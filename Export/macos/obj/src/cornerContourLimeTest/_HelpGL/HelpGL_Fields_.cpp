// Generated by Haxe 4.3.0-rc.1+5f599ba
#include <hxcpp.h>

#ifndef INCLUDED_cornerContourLimeTest__HelpGL_HelpGL_Fields_
#include <cornerContourLimeTest/_HelpGL/HelpGL_Fields_.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_abb715a94c4cd3c1_7_clearAll,"cornerContourLimeTest._HelpGL.HelpGL_Fields_","clearAll",0xf1f2aa6a,"cornerContourLimeTest._HelpGL.HelpGL_Fields_.clearAll","cornerContourLimeTest/HelpGL.hx",7,0xfa9bf5d5)
HX_LOCAL_STACK_FRAME(_hx_pos_abb715a94c4cd3c1_15_programSetup,"cornerContourLimeTest._HelpGL.HelpGL_Fields_","programSetup",0x41aa0d2f,"cornerContourLimeTest._HelpGL.HelpGL_Fields_.programSetup","cornerContourLimeTest/HelpGL.hx",15,0xfa9bf5d5)
HX_LOCAL_STACK_FRAME(_hx_pos_abb715a94c4cd3c1_35_shaderSetup,"cornerContourLimeTest._HelpGL.HelpGL_Fields_","shaderSetup",0x73cbce02,"cornerContourLimeTest._HelpGL.HelpGL_Fields_.shaderSetup","cornerContourLimeTest/HelpGL.hx",35,0xfa9bf5d5)
namespace cornerContourLimeTest{
namespace _HelpGL{

void HelpGL_Fields__obj::__construct() { }

Dynamic HelpGL_Fields__obj::__CreateEmpty() { return new HelpGL_Fields__obj; }

void *HelpGL_Fields__obj::_hx_vtable = 0;

Dynamic HelpGL_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< HelpGL_Fields__obj > _hx_result = new HelpGL_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool HelpGL_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x49a980e6;
}

void HelpGL_Fields__obj::clearAll( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,int width,int height){
            	HX_STACKFRAME(&_hx_pos_abb715a94c4cd3c1_7_clearAll)
HXLINE(   8)		gl->viewport(0,0,width,height);
HXLINE(   9)		gl->clearColor(((Float)0.0),((Float)0.0),((Float)0.0),((Float)1.0));
HXLINE(  10)		gl->clear(gl->COLOR_BUFFER_BIT);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(HelpGL_Fields__obj,clearAll,(void))

 ::lime::graphics::opengl::GLObject HelpGL_Fields__obj::programSetup( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,::String strVertex,::String strFragment){
            	HX_STACKFRAME(&_hx_pos_abb715a94c4cd3c1_15_programSetup)
HXLINE(  16)		 ::lime::graphics::opengl::GLObject program = gl->createProgram();
HXLINE(  17)		{
HXLINE(  17)			 ::lime::graphics::opengl::GLObject shader = gl->createShader(gl->VERTEX_SHADER);
HXDLIN(  17)			gl->shaderSource(shader,strVertex);
HXDLIN(  17)			gl->compileShader(shader);
HXDLIN(  17)			 ::lime::graphics::opengl::GLObject shader1;
HXDLIN(  17)			if (!(( (bool)(gl->getShaderParameter(shader,gl->COMPILE_STATUS)) ))) {
HXLINE(  17)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error compiling shader. ",bf,50,4d,23) + gl->getShaderInfoLog(shader))));
            			}
            			else {
HXLINE(  17)				shader1 = shader;
            			}
HXDLIN(  17)			gl->attachShader(program,shader1);
            		}
HXLINE(  18)		{
HXLINE(  18)			 ::lime::graphics::opengl::GLObject shader2 = gl->createShader(gl->FRAGMENT_SHADER);
HXDLIN(  18)			gl->shaderSource(shader2,strFragment);
HXDLIN(  18)			gl->compileShader(shader2);
HXDLIN(  18)			 ::lime::graphics::opengl::GLObject shader3;
HXDLIN(  18)			if (!(( (bool)(gl->getShaderParameter(shader2,gl->COMPILE_STATUS)) ))) {
HXLINE(  18)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error compiling shader. ",bf,50,4d,23) + gl->getShaderInfoLog(shader2))));
            			}
            			else {
HXLINE(  18)				shader3 = shader2;
            			}
HXDLIN(  18)			gl->attachShader(program,shader3);
            		}
HXLINE(  19)		gl->linkProgram(program);
HXLINE(  20)		if (!(( (bool)(gl->getProgramParameter(program,gl->LINK_STATUS)) ))) {
HXLINE(  21)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error linking program. ",46,e8,c7,f8) + gl->getProgramInfoLog(program))));
            		}
HXLINE(  24)		gl->validateProgram(program);
HXLINE(  25)		if (!(( (bool)(gl->getProgramParameter(program,gl->VALIDATE_STATUS)) ))) {
HXLINE(  26)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error validating program. ",21,2c,33,3d) + gl->getProgramInfoLog(program))));
            		}
HXLINE(  29)		gl->useProgram(program);
HXLINE(  30)		return program;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(HelpGL_Fields__obj,programSetup,return )

 ::lime::graphics::opengl::GLObject HelpGL_Fields__obj::shaderSetup( ::lime::_internal::backend::native::NativeOpenGLRenderContext gl,int shaderType,::String str){
            	HX_STACKFRAME(&_hx_pos_abb715a94c4cd3c1_35_shaderSetup)
HXLINE(  36)		 ::lime::graphics::opengl::GLObject shader = gl->createShader(shaderType);
HXLINE(  37)		gl->shaderSource(shader,str);
HXLINE(  38)		gl->compileShader(shader);
HXLINE(  39)		if (!(( (bool)(gl->getShaderParameter(shader,gl->COMPILE_STATUS)) ))) {
HXLINE(  40)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown((HX_("Error compiling shader. ",bf,50,4d,23) + gl->getShaderInfoLog(shader))));
            		}
HXLINE(  43)		return shader;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(HelpGL_Fields__obj,shaderSetup,return )


HelpGL_Fields__obj::HelpGL_Fields__obj()
{
}

bool HelpGL_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"clearAll") ) { outValue = clearAll_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"shaderSetup") ) { outValue = shaderSetup_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"programSetup") ) { outValue = programSetup_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *HelpGL_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *HelpGL_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class HelpGL_Fields__obj::__mClass;

static ::String HelpGL_Fields__obj_sStaticFields[] = {
	HX_("clearAll",94,f5,05,31),
	HX_("programSetup",59,35,93,42),
	HX_("shaderSetup",18,59,5c,51),
	::String(null())
};

void HelpGL_Fields__obj::__register()
{
	HelpGL_Fields__obj _hx_dummy;
	HelpGL_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("cornerContourLimeTest._HelpGL.HelpGL_Fields_",58,9e,e9,50);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &HelpGL_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(HelpGL_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< HelpGL_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = HelpGL_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = HelpGL_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace cornerContourLimeTest
} // end namespace _HelpGL
