// Generated by Haxe 4.3.0-rc.1+5f599ba
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_cornerContour_Contour
#include <cornerContour/Contour.h>
#endif
#ifndef INCLUDED_cornerContour_IPen
#include <cornerContour/IPen.h>
#endif
#ifndef INCLUDED_cornerContour_Sketcher
#include <cornerContour/Sketcher.h>
#endif
#ifndef INCLUDED_cornerContour__CurveMath_CurveMath_Fields_
#include <cornerContour/_CurveMath/CurveMath_Fields_.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_justPath_IPathContext
#include <justPath/IPathContext.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0fc6eed552804d6b_13_new,"cornerContour.Sketcher","new",0x0a6509f4,"cornerContour.Sketcher.new","cornerContour/Sketcher.hx",13,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_29_tracerLine,"cornerContour.Sketcher","tracerLine",0x2110f5cd,"cornerContour.Sketcher.tracerLine","cornerContour/Sketcher.hx",29,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_31_fillOnlyLine,"cornerContour.Sketcher","fillOnlyLine",0x27ad290f,"cornerContour.Sketcher.fillOnlyLine","cornerContour/Sketcher.hx",31,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_33_baseLine,"cornerContour.Sketcher","baseLine",0x58b29691,"cornerContour.Sketcher.baseLine","cornerContour/Sketcher.hx",33,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_38_crudeLine,"cornerContour.Sketcher","crudeLine",0x2181440f,"cornerContour.Sketcher.crudeLine","cornerContour/Sketcher.hx",38,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_41_roundEndLine,"cornerContour.Sketcher","roundEndLine",0x67ddbaad,"cornerContour.Sketcher.roundEndLine","cornerContour/Sketcher.hx",41,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_44_mediumLine,"cornerContour.Sketcher","mediumLine",0x529257f5,"cornerContour.Sketcher.mediumLine","cornerContour/Sketcher.hx",44,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_47_mediumOverlapLine,"cornerContour.Sketcher","mediumOverlapLine",0xac4d893a,"cornerContour.Sketcher.mediumOverlapLine","cornerContour/Sketcher.hx",47,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_50_fineLine,"cornerContour.Sketcher","fineLine",0x8a5f473a,"cornerContour.Sketcher.fineLine","cornerContour/Sketcher.hx",50,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_53_fineOverlapLine,"cornerContour.Sketcher","fineOverlapLine",0xc9253c95,"cornerContour.Sketcher.fineOverlapLine","cornerContour/Sketcher.hx",53,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_79_reset,"cornerContour.Sketcher","reset",0x82ca1063,"cornerContour.Sketcher.reset","cornerContour/Sketcher.hx",79,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_87_pointsNoEndOverlap,"cornerContour.Sketcher","pointsNoEndOverlap",0x17083c3c,"cornerContour.Sketcher.pointsNoEndOverlap","cornerContour/Sketcher.hx",87,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_109_pointsRewound,"cornerContour.Sketcher","pointsRewound",0xfa989cf1,"cornerContour.Sketcher.pointsRewound","cornerContour/Sketcher.hx",109,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_157_initDim,"cornerContour.Sketcher","initDim",0xc07297ac,"cornerContour.Sketcher.initDim","cornerContour/Sketcher.hx",157,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_159_updateDim,"cornerContour.Sketcher","updateDim",0x4183bb53,"cornerContour.Sketcher.updateDim","cornerContour/Sketcher.hx",159,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_167_moveTo,"cornerContour.Sketcher","moveTo",0xb238cdd8,"cornerContour.Sketcher.moveTo","cornerContour/Sketcher.hx",167,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_186_lastClock,"cornerContour.Sketcher","lastClock",0x53bad82c,"cornerContour.Sketcher.lastClock","cornerContour/Sketcher.hx",186,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_195_getEdges,"cornerContour.Sketcher","getEdges",0x26690b0c,"cornerContour.Sketcher.getEdges","cornerContour/Sketcher.hx",195,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_223_lineTo,"cornerContour.Sketcher","lineTo",0xd22c417b,"cornerContour.Sketcher.lineTo","cornerContour/Sketcher.hx",223,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_240_quadTo,"cornerContour.Sketcher","quadTo",0xb22b7d0e,"cornerContour.Sketcher.quadTo","cornerContour/Sketcher.hx",240,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_249_quadThru,"cornerContour.Sketcher","quadThru",0x31ca708a,"cornerContour.Sketcher.quadThru","cornerContour/Sketcher.hx",249,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_255_curveTo,"cornerContour.Sketcher","curveTo",0xc377f39e,"cornerContour.Sketcher.curveTo","cornerContour/Sketcher.hx",255,0xbca0dd9b)
HX_LOCAL_STACK_FRAME(_hx_pos_0fc6eed552804d6b_263_plotCoord,"cornerContour.Sketcher","plotCoord",0x70513968,"cornerContour.Sketcher.plotCoord","cornerContour/Sketcher.hx",263,0xbca0dd9b)
namespace cornerContour{

void Sketcher_obj::__construct(::Dynamic pen_,int sketchForm_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_0fc6eed552804d6b_13_new)
HXLINE(  16)		this->width = ((Float)0.01);
HXLINE(  15)		this->y = ((Float)0.);
HXLINE(  14)		this->x = ((Float)0.);
HXLINE(  58)		this->contour =  ::cornerContour::Contour_obj::__alloc( HX_CTX ,pen_,endLine_);
HXLINE(  59)		this->pen = pen_;
HXLINE(  60)		this->endLine = endLine_;
HXLINE(  61)		this->sketchForm = sketchForm_;
HXLINE(  62)		switch((int)(sketchForm_)){
            			case (int)0: {
HXLINE(  63)				this->line = this->tracerLine_dyn();
            			}
            			break;
            			case (int)1: {
HXLINE(  64)				this->line = this->baseLine_dyn();
            			}
            			break;
            			case (int)2: {
HXLINE(  65)				this->line = this->crudeLine_dyn();
            			}
            			break;
            			case (int)3: {
HXLINE(  66)				this->line = this->fillOnlyLine_dyn();
            			}
            			break;
            			case (int)4: {
HXLINE(  67)				this->line = this->fineLine_dyn();
            			}
            			break;
            			case (int)5: {
HXLINE(  68)				this->line = this->fineOverlapLine_dyn();
            			}
            			break;
            			case (int)6: {
HXLINE(  69)				this->line = this->mediumLine_dyn();
            			}
            			break;
            			case (int)7: {
HXLINE(  70)				this->line = this->mediumOverlapLine_dyn();
            			}
            			break;
            			case (int)8: {
HXLINE(  71)				this->line = this->roundEndLine_dyn();
            			}
            			break;
            		}
HXLINE(  73)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  74)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  75)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  76)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE(  77)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic Sketcher_obj::__CreateEmpty() { return new Sketcher_obj; }

void *Sketcher_obj::_hx_vtable = 0;

Dynamic Sketcher_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sketcher_obj > _hx_result = new Sketcher_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Sketcher_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x441bc2da;
}

static ::justPath::IPathContext_obj _hx_cornerContour_Sketcher__hx_justPath_IPathContext= {
	( void (::hx::Object::*)(Float,Float))&::cornerContour::Sketcher_obj::moveTo,
	( void (::hx::Object::*)(Float,Float))&::cornerContour::Sketcher_obj::lineTo,
	( void (::hx::Object::*)(Float,Float,Float,Float))&::cornerContour::Sketcher_obj::quadTo,
	( void (::hx::Object::*)(Float,Float,Float,Float,Float,Float))&::cornerContour::Sketcher_obj::curveTo,
};

void *Sketcher_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xed67b972: return &_hx_cornerContour_Sketcher__hx_justPath_IPathContext;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void Sketcher_obj::tracerLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_29_tracerLine)
HXDLIN(  29)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("cornerContour/Sketcher.hx",9b,dd,a0,bc),29,HX_("cornerContour.Sketcher",02,40,bc,91),HX_("tracerLine",e1,14,6f,0a)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,tracerLine,(void))

void Sketcher_obj::fillOnlyLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_31_fillOnlyLine)
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,fillOnlyLine,(void))

void Sketcher_obj::baseLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_33_baseLine)
HXLINE(  34)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("cornerContour/Sketcher.hx",9b,dd,a0,bc),29,HX_("cornerContour.Sketcher",02,40,bc,91),HX_("tracerLine",e1,14,6f,0a)));
HXLINE(  35)		{
HXLINE(  35)			 ::cornerContour::Contour _this = this->contour;
HXDLIN(  35)			Float ax_ = this->x;
HXDLIN(  35)			Float ay_ = this->y;
HXDLIN(  35)			Float width_ = this->width;
HXDLIN(  35)			_this->ax = x_;
HXDLIN(  35)			_this->ay = y_;
HXDLIN(  35)			_this->bx = ax_;
HXDLIN(  35)			_this->by = ay_;
HXDLIN(  35)			_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  35)			_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  35)			_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  35)			{
HXLINE(  35)				{
HXLINE(  35)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  35)					if ((_this->theta > 0)) {
HXLINE(  35)						if ((_this->halfA < 0)) {
HXLINE(  35)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  35)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  35)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  35)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  35)						if ((_this->halfA > 0)) {
HXLINE(  35)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  35)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  35)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  35)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  35)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  35)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  35)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  35)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  35)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  35)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  35)					_this->exPrev = _this->ex;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  35)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  35)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  35)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  35)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  35)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  35)			 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  35)			 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  35)			 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  35)			 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  35)			_this->ax = ax_;
HXDLIN(  35)			_this->ay = ay_;
HXDLIN(  35)			_this->bx = x_;
HXDLIN(  35)			_this->by = y_;
HXDLIN(  35)			{
HXLINE(  35)				{
HXLINE(  35)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  35)					if ((_this->theta > 0)) {
HXLINE(  35)						if ((_this->halfA < 0)) {
HXLINE(  35)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  35)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  35)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  35)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  35)						if ((_this->halfA > 0)) {
HXLINE(  35)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  35)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  35)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  35)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  35)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  35)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  35)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  35)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  35)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  35)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  35)					_this->exPrev = _this->ex;
            				}
HXDLIN(  35)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  35)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  35)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  35)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  35)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  35)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  35)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(exPrev_) ),( (Float)(eyPrev_) ),-1);
HXDLIN(  35)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,baseLine,(void))

void Sketcher_obj::crudeLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_38_crudeLine)
HXDLIN(  38)		 ::cornerContour::Contour _this = this->contour;
HXDLIN(  38)		Float ax_ = this->x;
HXDLIN(  38)		Float ay_ = this->y;
HXDLIN(  38)		Float width_ = this->width;
HXDLIN(  38)		_this->ax = x_;
HXDLIN(  38)		_this->ay = y_;
HXDLIN(  38)		_this->bx = ax_;
HXDLIN(  38)		_this->by = ay_;
HXDLIN(  38)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  38)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  38)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  38)		{
HXDLIN(  38)			{
HXDLIN(  38)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  38)				if ((_this->theta > 0)) {
HXDLIN(  38)					if ((_this->halfA < 0)) {
HXDLIN(  38)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  38)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  38)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  38)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  38)					if ((_this->halfA > 0)) {
HXDLIN(  38)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  38)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  38)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  38)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  38)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  38)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  38)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  38)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  38)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  38)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  38)				_this->exPrev = _this->ex;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  38)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  38)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  38)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  38)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  38)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  38)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  38)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  38)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  38)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  38)		_this->ax = ax_;
HXDLIN(  38)		_this->ay = ay_;
HXDLIN(  38)		_this->bx = x_;
HXDLIN(  38)		_this->by = y_;
HXDLIN(  38)		{
HXDLIN(  38)			{
HXDLIN(  38)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  38)				if ((_this->theta > 0)) {
HXDLIN(  38)					if ((_this->halfA < 0)) {
HXDLIN(  38)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  38)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  38)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  38)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  38)					if ((_this->halfA > 0)) {
HXDLIN(  38)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  38)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  38)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  38)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  38)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  38)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  38)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  38)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  38)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  38)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  38)				_this->exPrev = _this->ex;
            			}
HXDLIN(  38)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  38)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  38)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  38)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  38)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  38)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  38)		::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(exPrev_) ),( (Float)(eyPrev_) ),-1);
HXDLIN(  38)		::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,crudeLine,(void))

void Sketcher_obj::roundEndLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_41_roundEndLine)
HXDLIN(  41)		 ::cornerContour::Contour _this = this->contour;
HXDLIN(  41)		Float ax_ = this->x;
HXDLIN(  41)		Float ay_ = this->y;
HXDLIN(  41)		Float width_ = this->width;
HXDLIN(  41)		 ::Dynamic endLineCurve = 3;
HXDLIN(  41)		if (::hx::IsNull( endLineCurve )) {
HXDLIN(  41)			endLineCurve = 0;
            		}
HXDLIN(  41)		_this->ax = x_;
HXDLIN(  41)		_this->ay = y_;
HXDLIN(  41)		_this->bx = ax_;
HXDLIN(  41)		_this->by = ay_;
HXDLIN(  41)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  41)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  41)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  41)		{
HXDLIN(  41)			{
HXDLIN(  41)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  41)				if ((_this->theta > 0)) {
HXDLIN(  41)					if ((_this->halfA < 0)) {
HXDLIN(  41)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  41)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  41)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  41)					if ((_this->halfA > 0)) {
HXDLIN(  41)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  41)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  41)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  41)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  41)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  41)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  41)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  41)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  41)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  41)				_this->exPrev = _this->ex;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  41)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  41)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  41)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  41)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  41)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  41)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  41)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  41)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  41)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  41)		_this->ax = ax_;
HXDLIN(  41)		_this->ay = ay_;
HXDLIN(  41)		_this->bx = x_;
HXDLIN(  41)		_this->by = y_;
HXDLIN(  41)		{
HXDLIN(  41)			{
HXDLIN(  41)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  41)				if ((_this->theta > 0)) {
HXDLIN(  41)					if ((_this->halfA < 0)) {
HXDLIN(  41)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  41)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  41)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  41)					if ((_this->halfA > 0)) {
HXDLIN(  41)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  41)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  41)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  41)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  41)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  41)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  41)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  41)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  41)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  41)				_this->exPrev = _this->ex;
            			}
HXDLIN(  41)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  41)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  41)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  41)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  41)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  41)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  41)		 ::Dynamic _hx_switch_0 = endLineCurve;
            		if (  (_hx_switch_0==0) ){
HXDLIN(  41)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==1) ){
HXDLIN(  41)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  41)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  41)			{
HXDLIN(  41)				int color = 0;
HXDLIN(  41)				 ::Dynamic sides = 36;
HXDLIN(  41)				if (::hx::IsNull( sides )) {
HXDLIN(  41)					sides = 36;
            				}
HXDLIN(  41)				Float pi = ::Math_obj::PI;
HXDLIN(  41)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  41)				Float dif;
HXDLIN(  41)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if ((dif1 > 0)) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if ((dif1 < 0)) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if (smallest) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  41)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if (largest) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  41)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  41)				bool positive = (dif >= 0);
HXDLIN(  41)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  41)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  41)				Float angle = beta;
HXDLIN(  41)				Float cx;
HXDLIN(  41)				Float cy;
HXDLIN(  41)				Float bx = ( (Float)(0) );
HXDLIN(  41)				Float by = ( (Float)(0) );
HXDLIN(  41)				{
HXDLIN(  41)					int _g = 0;
HXDLIN(  41)					int _g1 = (totalSteps + 1);
HXDLIN(  41)					while((_g < _g1)){
HXDLIN(  41)						_g = (_g + 1);
HXDLIN(  41)						int i = (_g - 1);
HXDLIN(  41)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  41)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  41)						if ((i != 0)) {
HXDLIN(  41)							::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax_,ay_,bx,by,cx,cy,color);
            						}
HXDLIN(  41)						angle = (angle + step1);
HXDLIN(  41)						bx = cx;
HXDLIN(  41)						by = cy;
            					}
            				}
            			}
HXDLIN(  41)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==2) ){
HXDLIN(  41)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  41)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  41)			{
HXDLIN(  41)				int color = 0;
HXDLIN(  41)				 ::Dynamic sides = 36;
HXDLIN(  41)				if (::hx::IsNull( sides )) {
HXDLIN(  41)					sides = 36;
            				}
HXDLIN(  41)				Float pi = ::Math_obj::PI;
HXDLIN(  41)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  41)				Float dif;
HXDLIN(  41)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if ((dif1 > 0)) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if ((dif1 < 0)) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if (smallest) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  41)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  41)						Float f;
HXDLIN(  41)						bool f1;
HXDLIN(  41)						if ((beta >= 0)) {
HXDLIN(  41)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f1 = false;
            						}
HXDLIN(  41)						if (f1) {
HXDLIN(  41)							f = beta;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f = a;
            							}
            							else {
HXDLIN(  41)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this1 = f;
HXDLIN(  41)						Float za = this1;
HXDLIN(  41)						Float f2;
HXDLIN(  41)						bool f3;
HXDLIN(  41)						if ((gamma >= 0)) {
HXDLIN(  41)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  41)							f3 = false;
            						}
HXDLIN(  41)						if (f3) {
HXDLIN(  41)							f2 = gamma;
            						}
            						else {
HXDLIN(  41)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)							if ((a >= 0)) {
HXDLIN(  41)								f2 = a;
            							}
            							else {
HXDLIN(  41)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  41)						Float this2 = f2;
HXDLIN(  41)						Float zb = this2;
HXDLIN(  41)						Float fa = za;
HXDLIN(  41)						Float fb = zb;
HXDLIN(  41)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  41)						bool clockwise = (fa < fb);
HXDLIN(  41)						Float dif1;
HXDLIN(  41)						if (clockwise) {
HXDLIN(  41)							dif1 = theta;
            						}
            						else {
HXDLIN(  41)							dif1 = -(theta);
            						}
HXDLIN(  41)						if (largest) {
HXDLIN(  41)							dif = dif1;
            						}
            						else {
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  41)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  41)				bool positive = (dif >= 0);
HXDLIN(  41)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  41)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  41)				Float angle = beta;
HXDLIN(  41)				Float cx;
HXDLIN(  41)				Float cy;
HXDLIN(  41)				Float bx = ( (Float)(0) );
HXDLIN(  41)				Float by = ( (Float)(0) );
HXDLIN(  41)				{
HXDLIN(  41)					int _g = 0;
HXDLIN(  41)					int _g1 = (totalSteps + 1);
HXDLIN(  41)					while((_g < _g1)){
HXDLIN(  41)						_g = (_g + 1);
HXDLIN(  41)						int i = (_g - 1);
HXDLIN(  41)						cx = (x_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  41)						cy = (y_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  41)						if ((i != 0)) {
HXDLIN(  41)							::cornerContour::IPen_obj::triangle2DFill(_this->pen,x_,y_,bx,by,cx,cy,color);
            						}
HXDLIN(  41)						angle = (angle + step1);
HXDLIN(  41)						bx = cx;
HXDLIN(  41)						by = cy;
            					}
            				}
            			}
HXDLIN(  41)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==3) ){
HXDLIN(  41)			{
HXDLIN(  41)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  41)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  41)				{
HXDLIN(  41)					int color = 0;
HXDLIN(  41)					 ::Dynamic sides = 36;
HXDLIN(  41)					if (::hx::IsNull( sides )) {
HXDLIN(  41)						sides = 36;
            					}
HXDLIN(  41)					Float pi = ::Math_obj::PI;
HXDLIN(  41)					Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  41)					Float dif;
HXDLIN(  41)					switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            						case (int)0: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta >= 0)) {
HXDLIN(  41)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma >= 0)) {
HXDLIN(  41)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif1;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif1 = theta;
            							}
            							else {
HXDLIN(  41)								dif1 = -(theta);
            							}
HXDLIN(  41)							if ((dif1 > 0)) {
HXDLIN(  41)								dif = dif1;
            							}
            							else {
HXDLIN(  41)								dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            							}
            						}
            						break;
            						case (int)1: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta >= 0)) {
HXDLIN(  41)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma >= 0)) {
HXDLIN(  41)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif1;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif1 = theta;
            							}
            							else {
HXDLIN(  41)								dif1 = -(theta);
            							}
HXDLIN(  41)							if ((dif1 < 0)) {
HXDLIN(  41)								dif = dif1;
            							}
            							else {
HXDLIN(  41)								dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            							}
            						}
            						break;
            						case (int)2: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta >= 0)) {
HXDLIN(  41)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma >= 0)) {
HXDLIN(  41)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif1;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif1 = theta;
            							}
            							else {
HXDLIN(  41)								dif1 = -(theta);
            							}
HXDLIN(  41)							if (smallest) {
HXDLIN(  41)								dif = dif1;
            							}
            							else {
HXDLIN(  41)								if (clockwise) {
HXDLIN(  41)									dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXDLIN(  41)									dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            						case (int)3: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta >= 0)) {
HXDLIN(  41)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma >= 0)) {
HXDLIN(  41)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool largest = (theta > ::Math_obj::PI);
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif1;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif1 = theta;
            							}
            							else {
HXDLIN(  41)								dif1 = -(theta);
            							}
HXDLIN(  41)							if (largest) {
HXDLIN(  41)								dif = dif1;
            							}
            							else {
HXDLIN(  41)								if (clockwise) {
HXDLIN(  41)									dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXDLIN(  41)									dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            					}
HXDLIN(  41)					bool positive = (dif >= 0);
HXDLIN(  41)					int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  41)					Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  41)					Float angle = beta;
HXDLIN(  41)					Float cx;
HXDLIN(  41)					Float cy;
HXDLIN(  41)					Float bx = ( (Float)(0) );
HXDLIN(  41)					Float by = ( (Float)(0) );
HXDLIN(  41)					{
HXDLIN(  41)						int _g = 0;
HXDLIN(  41)						int _g1 = (totalSteps + 1);
HXDLIN(  41)						while((_g < _g1)){
HXDLIN(  41)							_g = (_g + 1);
HXDLIN(  41)							int i = (_g - 1);
HXDLIN(  41)							cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  41)							cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  41)							if ((i != 0)) {
HXDLIN(  41)								::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax_,ay_,bx,by,cx,cy,color);
            							}
HXDLIN(  41)							angle = (angle + step1);
HXDLIN(  41)							bx = cx;
HXDLIN(  41)							by = cy;
            						}
            					}
            				}
            			}
HXDLIN(  41)			{
HXDLIN(  41)				Float radius1 = (width_ / ( (Float)(2) ));
HXDLIN(  41)				Float beta1 = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  41)				Float gamma1 = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  41)				{
HXDLIN(  41)					int color1 = 0;
HXDLIN(  41)					 ::Dynamic sides1 = 36;
HXDLIN(  41)					if (::hx::IsNull( sides1 )) {
HXDLIN(  41)						sides1 = 36;
            					}
HXDLIN(  41)					Float pi1 = ::Math_obj::PI;
HXDLIN(  41)					Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  41)					Float dif1;
HXDLIN(  41)					switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            						case (int)0: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta1 >= 0)) {
HXDLIN(  41)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma1 >= 0)) {
HXDLIN(  41)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = theta;
            							}
            							else {
HXDLIN(  41)								dif = -(theta);
            							}
HXDLIN(  41)							if ((dif > 0)) {
HXDLIN(  41)								dif1 = dif;
            							}
            							else {
HXDLIN(  41)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            							}
            						}
            						break;
            						case (int)1: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta1 >= 0)) {
HXDLIN(  41)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma1 >= 0)) {
HXDLIN(  41)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = theta;
            							}
            							else {
HXDLIN(  41)								dif = -(theta);
            							}
HXDLIN(  41)							if ((dif < 0)) {
HXDLIN(  41)								dif1 = dif;
            							}
            							else {
HXDLIN(  41)								dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            							}
            						}
            						break;
            						case (int)2: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta1 >= 0)) {
HXDLIN(  41)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma1 >= 0)) {
HXDLIN(  41)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = theta;
            							}
            							else {
HXDLIN(  41)								dif = -(theta);
            							}
HXDLIN(  41)							if (smallest) {
HXDLIN(  41)								dif1 = dif;
            							}
            							else {
HXDLIN(  41)								if (clockwise) {
HXDLIN(  41)									dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXDLIN(  41)									dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            						case (int)3: {
HXDLIN(  41)							Float f;
HXDLIN(  41)							bool f1;
HXDLIN(  41)							if ((beta1 >= 0)) {
HXDLIN(  41)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f1 = false;
            							}
HXDLIN(  41)							if (f1) {
HXDLIN(  41)								f = beta1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f = a;
            								}
            								else {
HXDLIN(  41)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this1 = f;
HXDLIN(  41)							Float za = this1;
HXDLIN(  41)							Float f2;
HXDLIN(  41)							bool f3;
HXDLIN(  41)							if ((gamma1 >= 0)) {
HXDLIN(  41)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXDLIN(  41)								f3 = false;
            							}
HXDLIN(  41)							if (f3) {
HXDLIN(  41)								f2 = gamma1;
            							}
            							else {
HXDLIN(  41)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)								if ((a >= 0)) {
HXDLIN(  41)									f2 = a;
            								}
            								else {
HXDLIN(  41)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN(  41)							Float this2 = f2;
HXDLIN(  41)							Float zb = this2;
HXDLIN(  41)							Float fa = za;
HXDLIN(  41)							Float fb = zb;
HXDLIN(  41)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)							bool largest = (theta > ::Math_obj::PI);
HXDLIN(  41)							bool clockwise = (fa < fb);
HXDLIN(  41)							Float dif;
HXDLIN(  41)							if (clockwise) {
HXDLIN(  41)								dif = theta;
            							}
            							else {
HXDLIN(  41)								dif = -(theta);
            							}
HXDLIN(  41)							if (largest) {
HXDLIN(  41)								dif1 = dif;
            							}
            							else {
HXDLIN(  41)								if (clockwise) {
HXDLIN(  41)									dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXDLIN(  41)									dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            					}
HXDLIN(  41)					bool positive1 = (dif1 >= 0);
HXDLIN(  41)					int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN(  41)					Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN(  41)					Float angle1 = beta1;
HXDLIN(  41)					Float cx1;
HXDLIN(  41)					Float cy1;
HXDLIN(  41)					Float bx1 = ( (Float)(0) );
HXDLIN(  41)					Float by1 = ( (Float)(0) );
HXDLIN(  41)					{
HXDLIN(  41)						int _g2 = 0;
HXDLIN(  41)						int _g3 = (totalSteps1 + 1);
HXDLIN(  41)						while((_g2 < _g3)){
HXDLIN(  41)							_g2 = (_g2 + 1);
HXDLIN(  41)							int i = (_g2 - 1);
HXDLIN(  41)							cx1 = (x_ + (radius1 * ::Math_obj::sin(angle1)));
HXDLIN(  41)							cy1 = (y_ + (radius1 * ::Math_obj::cos(angle1)));
HXDLIN(  41)							if ((i != 0)) {
HXDLIN(  41)								::cornerContour::IPen_obj::triangle2DFill(_this->pen,x_,y_,bx1,by1,cx1,cy1,color1);
            							}
HXDLIN(  41)							angle1 = (angle1 + step3);
HXDLIN(  41)							bx1 = cx1;
HXDLIN(  41)							by1 = cy1;
            						}
            					}
            				}
            			}
HXDLIN(  41)			goto _hx_goto_5;
            		}
            		_hx_goto_5:;
HXDLIN(  41)		::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(exPrev_) ),( (Float)(eyPrev_) ),-1);
HXDLIN(  41)		::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,roundEndLine,(void))

void Sketcher_obj::mediumLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_44_mediumLine)
HXDLIN(  44)		 ::cornerContour::Contour _this = this->contour;
HXDLIN(  44)		Float ax_ = this->x;
HXDLIN(  44)		Float ay_ = this->y;
HXDLIN(  44)		Float width_ = this->width;
HXDLIN(  44)		bool overlap = false;
HXDLIN(  44)		 ::Dynamic oldAngle;
HXDLIN(  44)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  44)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  44)			oldAngle = null();
            		}
HXDLIN(  44)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  44)		_this->ax = x_;
HXDLIN(  44)		_this->ay = y_;
HXDLIN(  44)		_this->bx = ax_;
HXDLIN(  44)		_this->by = ay_;
HXDLIN(  44)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  44)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  44)		{
HXDLIN(  44)			{
HXDLIN(  44)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  44)				if ((_this->theta > 0)) {
HXDLIN(  44)					if ((_this->halfA < 0)) {
HXDLIN(  44)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  44)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  44)					if ((_this->halfA > 0)) {
HXDLIN(  44)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  44)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  44)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  44)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  44)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  44)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  44)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  44)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  44)				_this->exPrev = _this->ex;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  44)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  44)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  44)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  44)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  44)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  44)		_this->ax = ax_;
HXDLIN(  44)		_this->ay = ay_;
HXDLIN(  44)		_this->bx = x_;
HXDLIN(  44)		_this->by = y_;
HXDLIN(  44)		{
HXDLIN(  44)			{
HXDLIN(  44)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  44)				if ((_this->theta > 0)) {
HXDLIN(  44)					if ((_this->halfA < 0)) {
HXDLIN(  44)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  44)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  44)					if ((_this->halfA > 0)) {
HXDLIN(  44)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  44)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  44)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  44)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  44)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  44)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  44)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  44)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  44)				_this->exPrev = _this->ex;
            			}
HXDLIN(  44)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  44)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  44)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  44)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  44)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  44)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  44)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  44)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  44)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  44)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  44)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  44)		Float theta0;
HXDLIN(  44)		Float theta1;
HXDLIN(  44)		if (clockWise) {
HXDLIN(  44)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  44)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  44)		Float dif;
HXDLIN(  44)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  44)				Float f;
HXDLIN(  44)				bool f1;
HXDLIN(  44)				if ((theta0 >= 0)) {
HXDLIN(  44)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f1 = false;
            				}
HXDLIN(  44)				if (f1) {
HXDLIN(  44)					f = theta0;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f = a;
            					}
            					else {
HXDLIN(  44)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this1 = f;
HXDLIN(  44)				Float za = this1;
HXDLIN(  44)				Float f2;
HXDLIN(  44)				bool f3;
HXDLIN(  44)				if ((theta1 >= 0)) {
HXDLIN(  44)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f3 = false;
            				}
HXDLIN(  44)				if (f3) {
HXDLIN(  44)					f2 = theta1;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f2 = a;
            					}
            					else {
HXDLIN(  44)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this2 = f2;
HXDLIN(  44)				Float zb = this2;
HXDLIN(  44)				Float fa = za;
HXDLIN(  44)				Float fb = zb;
HXDLIN(  44)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)				bool clockwise = (fa < fb);
HXDLIN(  44)				Float dif1;
HXDLIN(  44)				if (clockwise) {
HXDLIN(  44)					dif1 = theta;
            				}
            				else {
HXDLIN(  44)					dif1 = -(theta);
            				}
HXDLIN(  44)				if ((dif1 > 0)) {
HXDLIN(  44)					dif = dif1;
            				}
            				else {
HXDLIN(  44)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  44)				Float f;
HXDLIN(  44)				bool f1;
HXDLIN(  44)				if ((theta0 >= 0)) {
HXDLIN(  44)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f1 = false;
            				}
HXDLIN(  44)				if (f1) {
HXDLIN(  44)					f = theta0;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f = a;
            					}
            					else {
HXDLIN(  44)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this1 = f;
HXDLIN(  44)				Float za = this1;
HXDLIN(  44)				Float f2;
HXDLIN(  44)				bool f3;
HXDLIN(  44)				if ((theta1 >= 0)) {
HXDLIN(  44)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f3 = false;
            				}
HXDLIN(  44)				if (f3) {
HXDLIN(  44)					f2 = theta1;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f2 = a;
            					}
            					else {
HXDLIN(  44)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this2 = f2;
HXDLIN(  44)				Float zb = this2;
HXDLIN(  44)				Float fa = za;
HXDLIN(  44)				Float fb = zb;
HXDLIN(  44)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)				bool clockwise = (fa < fb);
HXDLIN(  44)				Float dif1;
HXDLIN(  44)				if (clockwise) {
HXDLIN(  44)					dif1 = theta;
            				}
            				else {
HXDLIN(  44)					dif1 = -(theta);
            				}
HXDLIN(  44)				if ((dif1 < 0)) {
HXDLIN(  44)					dif = dif1;
            				}
            				else {
HXDLIN(  44)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  44)				Float f;
HXDLIN(  44)				bool f1;
HXDLIN(  44)				if ((theta0 >= 0)) {
HXDLIN(  44)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f1 = false;
            				}
HXDLIN(  44)				if (f1) {
HXDLIN(  44)					f = theta0;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f = a;
            					}
            					else {
HXDLIN(  44)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this1 = f;
HXDLIN(  44)				Float za = this1;
HXDLIN(  44)				Float f2;
HXDLIN(  44)				bool f3;
HXDLIN(  44)				if ((theta1 >= 0)) {
HXDLIN(  44)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f3 = false;
            				}
HXDLIN(  44)				if (f3) {
HXDLIN(  44)					f2 = theta1;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f2 = a;
            					}
            					else {
HXDLIN(  44)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this2 = f2;
HXDLIN(  44)				Float zb = this2;
HXDLIN(  44)				Float fa = za;
HXDLIN(  44)				Float fb = zb;
HXDLIN(  44)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  44)				bool clockwise = (fa < fb);
HXDLIN(  44)				Float dif1;
HXDLIN(  44)				if (clockwise) {
HXDLIN(  44)					dif1 = theta;
            				}
            				else {
HXDLIN(  44)					dif1 = -(theta);
            				}
HXDLIN(  44)				if (smallest) {
HXDLIN(  44)					dif = dif1;
            				}
            				else {
HXDLIN(  44)					if (clockwise) {
HXDLIN(  44)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  44)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  44)				Float f;
HXDLIN(  44)				bool f1;
HXDLIN(  44)				if ((theta0 >= 0)) {
HXDLIN(  44)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f1 = false;
            				}
HXDLIN(  44)				if (f1) {
HXDLIN(  44)					f = theta0;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f = a;
            					}
            					else {
HXDLIN(  44)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this1 = f;
HXDLIN(  44)				Float za = this1;
HXDLIN(  44)				Float f2;
HXDLIN(  44)				bool f3;
HXDLIN(  44)				if ((theta1 >= 0)) {
HXDLIN(  44)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f3 = false;
            				}
HXDLIN(  44)				if (f3) {
HXDLIN(  44)					f2 = theta1;
            				}
            				else {
HXDLIN(  44)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)					if ((a >= 0)) {
HXDLIN(  44)						f2 = a;
            					}
            					else {
HXDLIN(  44)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  44)				Float this2 = f2;
HXDLIN(  44)				Float zb = this2;
HXDLIN(  44)				Float fa = za;
HXDLIN(  44)				Float fb = zb;
HXDLIN(  44)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  44)				bool clockwise = (fa < fb);
HXDLIN(  44)				Float dif1;
HXDLIN(  44)				if (clockwise) {
HXDLIN(  44)					dif1 = theta;
            				}
            				else {
HXDLIN(  44)					dif1 = -(theta);
            				}
HXDLIN(  44)				if (largest) {
HXDLIN(  44)					dif = dif1;
            				}
            				else {
HXDLIN(  44)					if (clockwise) {
HXDLIN(  44)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  44)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  44)		bool _hx_tmp;
HXDLIN(  44)		if (!(overlap)) {
HXDLIN(  44)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  44)			_hx_tmp = false;
            		}
HXDLIN(  44)		if (_hx_tmp) {
HXDLIN(  44)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  44)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  44)			Float f;
HXDLIN(  44)			bool f1;
HXDLIN(  44)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  44)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  44)				f1 = false;
            			}
HXDLIN(  44)			if (f1) {
HXDLIN(  44)				f = theta0;
            			}
            			else {
HXDLIN(  44)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)				if ((a >= 0)) {
HXDLIN(  44)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  44)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  44)			Float this1 = f;
HXDLIN(  44)			Float start = this1;
HXDLIN(  44)			Float start2 = start;
HXDLIN(  44)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  44)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  44)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  44)		bool _hx_tmp1;
HXDLIN(  44)		if ((_this->count == 0)) {
HXDLIN(  44)			if ((_this->endLine != 1)) {
HXDLIN(  44)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  44)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  44)			_hx_tmp1 = false;
            		}
HXDLIN(  44)		if (_hx_tmp1) {
HXDLIN(  44)			Float ax = _this->ax;
HXDLIN(  44)			Float ay = _this->ay;
HXDLIN(  44)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  44)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  44)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  44)			{
HXDLIN(  44)				int color = -1;
HXDLIN(  44)				 ::Dynamic sides = 36;
HXDLIN(  44)				if (::hx::IsNull( sides )) {
HXDLIN(  44)					sides = 36;
            				}
HXDLIN(  44)				Float pi = ::Math_obj::PI;
HXDLIN(  44)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  44)				Float dif;
HXDLIN(  44)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  44)						Float f;
HXDLIN(  44)						bool f1;
HXDLIN(  44)						if ((beta >= 0)) {
HXDLIN(  44)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f1 = false;
            						}
HXDLIN(  44)						if (f1) {
HXDLIN(  44)							f = beta;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f = a;
            							}
            							else {
HXDLIN(  44)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this1 = f;
HXDLIN(  44)						Float za = this1;
HXDLIN(  44)						Float f2;
HXDLIN(  44)						bool f3;
HXDLIN(  44)						if ((gamma >= 0)) {
HXDLIN(  44)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f3 = false;
            						}
HXDLIN(  44)						if (f3) {
HXDLIN(  44)							f2 = gamma;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f2 = a;
            							}
            							else {
HXDLIN(  44)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this2 = f2;
HXDLIN(  44)						Float zb = this2;
HXDLIN(  44)						Float fa = za;
HXDLIN(  44)						Float fb = zb;
HXDLIN(  44)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)						bool clockwise = (fa < fb);
HXDLIN(  44)						Float dif1;
HXDLIN(  44)						if (clockwise) {
HXDLIN(  44)							dif1 = theta;
            						}
            						else {
HXDLIN(  44)							dif1 = -(theta);
            						}
HXDLIN(  44)						if ((dif1 > 0)) {
HXDLIN(  44)							dif = dif1;
            						}
            						else {
HXDLIN(  44)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  44)						Float f;
HXDLIN(  44)						bool f1;
HXDLIN(  44)						if ((beta >= 0)) {
HXDLIN(  44)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f1 = false;
            						}
HXDLIN(  44)						if (f1) {
HXDLIN(  44)							f = beta;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f = a;
            							}
            							else {
HXDLIN(  44)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this1 = f;
HXDLIN(  44)						Float za = this1;
HXDLIN(  44)						Float f2;
HXDLIN(  44)						bool f3;
HXDLIN(  44)						if ((gamma >= 0)) {
HXDLIN(  44)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f3 = false;
            						}
HXDLIN(  44)						if (f3) {
HXDLIN(  44)							f2 = gamma;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f2 = a;
            							}
            							else {
HXDLIN(  44)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this2 = f2;
HXDLIN(  44)						Float zb = this2;
HXDLIN(  44)						Float fa = za;
HXDLIN(  44)						Float fb = zb;
HXDLIN(  44)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)						bool clockwise = (fa < fb);
HXDLIN(  44)						Float dif1;
HXDLIN(  44)						if (clockwise) {
HXDLIN(  44)							dif1 = theta;
            						}
            						else {
HXDLIN(  44)							dif1 = -(theta);
            						}
HXDLIN(  44)						if ((dif1 < 0)) {
HXDLIN(  44)							dif = dif1;
            						}
            						else {
HXDLIN(  44)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  44)						Float f;
HXDLIN(  44)						bool f1;
HXDLIN(  44)						if ((beta >= 0)) {
HXDLIN(  44)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f1 = false;
            						}
HXDLIN(  44)						if (f1) {
HXDLIN(  44)							f = beta;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f = a;
            							}
            							else {
HXDLIN(  44)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this1 = f;
HXDLIN(  44)						Float za = this1;
HXDLIN(  44)						Float f2;
HXDLIN(  44)						bool f3;
HXDLIN(  44)						if ((gamma >= 0)) {
HXDLIN(  44)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f3 = false;
            						}
HXDLIN(  44)						if (f3) {
HXDLIN(  44)							f2 = gamma;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f2 = a;
            							}
            							else {
HXDLIN(  44)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this2 = f2;
HXDLIN(  44)						Float zb = this2;
HXDLIN(  44)						Float fa = za;
HXDLIN(  44)						Float fb = zb;
HXDLIN(  44)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  44)						bool clockwise = (fa < fb);
HXDLIN(  44)						Float dif1;
HXDLIN(  44)						if (clockwise) {
HXDLIN(  44)							dif1 = theta;
            						}
            						else {
HXDLIN(  44)							dif1 = -(theta);
            						}
HXDLIN(  44)						if (smallest) {
HXDLIN(  44)							dif = dif1;
            						}
            						else {
HXDLIN(  44)							if (clockwise) {
HXDLIN(  44)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  44)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  44)						Float f;
HXDLIN(  44)						bool f1;
HXDLIN(  44)						if ((beta >= 0)) {
HXDLIN(  44)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f1 = false;
            						}
HXDLIN(  44)						if (f1) {
HXDLIN(  44)							f = beta;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f = a;
            							}
            							else {
HXDLIN(  44)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this1 = f;
HXDLIN(  44)						Float za = this1;
HXDLIN(  44)						Float f2;
HXDLIN(  44)						bool f3;
HXDLIN(  44)						if ((gamma >= 0)) {
HXDLIN(  44)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  44)							f3 = false;
            						}
HXDLIN(  44)						if (f3) {
HXDLIN(  44)							f2 = gamma;
            						}
            						else {
HXDLIN(  44)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  44)							if ((a >= 0)) {
HXDLIN(  44)								f2 = a;
            							}
            							else {
HXDLIN(  44)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  44)						Float this2 = f2;
HXDLIN(  44)						Float zb = this2;
HXDLIN(  44)						Float fa = za;
HXDLIN(  44)						Float fb = zb;
HXDLIN(  44)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  44)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  44)						bool clockwise = (fa < fb);
HXDLIN(  44)						Float dif1;
HXDLIN(  44)						if (clockwise) {
HXDLIN(  44)							dif1 = theta;
            						}
            						else {
HXDLIN(  44)							dif1 = -(theta);
            						}
HXDLIN(  44)						if (largest) {
HXDLIN(  44)							dif = dif1;
            						}
            						else {
HXDLIN(  44)							if (clockwise) {
HXDLIN(  44)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  44)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  44)				bool positive = (dif >= 0);
HXDLIN(  44)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  44)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  44)				Float angle = beta;
HXDLIN(  44)				Float cx;
HXDLIN(  44)				Float cy;
HXDLIN(  44)				Float bx = ( (Float)(0) );
HXDLIN(  44)				Float by = ( (Float)(0) );
HXDLIN(  44)				int p2 = temp->length;
HXDLIN(  44)				{
HXDLIN(  44)					int _g = 0;
HXDLIN(  44)					int _g1 = (totalSteps + 1);
HXDLIN(  44)					while((_g < _g1)){
HXDLIN(  44)						_g = (_g + 1);
HXDLIN(  44)						int i = (_g - 1);
HXDLIN(  44)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  44)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  44)						p2 = (p2 + 1);
HXDLIN(  44)						temp[(p2 - 1)] = cx;
HXDLIN(  44)						p2 = (p2 + 1);
HXDLIN(  44)						temp[(p2 - 1)] = cy;
HXDLIN(  44)						if ((i != 0)) {
HXDLIN(  44)							::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            						}
HXDLIN(  44)						angle = (angle + step1);
HXDLIN(  44)						bx = cx;
HXDLIN(  44)						by = cy;
            					}
            				}
            			}
HXDLIN(  44)			int pA = _this->pointsAnti->length;
HXDLIN(  44)			int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  44)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  44)			{
HXDLIN(  44)				int _g2 = 0;
HXDLIN(  44)				int _g3 = p4;
HXDLIN(  44)				while((_g2 < _g3)){
HXDLIN(  44)					_g2 = (_g2 + 1);
HXDLIN(  44)					int i = (_g2 - 1);
HXDLIN(  44)					pA = (pA + 1);
HXDLIN(  44)					_this->pointsAnti[(pA - 1)] = temp->__get(((len - (2 * i)) + 1));
HXDLIN(  44)					pA = (pA + 1);
HXDLIN(  44)					_this->pointsAnti[(pA - 1)] = temp->__get((len - (2 * i)));
            				}
            			}
HXDLIN(  44)			int pC = _this->pointsClock->length;
HXDLIN(  44)			{
HXDLIN(  44)				int _g4 = 0;
HXDLIN(  44)				int _g5 = p4;
HXDLIN(  44)				while((_g4 < _g5)){
HXDLIN(  44)					_g4 = (_g4 + 1);
HXDLIN(  44)					int i = (_g4 - 1);
HXDLIN(  44)					pC = (pC + 1);
HXDLIN(  44)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len) + 1));
HXDLIN(  44)					pC = (pC + 1);
HXDLIN(  44)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len));
            				}
            			}
            		}
HXDLIN(  44)		if (overlap) {
HXDLIN(  44)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  44)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            		}
            		else {
HXDLIN(  44)			if ((_this->count != 0)) {
HXDLIN(  44)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  44)			{
HXDLIN(  44)				_this->quadIndex = ::cornerContour::IPen_obj::get_pos(_this->pen);
HXDLIN(  44)				if ((_this->count == 0)) {
HXDLIN(  44)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  44)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  44)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  44)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  44)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  44)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  44)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  44)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  44)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  44)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            				}
            				else {
HXDLIN(  44)					bool _hx_tmp;
HXDLIN(  44)					if (clockWise) {
HXDLIN(  44)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  44)						_hx_tmp = false;
            					}
HXDLIN(  44)					if (_hx_tmp) {
HXDLIN(  44)						_this->penultimateAX = _this->jx;
HXDLIN(  44)						_this->penultimateAY = _this->jy;
HXDLIN(  44)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  44)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  44)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  44)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  44)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  44)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            					}
HXDLIN(  44)					bool _hx_tmp1;
HXDLIN(  44)					if (clockWise) {
HXDLIN(  44)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  44)						_hx_tmp1 = false;
            					}
HXDLIN(  44)					if (_hx_tmp1) {
HXDLIN(  44)						_this->penultimateAX = _this->jx;
HXDLIN(  44)						_this->penultimateAY = _this->jy;
HXDLIN(  44)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  44)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  44)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  44)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  44)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  44)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            					}
HXDLIN(  44)					bool _hx_tmp2;
HXDLIN(  44)					if (!(clockWise)) {
HXDLIN(  44)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  44)						_hx_tmp2 = false;
            					}
HXDLIN(  44)					if (_hx_tmp2) {
HXDLIN(  44)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  44)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  44)						_this->lastClockX = _this->jx;
HXDLIN(  44)						_this->lastClockY = _this->jy;
HXDLIN(  44)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  44)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  44)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  44)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),_this->jx,_this->jy,-1);
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            					}
HXDLIN(  44)					bool _hx_tmp3;
HXDLIN(  44)					if (!(clockWise)) {
HXDLIN(  44)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  44)						_hx_tmp3 = false;
            					}
HXDLIN(  44)					if (_hx_tmp3) {
HXDLIN(  44)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  44)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  44)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  44)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  44)						_this->penultimateCX = _this->jx;
HXDLIN(  44)						_this->penultimateCY = _this->jy;
HXDLIN(  44)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  44)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  44)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),_this->jx,_this->jy,( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            					}
            				}
            			}
            		}
HXDLIN(  44)		if ((_this->count != 0)) {
HXDLIN(  44)			if (overlap) {
HXDLIN(  44)				if (clockWise) {
HXDLIN(  44)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),_this->ax,_this->ay,-1);
            				}
            				else {
HXDLIN(  44)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),_this->ax,_this->ay,-1);
            				}
            			}
            			else {
HXDLIN(  44)				if (clockWise) {
HXDLIN(  44)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),_this->jx,_this->jy,-1);
            				}
            				else {
HXDLIN(  44)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),_this->jx,_this->jy,-1);
            				}
            			}
            		}
HXDLIN(  44)		{
HXDLIN(  44)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  44)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  44)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  44)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  44)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  44)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  44)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  44)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  44)		_this->jxOld = _this->jx;
HXDLIN(  44)		_this->jyOld = _this->jy;
HXDLIN(  44)		_this->lastClock = clockWise;
HXDLIN(  44)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,mediumLine,(void))

void Sketcher_obj::mediumOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_47_mediumOverlapLine)
HXDLIN(  47)		 ::cornerContour::Contour _this = this->contour;
HXDLIN(  47)		Float ax_ = this->x;
HXDLIN(  47)		Float ay_ = this->y;
HXDLIN(  47)		Float width_ = this->width;
HXDLIN(  47)		 ::Dynamic oldAngle;
HXDLIN(  47)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  47)			oldAngle = null();
            		}
HXDLIN(  47)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  47)		_this->ax = x_;
HXDLIN(  47)		_this->ay = y_;
HXDLIN(  47)		_this->bx = ax_;
HXDLIN(  47)		_this->by = ay_;
HXDLIN(  47)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  47)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  47)		{
HXDLIN(  47)			{
HXDLIN(  47)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  47)				if ((_this->theta > 0)) {
HXDLIN(  47)					if ((_this->halfA < 0)) {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  47)					if ((_this->halfA > 0)) {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  47)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  47)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  47)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  47)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  47)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  47)				_this->exPrev = _this->ex;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  47)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  47)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  47)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  47)		_this->ax = ax_;
HXDLIN(  47)		_this->ay = ay_;
HXDLIN(  47)		_this->bx = x_;
HXDLIN(  47)		_this->by = y_;
HXDLIN(  47)		{
HXDLIN(  47)			{
HXDLIN(  47)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  47)				if ((_this->theta > 0)) {
HXDLIN(  47)					if ((_this->halfA < 0)) {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  47)					if ((_this->halfA > 0)) {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  47)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  47)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  47)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  47)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  47)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  47)				_this->exPrev = _this->ex;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  47)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  47)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  47)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  47)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  47)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  47)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  47)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  47)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  47)		Float theta0;
HXDLIN(  47)		Float theta1;
HXDLIN(  47)		if (clockWise) {
HXDLIN(  47)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  47)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  47)		Float dif;
HXDLIN(  47)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  47)				Float f;
HXDLIN(  47)				bool f1;
HXDLIN(  47)				if ((theta0 >= 0)) {
HXDLIN(  47)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f1 = false;
            				}
HXDLIN(  47)				if (f1) {
HXDLIN(  47)					f = theta0;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f = a;
            					}
            					else {
HXDLIN(  47)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this1 = f;
HXDLIN(  47)				Float za = this1;
HXDLIN(  47)				Float f2;
HXDLIN(  47)				bool f3;
HXDLIN(  47)				if ((theta1 >= 0)) {
HXDLIN(  47)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f3 = false;
            				}
HXDLIN(  47)				if (f3) {
HXDLIN(  47)					f2 = theta1;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f2 = a;
            					}
            					else {
HXDLIN(  47)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this2 = f2;
HXDLIN(  47)				Float zb = this2;
HXDLIN(  47)				Float fa = za;
HXDLIN(  47)				Float fb = zb;
HXDLIN(  47)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)				bool clockwise = (fa < fb);
HXDLIN(  47)				Float dif1;
HXDLIN(  47)				if (clockwise) {
HXDLIN(  47)					dif1 = theta;
            				}
            				else {
HXDLIN(  47)					dif1 = -(theta);
            				}
HXDLIN(  47)				if ((dif1 > 0)) {
HXDLIN(  47)					dif = dif1;
            				}
            				else {
HXDLIN(  47)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  47)				Float f;
HXDLIN(  47)				bool f1;
HXDLIN(  47)				if ((theta0 >= 0)) {
HXDLIN(  47)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f1 = false;
            				}
HXDLIN(  47)				if (f1) {
HXDLIN(  47)					f = theta0;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f = a;
            					}
            					else {
HXDLIN(  47)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this1 = f;
HXDLIN(  47)				Float za = this1;
HXDLIN(  47)				Float f2;
HXDLIN(  47)				bool f3;
HXDLIN(  47)				if ((theta1 >= 0)) {
HXDLIN(  47)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f3 = false;
            				}
HXDLIN(  47)				if (f3) {
HXDLIN(  47)					f2 = theta1;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f2 = a;
            					}
            					else {
HXDLIN(  47)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this2 = f2;
HXDLIN(  47)				Float zb = this2;
HXDLIN(  47)				Float fa = za;
HXDLIN(  47)				Float fb = zb;
HXDLIN(  47)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)				bool clockwise = (fa < fb);
HXDLIN(  47)				Float dif1;
HXDLIN(  47)				if (clockwise) {
HXDLIN(  47)					dif1 = theta;
            				}
            				else {
HXDLIN(  47)					dif1 = -(theta);
            				}
HXDLIN(  47)				if ((dif1 < 0)) {
HXDLIN(  47)					dif = dif1;
            				}
            				else {
HXDLIN(  47)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  47)				Float f;
HXDLIN(  47)				bool f1;
HXDLIN(  47)				if ((theta0 >= 0)) {
HXDLIN(  47)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f1 = false;
            				}
HXDLIN(  47)				if (f1) {
HXDLIN(  47)					f = theta0;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f = a;
            					}
            					else {
HXDLIN(  47)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this1 = f;
HXDLIN(  47)				Float za = this1;
HXDLIN(  47)				Float f2;
HXDLIN(  47)				bool f3;
HXDLIN(  47)				if ((theta1 >= 0)) {
HXDLIN(  47)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f3 = false;
            				}
HXDLIN(  47)				if (f3) {
HXDLIN(  47)					f2 = theta1;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f2 = a;
            					}
            					else {
HXDLIN(  47)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this2 = f2;
HXDLIN(  47)				Float zb = this2;
HXDLIN(  47)				Float fa = za;
HXDLIN(  47)				Float fb = zb;
HXDLIN(  47)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  47)				bool clockwise = (fa < fb);
HXDLIN(  47)				Float dif1;
HXDLIN(  47)				if (clockwise) {
HXDLIN(  47)					dif1 = theta;
            				}
            				else {
HXDLIN(  47)					dif1 = -(theta);
            				}
HXDLIN(  47)				if (smallest) {
HXDLIN(  47)					dif = dif1;
            				}
            				else {
HXDLIN(  47)					if (clockwise) {
HXDLIN(  47)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  47)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  47)				Float f;
HXDLIN(  47)				bool f1;
HXDLIN(  47)				if ((theta0 >= 0)) {
HXDLIN(  47)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f1 = false;
            				}
HXDLIN(  47)				if (f1) {
HXDLIN(  47)					f = theta0;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f = a;
            					}
            					else {
HXDLIN(  47)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this1 = f;
HXDLIN(  47)				Float za = this1;
HXDLIN(  47)				Float f2;
HXDLIN(  47)				bool f3;
HXDLIN(  47)				if ((theta1 >= 0)) {
HXDLIN(  47)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  47)					f3 = false;
            				}
HXDLIN(  47)				if (f3) {
HXDLIN(  47)					f2 = theta1;
            				}
            				else {
HXDLIN(  47)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)					if ((a >= 0)) {
HXDLIN(  47)						f2 = a;
            					}
            					else {
HXDLIN(  47)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  47)				Float this2 = f2;
HXDLIN(  47)				Float zb = this2;
HXDLIN(  47)				Float fa = za;
HXDLIN(  47)				Float fb = zb;
HXDLIN(  47)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  47)				bool clockwise = (fa < fb);
HXDLIN(  47)				Float dif1;
HXDLIN(  47)				if (clockwise) {
HXDLIN(  47)					dif1 = theta;
            				}
            				else {
HXDLIN(  47)					dif1 = -(theta);
            				}
HXDLIN(  47)				if (largest) {
HXDLIN(  47)					dif = dif1;
            				}
            				else {
HXDLIN(  47)					if (clockwise) {
HXDLIN(  47)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  47)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  47)		bool _hx_tmp;
HXDLIN(  47)		if ((_this->count == 0)) {
HXDLIN(  47)			if ((_this->endLine != 1)) {
HXDLIN(  47)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  47)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  47)			_hx_tmp = false;
            		}
HXDLIN(  47)		if (_hx_tmp) {
HXDLIN(  47)			Float ax = _this->ax;
HXDLIN(  47)			Float ay = _this->ay;
HXDLIN(  47)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  47)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  47)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  47)			{
HXDLIN(  47)				int color = -1;
HXDLIN(  47)				 ::Dynamic sides = 36;
HXDLIN(  47)				if (::hx::IsNull( sides )) {
HXDLIN(  47)					sides = 36;
            				}
HXDLIN(  47)				Float pi = ::Math_obj::PI;
HXDLIN(  47)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  47)				Float dif;
HXDLIN(  47)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  47)						Float f;
HXDLIN(  47)						bool f1;
HXDLIN(  47)						if ((beta >= 0)) {
HXDLIN(  47)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f1 = false;
            						}
HXDLIN(  47)						if (f1) {
HXDLIN(  47)							f = beta;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f = a;
            							}
            							else {
HXDLIN(  47)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this1 = f;
HXDLIN(  47)						Float za = this1;
HXDLIN(  47)						Float f2;
HXDLIN(  47)						bool f3;
HXDLIN(  47)						if ((gamma >= 0)) {
HXDLIN(  47)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f3 = false;
            						}
HXDLIN(  47)						if (f3) {
HXDLIN(  47)							f2 = gamma;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f2 = a;
            							}
            							else {
HXDLIN(  47)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this2 = f2;
HXDLIN(  47)						Float zb = this2;
HXDLIN(  47)						Float fa = za;
HXDLIN(  47)						Float fb = zb;
HXDLIN(  47)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)						bool clockwise = (fa < fb);
HXDLIN(  47)						Float dif1;
HXDLIN(  47)						if (clockwise) {
HXDLIN(  47)							dif1 = theta;
            						}
            						else {
HXDLIN(  47)							dif1 = -(theta);
            						}
HXDLIN(  47)						if ((dif1 > 0)) {
HXDLIN(  47)							dif = dif1;
            						}
            						else {
HXDLIN(  47)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  47)						Float f;
HXDLIN(  47)						bool f1;
HXDLIN(  47)						if ((beta >= 0)) {
HXDLIN(  47)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f1 = false;
            						}
HXDLIN(  47)						if (f1) {
HXDLIN(  47)							f = beta;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f = a;
            							}
            							else {
HXDLIN(  47)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this1 = f;
HXDLIN(  47)						Float za = this1;
HXDLIN(  47)						Float f2;
HXDLIN(  47)						bool f3;
HXDLIN(  47)						if ((gamma >= 0)) {
HXDLIN(  47)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f3 = false;
            						}
HXDLIN(  47)						if (f3) {
HXDLIN(  47)							f2 = gamma;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f2 = a;
            							}
            							else {
HXDLIN(  47)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this2 = f2;
HXDLIN(  47)						Float zb = this2;
HXDLIN(  47)						Float fa = za;
HXDLIN(  47)						Float fb = zb;
HXDLIN(  47)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)						bool clockwise = (fa < fb);
HXDLIN(  47)						Float dif1;
HXDLIN(  47)						if (clockwise) {
HXDLIN(  47)							dif1 = theta;
            						}
            						else {
HXDLIN(  47)							dif1 = -(theta);
            						}
HXDLIN(  47)						if ((dif1 < 0)) {
HXDLIN(  47)							dif = dif1;
            						}
            						else {
HXDLIN(  47)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  47)						Float f;
HXDLIN(  47)						bool f1;
HXDLIN(  47)						if ((beta >= 0)) {
HXDLIN(  47)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f1 = false;
            						}
HXDLIN(  47)						if (f1) {
HXDLIN(  47)							f = beta;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f = a;
            							}
            							else {
HXDLIN(  47)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this1 = f;
HXDLIN(  47)						Float za = this1;
HXDLIN(  47)						Float f2;
HXDLIN(  47)						bool f3;
HXDLIN(  47)						if ((gamma >= 0)) {
HXDLIN(  47)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f3 = false;
            						}
HXDLIN(  47)						if (f3) {
HXDLIN(  47)							f2 = gamma;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f2 = a;
            							}
            							else {
HXDLIN(  47)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this2 = f2;
HXDLIN(  47)						Float zb = this2;
HXDLIN(  47)						Float fa = za;
HXDLIN(  47)						Float fb = zb;
HXDLIN(  47)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  47)						bool clockwise = (fa < fb);
HXDLIN(  47)						Float dif1;
HXDLIN(  47)						if (clockwise) {
HXDLIN(  47)							dif1 = theta;
            						}
            						else {
HXDLIN(  47)							dif1 = -(theta);
            						}
HXDLIN(  47)						if (smallest) {
HXDLIN(  47)							dif = dif1;
            						}
            						else {
HXDLIN(  47)							if (clockwise) {
HXDLIN(  47)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  47)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  47)						Float f;
HXDLIN(  47)						bool f1;
HXDLIN(  47)						if ((beta >= 0)) {
HXDLIN(  47)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f1 = false;
            						}
HXDLIN(  47)						if (f1) {
HXDLIN(  47)							f = beta;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f = a;
            							}
            							else {
HXDLIN(  47)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this1 = f;
HXDLIN(  47)						Float za = this1;
HXDLIN(  47)						Float f2;
HXDLIN(  47)						bool f3;
HXDLIN(  47)						if ((gamma >= 0)) {
HXDLIN(  47)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  47)							f3 = false;
            						}
HXDLIN(  47)						if (f3) {
HXDLIN(  47)							f2 = gamma;
            						}
            						else {
HXDLIN(  47)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  47)							if ((a >= 0)) {
HXDLIN(  47)								f2 = a;
            							}
            							else {
HXDLIN(  47)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  47)						Float this2 = f2;
HXDLIN(  47)						Float zb = this2;
HXDLIN(  47)						Float fa = za;
HXDLIN(  47)						Float fb = zb;
HXDLIN(  47)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  47)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  47)						bool clockwise = (fa < fb);
HXDLIN(  47)						Float dif1;
HXDLIN(  47)						if (clockwise) {
HXDLIN(  47)							dif1 = theta;
            						}
            						else {
HXDLIN(  47)							dif1 = -(theta);
            						}
HXDLIN(  47)						if (largest) {
HXDLIN(  47)							dif = dif1;
            						}
            						else {
HXDLIN(  47)							if (clockwise) {
HXDLIN(  47)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  47)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  47)				bool positive = (dif >= 0);
HXDLIN(  47)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  47)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  47)				Float angle = beta;
HXDLIN(  47)				Float cx;
HXDLIN(  47)				Float cy;
HXDLIN(  47)				Float bx = ( (Float)(0) );
HXDLIN(  47)				Float by = ( (Float)(0) );
HXDLIN(  47)				int p2 = temp->length;
HXDLIN(  47)				{
HXDLIN(  47)					int _g = 0;
HXDLIN(  47)					int _g1 = (totalSteps + 1);
HXDLIN(  47)					while((_g < _g1)){
HXDLIN(  47)						_g = (_g + 1);
HXDLIN(  47)						int i = (_g - 1);
HXDLIN(  47)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  47)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  47)						p2 = (p2 + 1);
HXDLIN(  47)						temp[(p2 - 1)] = cx;
HXDLIN(  47)						p2 = (p2 + 1);
HXDLIN(  47)						temp[(p2 - 1)] = cy;
HXDLIN(  47)						if ((i != 0)) {
HXDLIN(  47)							::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            						}
HXDLIN(  47)						angle = (angle + step1);
HXDLIN(  47)						bx = cx;
HXDLIN(  47)						by = cy;
            					}
            				}
            			}
HXDLIN(  47)			int pA = _this->pointsAnti->length;
HXDLIN(  47)			int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  47)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  47)			{
HXDLIN(  47)				int _g2 = 0;
HXDLIN(  47)				int _g3 = p4;
HXDLIN(  47)				while((_g2 < _g3)){
HXDLIN(  47)					_g2 = (_g2 + 1);
HXDLIN(  47)					int i = (_g2 - 1);
HXDLIN(  47)					pA = (pA + 1);
HXDLIN(  47)					_this->pointsAnti[(pA - 1)] = temp->__get(((len - (2 * i)) + 1));
HXDLIN(  47)					pA = (pA + 1);
HXDLIN(  47)					_this->pointsAnti[(pA - 1)] = temp->__get((len - (2 * i)));
            				}
            			}
HXDLIN(  47)			int pC = _this->pointsClock->length;
HXDLIN(  47)			{
HXDLIN(  47)				int _g4 = 0;
HXDLIN(  47)				int _g5 = p4;
HXDLIN(  47)				while((_g4 < _g5)){
HXDLIN(  47)					_g4 = (_g4 + 1);
HXDLIN(  47)					int i = (_g4 - 1);
HXDLIN(  47)					pC = (pC + 1);
HXDLIN(  47)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len) + 1));
HXDLIN(  47)					pC = (pC + 1);
HXDLIN(  47)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len));
            				}
            			}
            		}
HXDLIN(  47)		{
HXDLIN(  47)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  47)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            		}
HXDLIN(  47)		if ((_this->count != 0)) {
HXDLIN(  47)			if (clockWise) {
HXDLIN(  47)				::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),_this->ax,_this->ay,-1);
            			}
            			else {
HXDLIN(  47)				::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),_this->ax,_this->ay,-1);
            			}
            		}
HXDLIN(  47)		{
HXDLIN(  47)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  47)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  47)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  47)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  47)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  47)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  47)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  47)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  47)		_this->jxOld = _this->jx;
HXDLIN(  47)		_this->jyOld = _this->jy;
HXDLIN(  47)		_this->lastClock = clockWise;
HXDLIN(  47)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,mediumOverlapLine,(void))

void Sketcher_obj::fineLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_50_fineLine)
HXDLIN(  50)		 ::cornerContour::Contour _this = this->contour;
HXDLIN(  50)		Float ax_ = this->x;
HXDLIN(  50)		Float ay_ = this->y;
HXDLIN(  50)		Float width_ = this->width;
HXDLIN(  50)		bool overlap = false;
HXDLIN(  50)		 ::Dynamic oldAngle;
HXDLIN(  50)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  50)			oldAngle = null();
            		}
HXDLIN(  50)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  50)		_this->ax = x_;
HXDLIN(  50)		_this->ay = y_;
HXDLIN(  50)		_this->bx = ax_;
HXDLIN(  50)		_this->by = ay_;
HXDLIN(  50)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  50)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  50)		{
HXDLIN(  50)			{
HXDLIN(  50)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  50)				if ((_this->theta > 0)) {
HXDLIN(  50)					if ((_this->halfA < 0)) {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  50)					if ((_this->halfA > 0)) {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  50)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  50)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  50)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  50)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  50)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  50)				_this->exPrev = _this->ex;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  50)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  50)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  50)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  50)		_this->ax = ax_;
HXDLIN(  50)		_this->ay = ay_;
HXDLIN(  50)		_this->bx = x_;
HXDLIN(  50)		_this->by = y_;
HXDLIN(  50)		{
HXDLIN(  50)			{
HXDLIN(  50)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  50)				if ((_this->theta > 0)) {
HXDLIN(  50)					if ((_this->halfA < 0)) {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  50)					if ((_this->halfA > 0)) {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  50)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  50)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  50)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  50)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  50)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  50)				_this->exPrev = _this->ex;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  50)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  50)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  50)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  50)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  50)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  50)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  50)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  50)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  50)		Float theta0;
HXDLIN(  50)		Float theta1;
HXDLIN(  50)		if (clockWise) {
HXDLIN(  50)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  50)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  50)		Float dif;
HXDLIN(  50)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  50)				Float f;
HXDLIN(  50)				bool f1;
HXDLIN(  50)				if ((theta0 >= 0)) {
HXDLIN(  50)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f1 = false;
            				}
HXDLIN(  50)				if (f1) {
HXDLIN(  50)					f = theta0;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f = a;
            					}
            					else {
HXDLIN(  50)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this1 = f;
HXDLIN(  50)				Float za = this1;
HXDLIN(  50)				Float f2;
HXDLIN(  50)				bool f3;
HXDLIN(  50)				if ((theta1 >= 0)) {
HXDLIN(  50)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f3 = false;
            				}
HXDLIN(  50)				if (f3) {
HXDLIN(  50)					f2 = theta1;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f2 = a;
            					}
            					else {
HXDLIN(  50)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this2 = f2;
HXDLIN(  50)				Float zb = this2;
HXDLIN(  50)				Float fa = za;
HXDLIN(  50)				Float fb = zb;
HXDLIN(  50)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)				bool clockwise = (fa < fb);
HXDLIN(  50)				Float dif1;
HXDLIN(  50)				if (clockwise) {
HXDLIN(  50)					dif1 = theta;
            				}
            				else {
HXDLIN(  50)					dif1 = -(theta);
            				}
HXDLIN(  50)				if ((dif1 > 0)) {
HXDLIN(  50)					dif = dif1;
            				}
            				else {
HXDLIN(  50)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  50)				Float f;
HXDLIN(  50)				bool f1;
HXDLIN(  50)				if ((theta0 >= 0)) {
HXDLIN(  50)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f1 = false;
            				}
HXDLIN(  50)				if (f1) {
HXDLIN(  50)					f = theta0;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f = a;
            					}
            					else {
HXDLIN(  50)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this1 = f;
HXDLIN(  50)				Float za = this1;
HXDLIN(  50)				Float f2;
HXDLIN(  50)				bool f3;
HXDLIN(  50)				if ((theta1 >= 0)) {
HXDLIN(  50)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f3 = false;
            				}
HXDLIN(  50)				if (f3) {
HXDLIN(  50)					f2 = theta1;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f2 = a;
            					}
            					else {
HXDLIN(  50)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this2 = f2;
HXDLIN(  50)				Float zb = this2;
HXDLIN(  50)				Float fa = za;
HXDLIN(  50)				Float fb = zb;
HXDLIN(  50)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)				bool clockwise = (fa < fb);
HXDLIN(  50)				Float dif1;
HXDLIN(  50)				if (clockwise) {
HXDLIN(  50)					dif1 = theta;
            				}
            				else {
HXDLIN(  50)					dif1 = -(theta);
            				}
HXDLIN(  50)				if ((dif1 < 0)) {
HXDLIN(  50)					dif = dif1;
            				}
            				else {
HXDLIN(  50)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  50)				Float f;
HXDLIN(  50)				bool f1;
HXDLIN(  50)				if ((theta0 >= 0)) {
HXDLIN(  50)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f1 = false;
            				}
HXDLIN(  50)				if (f1) {
HXDLIN(  50)					f = theta0;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f = a;
            					}
            					else {
HXDLIN(  50)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this1 = f;
HXDLIN(  50)				Float za = this1;
HXDLIN(  50)				Float f2;
HXDLIN(  50)				bool f3;
HXDLIN(  50)				if ((theta1 >= 0)) {
HXDLIN(  50)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f3 = false;
            				}
HXDLIN(  50)				if (f3) {
HXDLIN(  50)					f2 = theta1;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f2 = a;
            					}
            					else {
HXDLIN(  50)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this2 = f2;
HXDLIN(  50)				Float zb = this2;
HXDLIN(  50)				Float fa = za;
HXDLIN(  50)				Float fb = zb;
HXDLIN(  50)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)				bool clockwise = (fa < fb);
HXDLIN(  50)				Float dif1;
HXDLIN(  50)				if (clockwise) {
HXDLIN(  50)					dif1 = theta;
            				}
            				else {
HXDLIN(  50)					dif1 = -(theta);
            				}
HXDLIN(  50)				if (smallest) {
HXDLIN(  50)					dif = dif1;
            				}
            				else {
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  50)				Float f;
HXDLIN(  50)				bool f1;
HXDLIN(  50)				if ((theta0 >= 0)) {
HXDLIN(  50)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f1 = false;
            				}
HXDLIN(  50)				if (f1) {
HXDLIN(  50)					f = theta0;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f = a;
            					}
            					else {
HXDLIN(  50)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this1 = f;
HXDLIN(  50)				Float za = this1;
HXDLIN(  50)				Float f2;
HXDLIN(  50)				bool f3;
HXDLIN(  50)				if ((theta1 >= 0)) {
HXDLIN(  50)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f3 = false;
            				}
HXDLIN(  50)				if (f3) {
HXDLIN(  50)					f2 = theta1;
            				}
            				else {
HXDLIN(  50)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)					if ((a >= 0)) {
HXDLIN(  50)						f2 = a;
            					}
            					else {
HXDLIN(  50)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  50)				Float this2 = f2;
HXDLIN(  50)				Float zb = this2;
HXDLIN(  50)				Float fa = za;
HXDLIN(  50)				Float fb = zb;
HXDLIN(  50)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)				bool clockwise = (fa < fb);
HXDLIN(  50)				Float dif1;
HXDLIN(  50)				if (clockwise) {
HXDLIN(  50)					dif1 = theta;
            				}
            				else {
HXDLIN(  50)					dif1 = -(theta);
            				}
HXDLIN(  50)				if (largest) {
HXDLIN(  50)					dif = dif1;
            				}
            				else {
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  50)		bool _hx_tmp;
HXDLIN(  50)		if (!(overlap)) {
HXDLIN(  50)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  50)			_hx_tmp = false;
            		}
HXDLIN(  50)		if (_hx_tmp) {
HXDLIN(  50)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  50)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  50)			Float f;
HXDLIN(  50)			bool f1;
HXDLIN(  50)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  50)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  50)				f1 = false;
            			}
HXDLIN(  50)			if (f1) {
HXDLIN(  50)				f = theta0;
            			}
            			else {
HXDLIN(  50)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)				if ((a >= 0)) {
HXDLIN(  50)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  50)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  50)			Float this1 = f;
HXDLIN(  50)			Float start = this1;
HXDLIN(  50)			Float start2 = start;
HXDLIN(  50)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  50)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  50)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  50)		bool _hx_tmp1;
HXDLIN(  50)		if ((_this->count == 0)) {
HXDLIN(  50)			if ((_this->endLine != 1)) {
HXDLIN(  50)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  50)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  50)			_hx_tmp1 = false;
            		}
HXDLIN(  50)		if (_hx_tmp1) {
HXDLIN(  50)			Float ax = _this->ax;
HXDLIN(  50)			Float ay = _this->ay;
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  50)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  50)			{
HXDLIN(  50)				int color = -1;
HXDLIN(  50)				 ::Dynamic sides = 36;
HXDLIN(  50)				if (::hx::IsNull( sides )) {
HXDLIN(  50)					sides = 36;
            				}
HXDLIN(  50)				Float pi = ::Math_obj::PI;
HXDLIN(  50)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)				Float dif;
HXDLIN(  50)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if ((dif1 > 0)) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if ((dif1 < 0)) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if (smallest) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if (largest) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  50)				bool positive = (dif >= 0);
HXDLIN(  50)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)				Float angle = beta;
HXDLIN(  50)				Float cx;
HXDLIN(  50)				Float cy;
HXDLIN(  50)				Float bx = ( (Float)(0) );
HXDLIN(  50)				Float by = ( (Float)(0) );
HXDLIN(  50)				int p2 = temp->length;
HXDLIN(  50)				{
HXDLIN(  50)					int _g = 0;
HXDLIN(  50)					int _g1 = (totalSteps + 1);
HXDLIN(  50)					while((_g < _g1)){
HXDLIN(  50)						_g = (_g + 1);
HXDLIN(  50)						int i = (_g - 1);
HXDLIN(  50)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)						p2 = (p2 + 1);
HXDLIN(  50)						temp[(p2 - 1)] = cx;
HXDLIN(  50)						p2 = (p2 + 1);
HXDLIN(  50)						temp[(p2 - 1)] = cy;
HXDLIN(  50)						if ((i != 0)) {
HXDLIN(  50)							::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            						}
HXDLIN(  50)						angle = (angle + step1);
HXDLIN(  50)						bx = cx;
HXDLIN(  50)						by = cy;
            					}
            				}
            			}
HXDLIN(  50)			int pA = _this->pointsAnti->length;
HXDLIN(  50)			int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  50)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  50)			{
HXDLIN(  50)				int _g2 = 0;
HXDLIN(  50)				int _g3 = p4;
HXDLIN(  50)				while((_g2 < _g3)){
HXDLIN(  50)					_g2 = (_g2 + 1);
HXDLIN(  50)					int i = (_g2 - 1);
HXDLIN(  50)					pA = (pA + 1);
HXDLIN(  50)					_this->pointsAnti[(pA - 1)] = temp->__get(((len - (2 * i)) + 1));
HXDLIN(  50)					pA = (pA + 1);
HXDLIN(  50)					_this->pointsAnti[(pA - 1)] = temp->__get((len - (2 * i)));
            				}
            			}
HXDLIN(  50)			int pC = _this->pointsClock->length;
HXDLIN(  50)			{
HXDLIN(  50)				int _g4 = 0;
HXDLIN(  50)				int _g5 = p4;
HXDLIN(  50)				while((_g4 < _g5)){
HXDLIN(  50)					_g4 = (_g4 + 1);
HXDLIN(  50)					int i = (_g4 - 1);
HXDLIN(  50)					pC = (pC + 1);
HXDLIN(  50)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len) + 1));
HXDLIN(  50)					pC = (pC + 1);
HXDLIN(  50)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len));
            				}
            			}
            		}
HXDLIN(  50)		if (overlap) {
HXDLIN(  50)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  50)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            		}
            		else {
HXDLIN(  50)			if ((_this->count != 0)) {
HXDLIN(  50)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  50)			{
HXDLIN(  50)				_this->quadIndex = ::cornerContour::IPen_obj::get_pos(_this->pen);
HXDLIN(  50)				if ((_this->count == 0)) {
HXDLIN(  50)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  50)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  50)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  50)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  50)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  50)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  50)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  50)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  50)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  50)					::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            				}
            				else {
HXDLIN(  50)					bool _hx_tmp;
HXDLIN(  50)					if (clockWise) {
HXDLIN(  50)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  50)						_hx_tmp = false;
            					}
HXDLIN(  50)					if (_hx_tmp) {
HXDLIN(  50)						_this->penultimateAX = _this->jx;
HXDLIN(  50)						_this->penultimateAY = _this->jy;
HXDLIN(  50)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  50)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  50)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  50)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  50)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  50)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            					}
HXDLIN(  50)					bool _hx_tmp1;
HXDLIN(  50)					if (clockWise) {
HXDLIN(  50)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  50)						_hx_tmp1 = false;
            					}
HXDLIN(  50)					if (_hx_tmp1) {
HXDLIN(  50)						_this->penultimateAX = _this->jx;
HXDLIN(  50)						_this->penultimateAY = _this->jy;
HXDLIN(  50)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  50)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  50)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  50)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  50)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  50)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            					}
HXDLIN(  50)					bool _hx_tmp2;
HXDLIN(  50)					if (!(clockWise)) {
HXDLIN(  50)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  50)						_hx_tmp2 = false;
            					}
HXDLIN(  50)					if (_hx_tmp2) {
HXDLIN(  50)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  50)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  50)						_this->lastClockX = _this->jx;
HXDLIN(  50)						_this->lastClockY = _this->jy;
HXDLIN(  50)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  50)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  50)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  50)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),_this->jx,_this->jy,-1);
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            					}
HXDLIN(  50)					bool _hx_tmp3;
HXDLIN(  50)					if (!(clockWise)) {
HXDLIN(  50)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  50)						_hx_tmp3 = false;
            					}
HXDLIN(  50)					if (_hx_tmp3) {
HXDLIN(  50)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  50)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  50)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  50)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  50)						_this->penultimateCX = _this->jx;
HXDLIN(  50)						_this->penultimateCY = _this->jy;
HXDLIN(  50)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  50)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->jx,_this->jy,( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),_this->jx,_this->jy,( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
            					}
            				}
            			}
            		}
HXDLIN(  50)		if (clockWise) {
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  50)			int color = -1;
HXDLIN(  50)			Float pi = ::Math_obj::PI;
HXDLIN(  50)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  50)			bool positive = (dif >= 0);
HXDLIN(  50)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)			Float angle = theta0;
HXDLIN(  50)			Float cx;
HXDLIN(  50)			Float cy;
HXDLIN(  50)			Float bx = ( (Float)(0) );
HXDLIN(  50)			Float by = ( (Float)(0) );
HXDLIN(  50)			int p2 = edgePoly->length;
HXDLIN(  50)			{
HXDLIN(  50)				int _g = 0;
HXDLIN(  50)				int _g1 = (totalSteps + 1);
HXDLIN(  50)				while((_g < _g1)){
HXDLIN(  50)					_g = (_g + 1);
HXDLIN(  50)					int i = (_g - 1);
HXDLIN(  50)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)					p2 = (p2 + 1);
HXDLIN(  50)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  50)					p2 = (p2 + 1);
HXDLIN(  50)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  50)					if ((i != 0)) {
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax_,ay_,bx,by,cx,cy,color);
            					}
HXDLIN(  50)					angle = (angle + step1);
HXDLIN(  50)					bx = cx;
HXDLIN(  50)					by = cy;
            				}
            			}
            		}
            		else {
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  50)			int color = -1;
HXDLIN(  50)			Float pi = ::Math_obj::PI;
HXDLIN(  50)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  50)			bool positive = (dif >= 0);
HXDLIN(  50)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)			Float angle = theta0;
HXDLIN(  50)			Float cx;
HXDLIN(  50)			Float cy;
HXDLIN(  50)			Float bx = ( (Float)(0) );
HXDLIN(  50)			Float by = ( (Float)(0) );
HXDLIN(  50)			int p2 = edgePoly->length;
HXDLIN(  50)			{
HXDLIN(  50)				int _g = 0;
HXDLIN(  50)				int _g1 = (totalSteps + 1);
HXDLIN(  50)				while((_g < _g1)){
HXDLIN(  50)					_g = (_g + 1);
HXDLIN(  50)					int i = (_g - 1);
HXDLIN(  50)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)					p2 = (p2 + 1);
HXDLIN(  50)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  50)					p2 = (p2 + 1);
HXDLIN(  50)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  50)					if ((i != 0)) {
HXDLIN(  50)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax_,ay_,bx,by,cx,cy,color);
            					}
HXDLIN(  50)					angle = (angle + step1);
HXDLIN(  50)					bx = cx;
HXDLIN(  50)					by = cy;
            				}
            			}
            		}
HXDLIN(  50)		{
HXDLIN(  50)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  50)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  50)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  50)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  50)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  50)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  50)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  50)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  50)		bool _hx_tmp2;
HXDLIN(  50)		if (!(overlap)) {
HXDLIN(  50)			_hx_tmp2 = (_this->count != 0);
            		}
            		else {
HXDLIN(  50)			_hx_tmp2 = false;
            		}
HXDLIN(  50)		if (_hx_tmp2) {
HXDLIN(  50)			if (clockWise) {
HXDLIN(  50)				::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->ax,_this->ay,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),_this->jx,_this->jy,-1);
HXDLIN(  50)				::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->ax,_this->ay,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),_this->jx,_this->jy,-1);
            			}
            			else {
HXDLIN(  50)				::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->ax,_this->ay,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),_this->jx,_this->jy,-1);
HXDLIN(  50)				::cornerContour::IPen_obj::triangle2DFill(_this->pen,_this->ax,_this->ay,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),_this->jx,_this->jy,-1);
            			}
            		}
HXDLIN(  50)		_this->jxOld = _this->jx;
HXDLIN(  50)		_this->jyOld = _this->jy;
HXDLIN(  50)		_this->lastClock = clockWise;
HXDLIN(  50)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,fineLine,(void))

void Sketcher_obj::fineOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_53_fineOverlapLine)
HXDLIN(  53)		 ::cornerContour::Contour _this = this->contour;
HXDLIN(  53)		Float ax_ = this->x;
HXDLIN(  53)		Float ay_ = this->y;
HXDLIN(  53)		Float width_ = this->width;
HXDLIN(  53)		 ::Dynamic oldAngle;
HXDLIN(  53)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  53)			oldAngle = null();
            		}
HXDLIN(  53)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  53)		_this->ax = x_;
HXDLIN(  53)		_this->ay = y_;
HXDLIN(  53)		_this->bx = ax_;
HXDLIN(  53)		_this->by = ay_;
HXDLIN(  53)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  53)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  53)		{
HXDLIN(  53)			{
HXDLIN(  53)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  53)				if ((_this->theta > 0)) {
HXDLIN(  53)					if ((_this->halfA < 0)) {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  53)					if ((_this->halfA > 0)) {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  53)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  53)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  53)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  53)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  53)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  53)				_this->exPrev = _this->ex;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  53)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  53)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  53)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  53)		_this->ax = ax_;
HXDLIN(  53)		_this->ay = ay_;
HXDLIN(  53)		_this->bx = x_;
HXDLIN(  53)		_this->by = y_;
HXDLIN(  53)		{
HXDLIN(  53)			{
HXDLIN(  53)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  53)				if ((_this->theta > 0)) {
HXDLIN(  53)					if ((_this->halfA < 0)) {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  53)					if ((_this->halfA > 0)) {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  53)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  53)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  53)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  53)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  53)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  53)				_this->exPrev = _this->ex;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  53)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  53)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  53)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  53)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  53)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  53)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  53)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  53)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  53)		Float theta0;
HXDLIN(  53)		Float theta1;
HXDLIN(  53)		if (clockWise) {
HXDLIN(  53)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  53)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  53)		Float dif;
HXDLIN(  53)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if ((dif1 > 0)) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if ((dif1 < 0)) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if (smallest) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if (largest) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  53)		bool _hx_tmp;
HXDLIN(  53)		if ((_this->count == 0)) {
HXDLIN(  53)			if ((_this->endLine != 1)) {
HXDLIN(  53)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  53)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  53)			_hx_tmp = false;
            		}
HXDLIN(  53)		if (_hx_tmp) {
HXDLIN(  53)			Float ax = _this->ax;
HXDLIN(  53)			Float ay = _this->ay;
HXDLIN(  53)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  53)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  53)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  53)			{
HXDLIN(  53)				int color = -1;
HXDLIN(  53)				 ::Dynamic sides = 36;
HXDLIN(  53)				if (::hx::IsNull( sides )) {
HXDLIN(  53)					sides = 36;
            				}
HXDLIN(  53)				Float pi = ::Math_obj::PI;
HXDLIN(  53)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  53)				Float dif;
HXDLIN(  53)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  53)						Float f;
HXDLIN(  53)						bool f1;
HXDLIN(  53)						if ((beta >= 0)) {
HXDLIN(  53)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f1 = false;
            						}
HXDLIN(  53)						if (f1) {
HXDLIN(  53)							f = beta;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f = a;
            							}
            							else {
HXDLIN(  53)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this1 = f;
HXDLIN(  53)						Float za = this1;
HXDLIN(  53)						Float f2;
HXDLIN(  53)						bool f3;
HXDLIN(  53)						if ((gamma >= 0)) {
HXDLIN(  53)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f3 = false;
            						}
HXDLIN(  53)						if (f3) {
HXDLIN(  53)							f2 = gamma;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f2 = a;
            							}
            							else {
HXDLIN(  53)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this2 = f2;
HXDLIN(  53)						Float zb = this2;
HXDLIN(  53)						Float fa = za;
HXDLIN(  53)						Float fb = zb;
HXDLIN(  53)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)						bool clockwise = (fa < fb);
HXDLIN(  53)						Float dif1;
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif1 = theta;
            						}
            						else {
HXDLIN(  53)							dif1 = -(theta);
            						}
HXDLIN(  53)						if ((dif1 > 0)) {
HXDLIN(  53)							dif = dif1;
            						}
            						else {
HXDLIN(  53)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  53)						Float f;
HXDLIN(  53)						bool f1;
HXDLIN(  53)						if ((beta >= 0)) {
HXDLIN(  53)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f1 = false;
            						}
HXDLIN(  53)						if (f1) {
HXDLIN(  53)							f = beta;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f = a;
            							}
            							else {
HXDLIN(  53)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this1 = f;
HXDLIN(  53)						Float za = this1;
HXDLIN(  53)						Float f2;
HXDLIN(  53)						bool f3;
HXDLIN(  53)						if ((gamma >= 0)) {
HXDLIN(  53)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f3 = false;
            						}
HXDLIN(  53)						if (f3) {
HXDLIN(  53)							f2 = gamma;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f2 = a;
            							}
            							else {
HXDLIN(  53)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this2 = f2;
HXDLIN(  53)						Float zb = this2;
HXDLIN(  53)						Float fa = za;
HXDLIN(  53)						Float fb = zb;
HXDLIN(  53)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)						bool clockwise = (fa < fb);
HXDLIN(  53)						Float dif1;
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif1 = theta;
            						}
            						else {
HXDLIN(  53)							dif1 = -(theta);
            						}
HXDLIN(  53)						if ((dif1 < 0)) {
HXDLIN(  53)							dif = dif1;
            						}
            						else {
HXDLIN(  53)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  53)						Float f;
HXDLIN(  53)						bool f1;
HXDLIN(  53)						if ((beta >= 0)) {
HXDLIN(  53)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f1 = false;
            						}
HXDLIN(  53)						if (f1) {
HXDLIN(  53)							f = beta;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f = a;
            							}
            							else {
HXDLIN(  53)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this1 = f;
HXDLIN(  53)						Float za = this1;
HXDLIN(  53)						Float f2;
HXDLIN(  53)						bool f3;
HXDLIN(  53)						if ((gamma >= 0)) {
HXDLIN(  53)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f3 = false;
            						}
HXDLIN(  53)						if (f3) {
HXDLIN(  53)							f2 = gamma;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f2 = a;
            							}
            							else {
HXDLIN(  53)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this2 = f2;
HXDLIN(  53)						Float zb = this2;
HXDLIN(  53)						Float fa = za;
HXDLIN(  53)						Float fb = zb;
HXDLIN(  53)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  53)						bool clockwise = (fa < fb);
HXDLIN(  53)						Float dif1;
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif1 = theta;
            						}
            						else {
HXDLIN(  53)							dif1 = -(theta);
            						}
HXDLIN(  53)						if (smallest) {
HXDLIN(  53)							dif = dif1;
            						}
            						else {
HXDLIN(  53)							if (clockwise) {
HXDLIN(  53)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  53)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  53)						Float f;
HXDLIN(  53)						bool f1;
HXDLIN(  53)						if ((beta >= 0)) {
HXDLIN(  53)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f1 = false;
            						}
HXDLIN(  53)						if (f1) {
HXDLIN(  53)							f = beta;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f = a;
            							}
            							else {
HXDLIN(  53)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this1 = f;
HXDLIN(  53)						Float za = this1;
HXDLIN(  53)						Float f2;
HXDLIN(  53)						bool f3;
HXDLIN(  53)						if ((gamma >= 0)) {
HXDLIN(  53)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  53)							f3 = false;
            						}
HXDLIN(  53)						if (f3) {
HXDLIN(  53)							f2 = gamma;
            						}
            						else {
HXDLIN(  53)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)							if ((a >= 0)) {
HXDLIN(  53)								f2 = a;
            							}
            							else {
HXDLIN(  53)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  53)						Float this2 = f2;
HXDLIN(  53)						Float zb = this2;
HXDLIN(  53)						Float fa = za;
HXDLIN(  53)						Float fb = zb;
HXDLIN(  53)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  53)						bool clockwise = (fa < fb);
HXDLIN(  53)						Float dif1;
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif1 = theta;
            						}
            						else {
HXDLIN(  53)							dif1 = -(theta);
            						}
HXDLIN(  53)						if (largest) {
HXDLIN(  53)							dif = dif1;
            						}
            						else {
HXDLIN(  53)							if (clockwise) {
HXDLIN(  53)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  53)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  53)				bool positive = (dif >= 0);
HXDLIN(  53)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  53)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  53)				Float angle = beta;
HXDLIN(  53)				Float cx;
HXDLIN(  53)				Float cy;
HXDLIN(  53)				Float bx = ( (Float)(0) );
HXDLIN(  53)				Float by = ( (Float)(0) );
HXDLIN(  53)				int p2 = temp->length;
HXDLIN(  53)				{
HXDLIN(  53)					int _g = 0;
HXDLIN(  53)					int _g1 = (totalSteps + 1);
HXDLIN(  53)					while((_g < _g1)){
HXDLIN(  53)						_g = (_g + 1);
HXDLIN(  53)						int i = (_g - 1);
HXDLIN(  53)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  53)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  53)						p2 = (p2 + 1);
HXDLIN(  53)						temp[(p2 - 1)] = cx;
HXDLIN(  53)						p2 = (p2 + 1);
HXDLIN(  53)						temp[(p2 - 1)] = cy;
HXDLIN(  53)						if ((i != 0)) {
HXDLIN(  53)							::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            						}
HXDLIN(  53)						angle = (angle + step1);
HXDLIN(  53)						bx = cx;
HXDLIN(  53)						by = cy;
            					}
            				}
            			}
HXDLIN(  53)			int pA = _this->pointsAnti->length;
HXDLIN(  53)			int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  53)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  53)			{
HXDLIN(  53)				int _g2 = 0;
HXDLIN(  53)				int _g3 = p4;
HXDLIN(  53)				while((_g2 < _g3)){
HXDLIN(  53)					_g2 = (_g2 + 1);
HXDLIN(  53)					int i = (_g2 - 1);
HXDLIN(  53)					pA = (pA + 1);
HXDLIN(  53)					_this->pointsAnti[(pA - 1)] = temp->__get(((len - (2 * i)) + 1));
HXDLIN(  53)					pA = (pA + 1);
HXDLIN(  53)					_this->pointsAnti[(pA - 1)] = temp->__get((len - (2 * i)));
            				}
            			}
HXDLIN(  53)			int pC = _this->pointsClock->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g4 = 0;
HXDLIN(  53)				int _g5 = p4;
HXDLIN(  53)				while((_g4 < _g5)){
HXDLIN(  53)					_g4 = (_g4 + 1);
HXDLIN(  53)					int i = (_g4 - 1);
HXDLIN(  53)					pC = (pC + 1);
HXDLIN(  53)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len) + 1));
HXDLIN(  53)					pC = (pC + 1);
HXDLIN(  53)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len));
            				}
            			}
            		}
HXDLIN(  53)		{
HXDLIN(  53)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->ex) ),( (Float)(_this->ey) ),-1);
HXDLIN(  53)			::cornerContour::IPen_obj::triangle2DFill(_this->pen,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),( (Float)(_this->dx) ),( (Float)(_this->dy) ),( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),-1);
            		}
HXDLIN(  53)		if (clockWise) {
HXDLIN(  53)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  53)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  53)			int color = -1;
HXDLIN(  53)			Float pi = ::Math_obj::PI;
HXDLIN(  53)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  53)			bool positive = (dif >= 0);
HXDLIN(  53)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  53)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  53)			Float angle = theta0;
HXDLIN(  53)			Float cx;
HXDLIN(  53)			Float cy;
HXDLIN(  53)			Float bx = ( (Float)(0) );
HXDLIN(  53)			Float by = ( (Float)(0) );
HXDLIN(  53)			int p2 = edgePoly->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g = 0;
HXDLIN(  53)				int _g1 = (totalSteps + 1);
HXDLIN(  53)				while((_g < _g1)){
HXDLIN(  53)					_g = (_g + 1);
HXDLIN(  53)					int i = (_g - 1);
HXDLIN(  53)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  53)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  53)					if ((i != 0)) {
HXDLIN(  53)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax_,ay_,bx,by,cx,cy,color);
            					}
HXDLIN(  53)					angle = (angle + step1);
HXDLIN(  53)					bx = cx;
HXDLIN(  53)					by = cy;
            				}
            			}
            		}
            		else {
HXDLIN(  53)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  53)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  53)			int color = -1;
HXDLIN(  53)			Float pi = ::Math_obj::PI;
HXDLIN(  53)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  53)			bool positive = (dif >= 0);
HXDLIN(  53)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  53)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  53)			Float angle = theta0;
HXDLIN(  53)			Float cx;
HXDLIN(  53)			Float cy;
HXDLIN(  53)			Float bx = ( (Float)(0) );
HXDLIN(  53)			Float by = ( (Float)(0) );
HXDLIN(  53)			int p2 = edgePoly->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g = 0;
HXDLIN(  53)				int _g1 = (totalSteps + 1);
HXDLIN(  53)				while((_g < _g1)){
HXDLIN(  53)					_g = (_g + 1);
HXDLIN(  53)					int i = (_g - 1);
HXDLIN(  53)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  53)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  53)					if ((i != 0)) {
HXDLIN(  53)						::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax_,ay_,bx,by,cx,cy,color);
            					}
HXDLIN(  53)					angle = (angle + step1);
HXDLIN(  53)					bx = cx;
HXDLIN(  53)					by = cy;
            				}
            			}
            		}
HXDLIN(  53)		{
HXDLIN(  53)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  53)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  53)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  53)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  53)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  53)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  53)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  53)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  53)		_this->jxOld = _this->jx;
HXDLIN(  53)		_this->jyOld = _this->jy;
HXDLIN(  53)		_this->lastClock = clockWise;
HXDLIN(  53)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,fineOverlapLine,(void))

void Sketcher_obj::reset(){
            	HX_GC_STACKFRAME(&_hx_pos_0fc6eed552804d6b_79_reset)
HXLINE(  80)		this->contour =  ::cornerContour::Contour_obj::__alloc( HX_CTX ,this->pen,this->endLine);
HXLINE(  81)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  82)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  83)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  84)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE(  85)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketcher_obj,reset,(void))

::Array< ::Dynamic> Sketcher_obj::pointsNoEndOverlap(){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_87_pointsNoEndOverlap)
HXLINE(  88)		::Array< Float > p;
HXLINE(  89)		int l;
HXLINE(  90)		int j = 0;
HXLINE(  91)		::Array< ::Dynamic> pointsClean = ::Array_obj< ::Dynamic>::__new();
HXLINE(  92)		{
HXLINE(  92)			int _g = 0;
HXDLIN(  92)			int _g1 = this->points->length;
HXDLIN(  92)			while((_g < _g1)){
HXLINE(  92)				_g = (_g + 1);
HXDLIN(  92)				int i = (_g - 1);
HXLINE(  93)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE(  94)				if ((p->length > 2)) {
HXLINE(  94)					j = (j + 1);
HXDLIN(  94)					pointsClean[(j - 1)] = p;
            				}
            			}
            		}
HXLINE(  96)		this->points = pointsClean;
HXLINE(  97)		{
HXLINE(  97)			int _g2 = 0;
HXDLIN(  97)			int _g3 = this->points->length;
HXDLIN(  97)			while((_g2 < _g3)){
HXLINE(  97)				_g2 = (_g2 + 1);
HXDLIN(  97)				int i = (_g2 - 1);
HXLINE(  98)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE(  99)				l = p->length;
HXLINE( 100)				bool repeat;
HXDLIN( 100)				if ((p->__get(0) == p->__get((l - 2)))) {
HXLINE( 100)					repeat = (p->__get(1) == p->__get((l - 1)));
            				}
            				else {
HXLINE( 100)					repeat = false;
            				}
HXLINE( 101)				if (repeat) {
HXLINE( 102)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 103)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 104)					l = (l - 2);
            				}
            			}
            		}
HXLINE( 107)		return this->points;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketcher_obj,pointsNoEndOverlap,return )

::Array< ::Dynamic> Sketcher_obj::pointsRewound(){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_109_pointsRewound)
HXLINE( 110)		::Array< Float > p;
HXLINE( 111)		int l;
HXLINE( 112)		int j = 0;
HXLINE( 113)		::Array< ::Dynamic> pointsClean = ::Array_obj< ::Dynamic>::__new();
HXLINE( 114)		{
HXLINE( 114)			int _g = 0;
HXDLIN( 114)			int _g1 = this->points->length;
HXDLIN( 114)			while((_g < _g1)){
HXLINE( 114)				_g = (_g + 1);
HXDLIN( 114)				int i = (_g - 1);
HXLINE( 115)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 116)				if ((p->length > 2)) {
HXLINE( 116)					j = (j + 1);
HXDLIN( 116)					pointsClean[(j - 1)] = p;
            				}
            			}
            		}
HXLINE( 118)		this->points = pointsClean;
HXLINE( 120)		{
HXLINE( 120)			int _g2 = 0;
HXDLIN( 120)			int _g3 = this->points->length;
HXDLIN( 120)			while((_g2 < _g3)){
HXLINE( 120)				_g2 = (_g2 + 1);
HXDLIN( 120)				int i = (_g2 - 1);
HXLINE( 121)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 122)				l = p->length;
HXLINE( 124)				bool repeat;
HXDLIN( 124)				if ((p->__get(0) == p->__get((l - 2)))) {
HXLINE( 124)					repeat = (p->__get(1) == p->__get((l - 1)));
            				}
            				else {
HXLINE( 124)					repeat = false;
            				}
HXLINE( 125)				if (repeat) {
HXLINE( 126)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 127)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 128)					l = (l - 2);
            				}
HXLINE( 131)				Float cc = ((Float)0.);
HXLINE( 132)				int k = 0;
HXLINE( 133)				Float x1;
HXLINE( 134)				Float y1;
HXLINE( 135)				Float x2;
HXLINE( 136)				Float y2;
HXLINE( 137)				int last = (l - 2);
HXLINE( 138)				while((k < l)){
HXLINE( 139)					x1 = p->__get(k);
HXLINE( 140)					y1 = p->__get((k + 1));
HXLINE( 141)					if ((k == last)) {
HXLINE( 142)						x2 = p->__get(0);
HXLINE( 143)						y2 = p->__get(1);
            					}
            					else {
HXLINE( 145)						x2 = p->__get((k + 2));
HXLINE( 146)						y2 = p->__get((k + 3));
            					}
HXLINE( 148)					cc = (cc + ((x2 - x1) * (y2 + y1)));
HXLINE( 149)					k = (k + 2);
            				}
HXLINE( 151)				this->points[i] = p;
            			}
            		}
HXLINE( 153)		return this->points;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketcher_obj,pointsRewound,return )

 ::Dynamic Sketcher_obj::initDim(){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_157_initDim)
HXDLIN( 157)		return  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketcher_obj,initDim,return )

void Sketcher_obj::updateDim(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_159_updateDim)
HXLINE( 160)		 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXLINE( 161)		if (::hx::IsLess( x,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 161)			d->__SetField(HX_("minX",86,4e,5c,48),x,::hx::paccDynamic);
            		}
HXLINE( 162)		if (::hx::IsGreater( x,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 162)			d->__SetField(HX_("maxX",34,45,56,48),x,::hx::paccDynamic);
            		}
HXLINE( 163)		if (::hx::IsLess( y,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 163)			d->__SetField(HX_("minY",87,4e,5c,48),y,::hx::paccDynamic);
            		}
HXLINE( 164)		if (::hx::IsGreater( y,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 164)			d->__SetField(HX_("maxY",35,45,56,48),y,::hx::paccDynamic);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,updateDim,(void))

void Sketcher_obj::moveTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_167_moveTo)
HXLINE( 168)		bool _hx_tmp;
HXDLIN( 168)		if ((this->endLine != 2)) {
HXLINE( 168)			_hx_tmp = (this->endLine == 3);
            		}
            		else {
HXLINE( 168)			_hx_tmp = true;
            		}
HXDLIN( 168)		if (_hx_tmp) {
HXLINE( 168)			 ::cornerContour::Contour _this = this->contour;
HXDLIN( 168)			Float width_ = this->width;
HXDLIN( 168)			_this->endEdges();
HXDLIN( 168)			if ((_this->count != 0)) {
HXLINE( 168)				Float ax = _this->bx;
HXDLIN( 168)				Float ay = _this->by;
HXDLIN( 168)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 168)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 168)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 168)				::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 168)				{
HXLINE( 168)					int color = 0;
HXDLIN( 168)					 ::Dynamic sides = 36;
HXDLIN( 168)					if (::hx::IsNull( sides )) {
HXLINE( 168)						sides = 36;
            					}
HXDLIN( 168)					Float pi = ::Math_obj::PI;
HXDLIN( 168)					Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 168)					Float dif;
HXDLIN( 168)					switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            						case (int)0: {
HXLINE( 168)							Float f;
HXDLIN( 168)							bool f1;
HXDLIN( 168)							if ((beta >= 0)) {
HXLINE( 168)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f1 = false;
            							}
HXDLIN( 168)							if (f1) {
HXLINE( 168)								f = beta;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f = a;
            								}
            								else {
HXLINE( 168)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this1 = f;
HXDLIN( 168)							Float za = this1;
HXDLIN( 168)							Float f2;
HXDLIN( 168)							bool f3;
HXDLIN( 168)							if ((gamma >= 0)) {
HXLINE( 168)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f3 = false;
            							}
HXDLIN( 168)							if (f3) {
HXLINE( 168)								f2 = gamma;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f2 = a;
            								}
            								else {
HXLINE( 168)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this2 = f2;
HXDLIN( 168)							Float zb = this2;
HXDLIN( 168)							Float fa = za;
HXDLIN( 168)							Float fb = zb;
HXDLIN( 168)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 168)							bool clockwise = (fa < fb);
HXDLIN( 168)							Float dif1;
HXDLIN( 168)							if (clockwise) {
HXLINE( 168)								dif1 = theta;
            							}
            							else {
HXLINE( 168)								dif1 = -(theta);
            							}
HXDLIN( 168)							if ((dif1 > 0)) {
HXLINE( 168)								dif = dif1;
            							}
            							else {
HXLINE( 168)								dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            							}
            						}
            						break;
            						case (int)1: {
HXLINE( 168)							Float f;
HXDLIN( 168)							bool f1;
HXDLIN( 168)							if ((beta >= 0)) {
HXLINE( 168)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f1 = false;
            							}
HXDLIN( 168)							if (f1) {
HXLINE( 168)								f = beta;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f = a;
            								}
            								else {
HXLINE( 168)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this1 = f;
HXDLIN( 168)							Float za = this1;
HXDLIN( 168)							Float f2;
HXDLIN( 168)							bool f3;
HXDLIN( 168)							if ((gamma >= 0)) {
HXLINE( 168)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f3 = false;
            							}
HXDLIN( 168)							if (f3) {
HXLINE( 168)								f2 = gamma;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f2 = a;
            								}
            								else {
HXLINE( 168)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this2 = f2;
HXDLIN( 168)							Float zb = this2;
HXDLIN( 168)							Float fa = za;
HXDLIN( 168)							Float fb = zb;
HXDLIN( 168)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 168)							bool clockwise = (fa < fb);
HXDLIN( 168)							Float dif1;
HXDLIN( 168)							if (clockwise) {
HXLINE( 168)								dif1 = theta;
            							}
            							else {
HXLINE( 168)								dif1 = -(theta);
            							}
HXDLIN( 168)							if ((dif1 < 0)) {
HXLINE( 168)								dif = dif1;
            							}
            							else {
HXLINE( 168)								dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            							}
            						}
            						break;
            						case (int)2: {
HXLINE( 168)							Float f;
HXDLIN( 168)							bool f1;
HXDLIN( 168)							if ((beta >= 0)) {
HXLINE( 168)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f1 = false;
            							}
HXDLIN( 168)							if (f1) {
HXLINE( 168)								f = beta;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f = a;
            								}
            								else {
HXLINE( 168)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this1 = f;
HXDLIN( 168)							Float za = this1;
HXDLIN( 168)							Float f2;
HXDLIN( 168)							bool f3;
HXDLIN( 168)							if ((gamma >= 0)) {
HXLINE( 168)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f3 = false;
            							}
HXDLIN( 168)							if (f3) {
HXLINE( 168)								f2 = gamma;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f2 = a;
            								}
            								else {
HXLINE( 168)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this2 = f2;
HXDLIN( 168)							Float zb = this2;
HXDLIN( 168)							Float fa = za;
HXDLIN( 168)							Float fb = zb;
HXDLIN( 168)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 168)							bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 168)							bool clockwise = (fa < fb);
HXDLIN( 168)							Float dif1;
HXDLIN( 168)							if (clockwise) {
HXLINE( 168)								dif1 = theta;
            							}
            							else {
HXLINE( 168)								dif1 = -(theta);
            							}
HXDLIN( 168)							if (smallest) {
HXLINE( 168)								dif = dif1;
            							}
            							else {
HXLINE( 168)								if (clockwise) {
HXLINE( 168)									dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXLINE( 168)									dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            						case (int)3: {
HXLINE( 168)							Float f;
HXDLIN( 168)							bool f1;
HXDLIN( 168)							if ((beta >= 0)) {
HXLINE( 168)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f1 = false;
            							}
HXDLIN( 168)							if (f1) {
HXLINE( 168)								f = beta;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f = a;
            								}
            								else {
HXLINE( 168)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this1 = f;
HXDLIN( 168)							Float za = this1;
HXDLIN( 168)							Float f2;
HXDLIN( 168)							bool f3;
HXDLIN( 168)							if ((gamma >= 0)) {
HXLINE( 168)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 168)								f3 = false;
            							}
HXDLIN( 168)							if (f3) {
HXLINE( 168)								f2 = gamma;
            							}
            							else {
HXLINE( 168)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 168)								if ((a >= 0)) {
HXLINE( 168)									f2 = a;
            								}
            								else {
HXLINE( 168)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 168)							Float this2 = f2;
HXDLIN( 168)							Float zb = this2;
HXDLIN( 168)							Float fa = za;
HXDLIN( 168)							Float fb = zb;
HXDLIN( 168)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 168)							bool largest = (theta > ::Math_obj::PI);
HXDLIN( 168)							bool clockwise = (fa < fb);
HXDLIN( 168)							Float dif1;
HXDLIN( 168)							if (clockwise) {
HXLINE( 168)								dif1 = theta;
            							}
            							else {
HXLINE( 168)								dif1 = -(theta);
            							}
HXDLIN( 168)							if (largest) {
HXLINE( 168)								dif = dif1;
            							}
            							else {
HXLINE( 168)								if (clockwise) {
HXLINE( 168)									dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXLINE( 168)									dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            					}
HXDLIN( 168)					bool positive = (dif >= 0);
HXDLIN( 168)					int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 168)					Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 168)					Float angle = beta;
HXDLIN( 168)					Float cx;
HXDLIN( 168)					Float cy;
HXDLIN( 168)					Float bx = ( (Float)(0) );
HXDLIN( 168)					Float by = ( (Float)(0) );
HXDLIN( 168)					int p2 = temp->length;
HXDLIN( 168)					{
HXLINE( 168)						int _g = 0;
HXDLIN( 168)						int _g1 = (totalSteps + 1);
HXDLIN( 168)						while((_g < _g1)){
HXLINE( 168)							_g = (_g + 1);
HXDLIN( 168)							int i = (_g - 1);
HXDLIN( 168)							cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 168)							cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 168)							p2 = (p2 + 1);
HXDLIN( 168)							temp[(p2 - 1)] = cx;
HXDLIN( 168)							p2 = (p2 + 1);
HXDLIN( 168)							temp[(p2 - 1)] = cy;
HXDLIN( 168)							if ((i != 0)) {
HXLINE( 168)								::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            							}
HXDLIN( 168)							angle = (angle + step1);
HXDLIN( 168)							bx = cx;
HXDLIN( 168)							by = cy;
            						}
            					}
            				}
HXDLIN( 168)				int pA = _this->pointsAnti->length;
HXDLIN( 168)				int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 168)				{
HXLINE( 168)					int _g2 = 0;
HXDLIN( 168)					int _g3 = (len + 2);
HXDLIN( 168)					while((_g2 < _g3)){
HXLINE( 168)						_g2 = (_g2 + 1);
HXDLIN( 168)						int i = (_g2 - 1);
HXDLIN( 168)						pA = (pA + 1);
HXDLIN( 168)						_this->pointsAnti[(pA - 1)] = temp->__get(i);
            					}
            				}
HXDLIN( 168)				int pC = _this->pointsClock->length;
HXDLIN( 168)				{
HXLINE( 168)					int _g4 = 1;
HXDLIN( 168)					int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 168)					while((_g4 < _g5)){
HXLINE( 168)						_g4 = (_g4 + 1);
HXDLIN( 168)						int i = (_g4 - 1);
HXDLIN( 168)						pC = (pC + 1);
HXDLIN( 168)						_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 168)						pC = (pC + 1);
HXDLIN( 168)						_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            					}
            				}
            			}
            		}
HXLINE( 169)		this->x = x_;
HXLINE( 170)		this->y = y_;
HXLINE( 171)		int l = this->points->length;
HXLINE( 172)		this->points[l] = ::Array_obj< Float >::__new();
HXLINE( 173)		this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXLINE( 174)		this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXLINE( 177)		this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 178)		this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXLINE( 180)		this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXLINE( 181)		{
HXLINE( 181)			 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 181)			if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 181)				d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 181)			if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 181)				d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 181)			if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 181)				d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            			}
HXDLIN( 181)			if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 181)				d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            			}
            		}
HXLINE( 182)		this->contour->reset();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,moveTo,(void))

void Sketcher_obj::lastClock(){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_186_lastClock)
HXDLIN( 186)		if ((this->contour->pointsClock->length != 0)) {
HXLINE( 188)			this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 189)			this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketcher_obj,lastClock,(void))

::Array< ::Dynamic> Sketcher_obj::getEdges(){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_195_getEdges)
HXLINE( 196)		::Array< ::Dynamic> edges = ::Array_obj< ::Dynamic>::__new();
HXLINE( 197)		int no = this->pointsClock->length;
HXLINE( 198)		if ((no > this->pointsAnti->length)) {
HXLINE( 198)			no = this->pointsAnti->length;
            		}
HXLINE( 199)		::Array< Float > pClock;
HXLINE( 200)		::Array< Float > pAnti;
HXLINE( 201)		::Array< Float > shape;
HXLINE( 202)		{
HXLINE( 202)			int _g = 0;
HXDLIN( 202)			int _g1 = no;
HXDLIN( 202)			while((_g < _g1)){
HXLINE( 202)				_g = (_g + 1);
HXDLIN( 202)				int s = (_g - 1);
HXLINE( 203)				pClock = this->pointsClock->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 204)				pAnti = this->pointsAnti->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 205)				int lc = pClock->length;
HXLINE( 206)				int la = pAnti->length;
HXLINE( 207)				edges[s] = ::Array_obj< Float >::__new();
HXLINE( 208)				shape = edges->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 209)				{
HXLINE( 209)					int _g1 = 0;
HXDLIN( 209)					int _g2 = lc;
HXDLIN( 209)					while((_g1 < _g2)){
HXLINE( 209)						_g1 = (_g1 + 1);
HXDLIN( 209)						int i = (_g1 - 1);
HXDLIN( 209)						shape[i] = pClock->__get(i);
            					}
            				}
HXLINE( 210)				int j = shape->length;
HXLINE( 211)				int l5 = ::Std_obj::_hx_int((( (Float)(la) ) / ( (Float)(2) )));
HXLINE( 212)				{
HXLINE( 212)					int _g3 = 0;
HXDLIN( 212)					int _g4 = l5;
HXDLIN( 212)					while((_g3 < _g4)){
HXLINE( 212)						_g3 = (_g3 + 1);
HXDLIN( 212)						int i = (_g3 - 1);
HXLINE( 213)						shape[(j + (i * 2))] = pAnti->__get(((la - (i * 2)) - 1));
HXLINE( 214)						shape[((j + (i * 2)) + 1)] = pAnti->__get((la - (i * 2)));
            					}
            				}
HXLINE( 216)				j = shape->length;
HXLINE( 217)				j = (j + 1);
HXDLIN( 217)				shape[(j - 1)] = pClock->__get(0);
HXLINE( 218)				shape[j] = pClock->__get(1);
            			}
            		}
HXLINE( 220)		return edges;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketcher_obj,getEdges,return )

void Sketcher_obj::lineTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_223_lineTo)
HXLINE( 224)		bool repeat;
HXDLIN( 224)		if ((this->x == x_)) {
HXLINE( 224)			repeat = (this->y == y_);
            		}
            		else {
HXLINE( 224)			repeat = false;
            		}
HXLINE( 225)		if (!(repeat)) {
HXLINE( 226)			if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 226)				this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            			}
HXLINE( 227)			if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 227)				this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            			}
HXLINE( 228)			this->line(x_,y_);
HXLINE( 229)			int l = this->points->length;
HXLINE( 230)			::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXLINE( 231)			int l2 = p->length;
HXLINE( 232)			p[l2] = x_;
HXLINE( 233)			p[(l2 + 1)] = y_;
HXLINE( 234)			{
HXLINE( 234)				 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 234)				if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 234)					d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 234)				if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 234)					d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 234)				if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 234)					d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            				}
HXDLIN( 234)				if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 234)					d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            				}
            			}
HXLINE( 235)			this->x = x_;
HXLINE( 236)			this->y = y_;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,lineTo,(void))

void Sketcher_obj::quadTo(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_240_quadTo)
HXLINE( 241)		this->tempArr = ::Array_obj< Float >::__new(0);
HXLINE( 242)		{
HXLINE( 242)			::Array< Float > p = this->tempArr;
HXDLIN( 242)			Float ax = this->x;
HXDLIN( 242)			Float ay = this->y;
HXDLIN( 242)			Float x = (ax - x1);
HXDLIN( 242)			Float y = (ay - y1);
HXDLIN( 242)			Float x3 = (x1 - x2);
HXDLIN( 242)			Float y3 = (y1 - y2);
HXDLIN( 242)			Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
HXDLIN( 242)			if ((approxDistance == 0)) {
HXLINE( 242)				approxDistance = ((Float)0.000001);
            			}
HXDLIN( 242)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::cornerContour::_CurveMath::CurveMath_Fields__obj::quadStep);
HXDLIN( 242)			int l = p->length;
HXDLIN( 242)			l = (l + 1);
HXDLIN( 242)			p[(l - 1)] = ax;
HXDLIN( 242)			l = (l + 1);
HXDLIN( 242)			p[(l - 1)] = ay;
HXDLIN( 242)			Float t = step;
HXDLIN( 242)			while((t < ((Float)1.))){
HXLINE( 242)				l = (l + 1);
HXDLIN( 242)				Float u = (( (Float)(1) ) - t);
HXDLIN( 242)				p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 242)				l = (l + 1);
HXDLIN( 242)				Float u1 = (( (Float)(1) ) - t);
HXDLIN( 242)				p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 242)				t = (t + step);
            			}
HXDLIN( 242)			l = (l + 1);
HXDLIN( 242)			p[(l - 1)] = x2;
HXDLIN( 242)			l = (l + 1);
HXDLIN( 242)			p[(l - 1)] = y2;
            		}
HXLINE( 243)		{
HXLINE( 243)			::Array< Float > arr = this->tempArr;
HXDLIN( 243)			 ::Dynamic withMove = false;
HXDLIN( 243)			if (::hx::IsNull( withMove )) {
HXLINE( 243)				withMove = true;
            			}
HXDLIN( 243)			int l1 = arr->length;
HXDLIN( 243)			int i = 2;
HXDLIN( 243)			if (( (bool)(withMove) )) {
HXLINE( 243)				Float x_ = arr->__get(0);
HXDLIN( 243)				Float y_ = arr->__get(1);
HXDLIN( 243)				bool _hx_tmp;
HXDLIN( 243)				if ((this->endLine != 2)) {
HXLINE( 243)					_hx_tmp = (this->endLine == 3);
            				}
            				else {
HXLINE( 243)					_hx_tmp = true;
            				}
HXDLIN( 243)				if (_hx_tmp) {
HXLINE( 243)					 ::cornerContour::Contour _this = this->contour;
HXDLIN( 243)					Float width_ = this->width;
HXDLIN( 243)					_this->endEdges();
HXDLIN( 243)					if ((_this->count != 0)) {
HXLINE( 243)						Float ax = _this->bx;
HXDLIN( 243)						Float ay = _this->by;
HXDLIN( 243)						Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 243)						Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 243)						Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 243)						::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 243)						{
HXLINE( 243)							int color = 0;
HXDLIN( 243)							 ::Dynamic sides = 36;
HXDLIN( 243)							if (::hx::IsNull( sides )) {
HXLINE( 243)								sides = 36;
            							}
HXDLIN( 243)							Float pi = ::Math_obj::PI;
HXDLIN( 243)							Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 243)							Float dif;
HXDLIN( 243)							switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            								case (int)0: {
HXLINE( 243)									Float f;
HXDLIN( 243)									bool f1;
HXDLIN( 243)									if ((beta >= 0)) {
HXLINE( 243)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f1 = false;
            									}
HXDLIN( 243)									if (f1) {
HXLINE( 243)										f = beta;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f = a;
            										}
            										else {
HXLINE( 243)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this1 = f;
HXDLIN( 243)									Float za = this1;
HXDLIN( 243)									Float f2;
HXDLIN( 243)									bool f3;
HXDLIN( 243)									if ((gamma >= 0)) {
HXLINE( 243)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f3 = false;
            									}
HXDLIN( 243)									if (f3) {
HXLINE( 243)										f2 = gamma;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f2 = a;
            										}
            										else {
HXLINE( 243)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this2 = f2;
HXDLIN( 243)									Float zb = this2;
HXDLIN( 243)									Float fa = za;
HXDLIN( 243)									Float fb = zb;
HXDLIN( 243)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 243)									bool clockwise = (fa < fb);
HXDLIN( 243)									Float dif1;
HXDLIN( 243)									if (clockwise) {
HXLINE( 243)										dif1 = theta;
            									}
            									else {
HXLINE( 243)										dif1 = -(theta);
            									}
HXDLIN( 243)									if ((dif1 > 0)) {
HXLINE( 243)										dif = dif1;
            									}
            									else {
HXLINE( 243)										dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            									}
            								}
            								break;
            								case (int)1: {
HXLINE( 243)									Float f;
HXDLIN( 243)									bool f1;
HXDLIN( 243)									if ((beta >= 0)) {
HXLINE( 243)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f1 = false;
            									}
HXDLIN( 243)									if (f1) {
HXLINE( 243)										f = beta;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f = a;
            										}
            										else {
HXLINE( 243)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this1 = f;
HXDLIN( 243)									Float za = this1;
HXDLIN( 243)									Float f2;
HXDLIN( 243)									bool f3;
HXDLIN( 243)									if ((gamma >= 0)) {
HXLINE( 243)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f3 = false;
            									}
HXDLIN( 243)									if (f3) {
HXLINE( 243)										f2 = gamma;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f2 = a;
            										}
            										else {
HXLINE( 243)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this2 = f2;
HXDLIN( 243)									Float zb = this2;
HXDLIN( 243)									Float fa = za;
HXDLIN( 243)									Float fb = zb;
HXDLIN( 243)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 243)									bool clockwise = (fa < fb);
HXDLIN( 243)									Float dif1;
HXDLIN( 243)									if (clockwise) {
HXLINE( 243)										dif1 = theta;
            									}
            									else {
HXLINE( 243)										dif1 = -(theta);
            									}
HXDLIN( 243)									if ((dif1 < 0)) {
HXLINE( 243)										dif = dif1;
            									}
            									else {
HXLINE( 243)										dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            									}
            								}
            								break;
            								case (int)2: {
HXLINE( 243)									Float f;
HXDLIN( 243)									bool f1;
HXDLIN( 243)									if ((beta >= 0)) {
HXLINE( 243)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f1 = false;
            									}
HXDLIN( 243)									if (f1) {
HXLINE( 243)										f = beta;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f = a;
            										}
            										else {
HXLINE( 243)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this1 = f;
HXDLIN( 243)									Float za = this1;
HXDLIN( 243)									Float f2;
HXDLIN( 243)									bool f3;
HXDLIN( 243)									if ((gamma >= 0)) {
HXLINE( 243)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f3 = false;
            									}
HXDLIN( 243)									if (f3) {
HXLINE( 243)										f2 = gamma;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f2 = a;
            										}
            										else {
HXLINE( 243)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this2 = f2;
HXDLIN( 243)									Float zb = this2;
HXDLIN( 243)									Float fa = za;
HXDLIN( 243)									Float fb = zb;
HXDLIN( 243)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 243)									bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 243)									bool clockwise = (fa < fb);
HXDLIN( 243)									Float dif1;
HXDLIN( 243)									if (clockwise) {
HXLINE( 243)										dif1 = theta;
            									}
            									else {
HXLINE( 243)										dif1 = -(theta);
            									}
HXDLIN( 243)									if (smallest) {
HXLINE( 243)										dif = dif1;
            									}
            									else {
HXLINE( 243)										if (clockwise) {
HXLINE( 243)											dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            										}
            										else {
HXLINE( 243)											dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            										}
            									}
            								}
            								break;
            								case (int)3: {
HXLINE( 243)									Float f;
HXDLIN( 243)									bool f1;
HXDLIN( 243)									if ((beta >= 0)) {
HXLINE( 243)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f1 = false;
            									}
HXDLIN( 243)									if (f1) {
HXLINE( 243)										f = beta;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f = a;
            										}
            										else {
HXLINE( 243)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this1 = f;
HXDLIN( 243)									Float za = this1;
HXDLIN( 243)									Float f2;
HXDLIN( 243)									bool f3;
HXDLIN( 243)									if ((gamma >= 0)) {
HXLINE( 243)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 243)										f3 = false;
            									}
HXDLIN( 243)									if (f3) {
HXLINE( 243)										f2 = gamma;
            									}
            									else {
HXLINE( 243)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 243)										if ((a >= 0)) {
HXLINE( 243)											f2 = a;
            										}
            										else {
HXLINE( 243)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 243)									Float this2 = f2;
HXDLIN( 243)									Float zb = this2;
HXDLIN( 243)									Float fa = za;
HXDLIN( 243)									Float fb = zb;
HXDLIN( 243)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 243)									bool largest = (theta > ::Math_obj::PI);
HXDLIN( 243)									bool clockwise = (fa < fb);
HXDLIN( 243)									Float dif1;
HXDLIN( 243)									if (clockwise) {
HXLINE( 243)										dif1 = theta;
            									}
            									else {
HXLINE( 243)										dif1 = -(theta);
            									}
HXDLIN( 243)									if (largest) {
HXLINE( 243)										dif = dif1;
            									}
            									else {
HXLINE( 243)										if (clockwise) {
HXLINE( 243)											dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            										}
            										else {
HXLINE( 243)											dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            										}
            									}
            								}
            								break;
            							}
HXDLIN( 243)							bool positive = (dif >= 0);
HXDLIN( 243)							int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 243)							Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 243)							Float angle = beta;
HXDLIN( 243)							Float cx;
HXDLIN( 243)							Float cy;
HXDLIN( 243)							Float bx = ( (Float)(0) );
HXDLIN( 243)							Float by = ( (Float)(0) );
HXDLIN( 243)							int p2 = temp->length;
HXDLIN( 243)							{
HXLINE( 243)								int _g = 0;
HXDLIN( 243)								int _g1 = (totalSteps + 1);
HXDLIN( 243)								while((_g < _g1)){
HXLINE( 243)									_g = (_g + 1);
HXDLIN( 243)									int i = (_g - 1);
HXDLIN( 243)									cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 243)									cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 243)									p2 = (p2 + 1);
HXDLIN( 243)									temp[(p2 - 1)] = cx;
HXDLIN( 243)									p2 = (p2 + 1);
HXDLIN( 243)									temp[(p2 - 1)] = cy;
HXDLIN( 243)									if ((i != 0)) {
HXLINE( 243)										::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            									}
HXDLIN( 243)									angle = (angle + step1);
HXDLIN( 243)									bx = cx;
HXDLIN( 243)									by = cy;
            								}
            							}
            						}
HXDLIN( 243)						int pA = _this->pointsAnti->length;
HXDLIN( 243)						int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 243)						{
HXLINE( 243)							int _g2 = 0;
HXDLIN( 243)							int _g3 = (len + 2);
HXDLIN( 243)							while((_g2 < _g3)){
HXLINE( 243)								_g2 = (_g2 + 1);
HXDLIN( 243)								int i = (_g2 - 1);
HXDLIN( 243)								pA = (pA + 1);
HXDLIN( 243)								_this->pointsAnti[(pA - 1)] = temp->__get(i);
            							}
            						}
HXDLIN( 243)						int pC = _this->pointsClock->length;
HXDLIN( 243)						{
HXLINE( 243)							int _g4 = 1;
HXDLIN( 243)							int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 243)							while((_g4 < _g5)){
HXLINE( 243)								_g4 = (_g4 + 1);
HXDLIN( 243)								int i = (_g4 - 1);
HXDLIN( 243)								pC = (pC + 1);
HXDLIN( 243)								_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 243)								pC = (pC + 1);
HXDLIN( 243)								_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            							}
            						}
            					}
            				}
HXDLIN( 243)				this->x = x_;
HXDLIN( 243)				this->y = y_;
HXDLIN( 243)				int l = this->points->length;
HXDLIN( 243)				this->points[l] = ::Array_obj< Float >::__new();
HXDLIN( 243)				this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXDLIN( 243)				this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXDLIN( 243)				this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXDLIN( 243)				this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXDLIN( 243)				this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            					->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            					->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            					->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            					->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXDLIN( 243)				{
HXLINE( 243)					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 243)					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 243)						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 243)					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 243)						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 243)					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 243)						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            					}
HXDLIN( 243)					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 243)						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            					}
            				}
HXDLIN( 243)				this->contour->reset();
            			}
            			else {
HXLINE( 243)				Float x_ = arr->__get(0);
HXDLIN( 243)				Float y_ = arr->__get(1);
HXDLIN( 243)				bool repeat;
HXDLIN( 243)				if ((this->x == x_)) {
HXLINE( 243)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 243)					repeat = false;
            				}
HXDLIN( 243)				if (!(repeat)) {
HXLINE( 243)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 243)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 243)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 243)						this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            					}
HXDLIN( 243)					this->line(x_,y_);
HXDLIN( 243)					int l = this->points->length;
HXDLIN( 243)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 243)					int l2 = p->length;
HXDLIN( 243)					p[l2] = x_;
HXDLIN( 243)					p[(l2 + 1)] = y_;
HXDLIN( 243)					{
HXLINE( 243)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 243)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 243)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 243)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 243)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 243)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 243)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 243)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 243)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 243)					this->x = x_;
HXDLIN( 243)					this->y = y_;
            				}
            			}
HXDLIN( 243)			while((i < l1)){
HXLINE( 243)				{
HXLINE( 243)					Float x_ = arr->__get(i);
HXDLIN( 243)					Float y_ = arr->__get((i + 1));
HXDLIN( 243)					bool repeat;
HXDLIN( 243)					if ((this->x == x_)) {
HXLINE( 243)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 243)						repeat = false;
            					}
HXDLIN( 243)					if (!(repeat)) {
HXLINE( 243)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 243)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 243)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 243)							this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            						}
HXDLIN( 243)						this->line(x_,y_);
HXDLIN( 243)						int l = this->points->length;
HXDLIN( 243)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 243)						int l2 = p->length;
HXDLIN( 243)						p[l2] = x_;
HXDLIN( 243)						p[(l2 + 1)] = y_;
HXDLIN( 243)						{
HXLINE( 243)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 243)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 243)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 243)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 243)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 243)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 243)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 243)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 243)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 243)						this->x = x_;
HXDLIN( 243)						this->y = y_;
            					}
            				}
HXDLIN( 243)				i = (i + 2);
            			}
            		}
HXLINE( 244)		this->x = x2;
HXLINE( 245)		this->y = y2;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketcher_obj,quadTo,(void))

void Sketcher_obj::quadThru(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_249_quadThru)
HXLINE( 250)		Float newx = ((( (Float)(2) ) * x1) - (((Float)0.5) * (this->x + x2)));
HXLINE( 251)		Float newy = ((( (Float)(2) ) * y1) - (((Float)0.5) * (this->y + y2)));
HXLINE( 252)		{
HXLINE( 252)			this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 252)			{
HXLINE( 252)				::Array< Float > p = this->tempArr;
HXDLIN( 252)				Float ax = this->x;
HXDLIN( 252)				Float ay = this->y;
HXDLIN( 252)				Float x = (ax - newx);
HXDLIN( 252)				Float y = (ay - newy);
HXDLIN( 252)				Float x3 = (newx - x2);
HXDLIN( 252)				Float y3 = (newy - y2);
HXDLIN( 252)				Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
HXDLIN( 252)				if ((approxDistance == 0)) {
HXLINE( 252)					approxDistance = ((Float)0.000001);
            				}
HXDLIN( 252)				Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::cornerContour::_CurveMath::CurveMath_Fields__obj::quadStep);
HXDLIN( 252)				int l = p->length;
HXDLIN( 252)				l = (l + 1);
HXDLIN( 252)				p[(l - 1)] = ax;
HXDLIN( 252)				l = (l + 1);
HXDLIN( 252)				p[(l - 1)] = ay;
HXDLIN( 252)				Float t = step;
HXDLIN( 252)				while((t < ((Float)1.))){
HXLINE( 252)					l = (l + 1);
HXDLIN( 252)					Float u = (( (Float)(1) ) - t);
HXDLIN( 252)					p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * newx)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 252)					l = (l + 1);
HXDLIN( 252)					Float u1 = (( (Float)(1) ) - t);
HXDLIN( 252)					p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * newy)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 252)					t = (t + step);
            				}
HXDLIN( 252)				l = (l + 1);
HXDLIN( 252)				p[(l - 1)] = x2;
HXDLIN( 252)				l = (l + 1);
HXDLIN( 252)				p[(l - 1)] = y2;
            			}
HXDLIN( 252)			{
HXLINE( 252)				::Array< Float > arr = this->tempArr;
HXDLIN( 252)				 ::Dynamic withMove = false;
HXDLIN( 252)				if (::hx::IsNull( withMove )) {
HXLINE( 252)					withMove = true;
            				}
HXDLIN( 252)				int l1 = arr->length;
HXDLIN( 252)				int i = 2;
HXDLIN( 252)				if (( (bool)(withMove) )) {
HXLINE( 252)					Float x_ = arr->__get(0);
HXDLIN( 252)					Float y_ = arr->__get(1);
HXDLIN( 252)					bool _hx_tmp;
HXDLIN( 252)					if ((this->endLine != 2)) {
HXLINE( 252)						_hx_tmp = (this->endLine == 3);
            					}
            					else {
HXLINE( 252)						_hx_tmp = true;
            					}
HXDLIN( 252)					if (_hx_tmp) {
HXLINE( 252)						 ::cornerContour::Contour _this = this->contour;
HXDLIN( 252)						Float width_ = this->width;
HXDLIN( 252)						_this->endEdges();
HXDLIN( 252)						if ((_this->count != 0)) {
HXLINE( 252)							Float ax = _this->bx;
HXDLIN( 252)							Float ay = _this->by;
HXDLIN( 252)							Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 252)							Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 252)							Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 252)							::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 252)							{
HXLINE( 252)								int color = 0;
HXDLIN( 252)								 ::Dynamic sides = 36;
HXDLIN( 252)								if (::hx::IsNull( sides )) {
HXLINE( 252)									sides = 36;
            								}
HXDLIN( 252)								Float pi = ::Math_obj::PI;
HXDLIN( 252)								Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 252)								Float dif;
HXDLIN( 252)								switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            									case (int)0: {
HXLINE( 252)										Float f;
HXDLIN( 252)										bool f1;
HXDLIN( 252)										if ((beta >= 0)) {
HXLINE( 252)											f1 = (beta > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f1 = false;
            										}
HXDLIN( 252)										if (f1) {
HXLINE( 252)											f = beta;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f = a;
            											}
            											else {
HXLINE( 252)												f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this1 = f;
HXDLIN( 252)										Float za = this1;
HXDLIN( 252)										Float f2;
HXDLIN( 252)										bool f3;
HXDLIN( 252)										if ((gamma >= 0)) {
HXLINE( 252)											f3 = (gamma > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f3 = false;
            										}
HXDLIN( 252)										if (f3) {
HXLINE( 252)											f2 = gamma;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f2 = a;
            											}
            											else {
HXLINE( 252)												f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this2 = f2;
HXDLIN( 252)										Float zb = this2;
HXDLIN( 252)										Float fa = za;
HXDLIN( 252)										Float fb = zb;
HXDLIN( 252)										Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 252)										bool clockwise = (fa < fb);
HXDLIN( 252)										Float dif1;
HXDLIN( 252)										if (clockwise) {
HXLINE( 252)											dif1 = theta;
            										}
            										else {
HXLINE( 252)											dif1 = -(theta);
            										}
HXDLIN( 252)										if ((dif1 > 0)) {
HXLINE( 252)											dif = dif1;
            										}
            										else {
HXLINE( 252)											dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            										}
            									}
            									break;
            									case (int)1: {
HXLINE( 252)										Float f;
HXDLIN( 252)										bool f1;
HXDLIN( 252)										if ((beta >= 0)) {
HXLINE( 252)											f1 = (beta > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f1 = false;
            										}
HXDLIN( 252)										if (f1) {
HXLINE( 252)											f = beta;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f = a;
            											}
            											else {
HXLINE( 252)												f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this1 = f;
HXDLIN( 252)										Float za = this1;
HXDLIN( 252)										Float f2;
HXDLIN( 252)										bool f3;
HXDLIN( 252)										if ((gamma >= 0)) {
HXLINE( 252)											f3 = (gamma > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f3 = false;
            										}
HXDLIN( 252)										if (f3) {
HXLINE( 252)											f2 = gamma;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f2 = a;
            											}
            											else {
HXLINE( 252)												f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this2 = f2;
HXDLIN( 252)										Float zb = this2;
HXDLIN( 252)										Float fa = za;
HXDLIN( 252)										Float fb = zb;
HXDLIN( 252)										Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 252)										bool clockwise = (fa < fb);
HXDLIN( 252)										Float dif1;
HXDLIN( 252)										if (clockwise) {
HXLINE( 252)											dif1 = theta;
            										}
            										else {
HXLINE( 252)											dif1 = -(theta);
            										}
HXDLIN( 252)										if ((dif1 < 0)) {
HXLINE( 252)											dif = dif1;
            										}
            										else {
HXLINE( 252)											dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            										}
            									}
            									break;
            									case (int)2: {
HXLINE( 252)										Float f;
HXDLIN( 252)										bool f1;
HXDLIN( 252)										if ((beta >= 0)) {
HXLINE( 252)											f1 = (beta > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f1 = false;
            										}
HXDLIN( 252)										if (f1) {
HXLINE( 252)											f = beta;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f = a;
            											}
            											else {
HXLINE( 252)												f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this1 = f;
HXDLIN( 252)										Float za = this1;
HXDLIN( 252)										Float f2;
HXDLIN( 252)										bool f3;
HXDLIN( 252)										if ((gamma >= 0)) {
HXLINE( 252)											f3 = (gamma > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f3 = false;
            										}
HXDLIN( 252)										if (f3) {
HXLINE( 252)											f2 = gamma;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f2 = a;
            											}
            											else {
HXLINE( 252)												f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this2 = f2;
HXDLIN( 252)										Float zb = this2;
HXDLIN( 252)										Float fa = za;
HXDLIN( 252)										Float fb = zb;
HXDLIN( 252)										Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 252)										bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 252)										bool clockwise = (fa < fb);
HXDLIN( 252)										Float dif1;
HXDLIN( 252)										if (clockwise) {
HXLINE( 252)											dif1 = theta;
            										}
            										else {
HXLINE( 252)											dif1 = -(theta);
            										}
HXDLIN( 252)										if (smallest) {
HXLINE( 252)											dif = dif1;
            										}
            										else {
HXLINE( 252)											if (clockwise) {
HXLINE( 252)												dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            											}
            											else {
HXLINE( 252)												dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            											}
            										}
            									}
            									break;
            									case (int)3: {
HXLINE( 252)										Float f;
HXDLIN( 252)										bool f1;
HXDLIN( 252)										if ((beta >= 0)) {
HXLINE( 252)											f1 = (beta > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f1 = false;
            										}
HXDLIN( 252)										if (f1) {
HXLINE( 252)											f = beta;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f = a;
            											}
            											else {
HXLINE( 252)												f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this1 = f;
HXDLIN( 252)										Float za = this1;
HXDLIN( 252)										Float f2;
HXDLIN( 252)										bool f3;
HXDLIN( 252)										if ((gamma >= 0)) {
HXLINE( 252)											f3 = (gamma > ::Math_obj::PI);
            										}
            										else {
HXLINE( 252)											f3 = false;
            										}
HXDLIN( 252)										if (f3) {
HXLINE( 252)											f2 = gamma;
            										}
            										else {
HXLINE( 252)											Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 252)											if ((a >= 0)) {
HXLINE( 252)												f2 = a;
            											}
            											else {
HXLINE( 252)												f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            											}
            										}
HXDLIN( 252)										Float this2 = f2;
HXDLIN( 252)										Float zb = this2;
HXDLIN( 252)										Float fa = za;
HXDLIN( 252)										Float fb = zb;
HXDLIN( 252)										Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 252)										bool largest = (theta > ::Math_obj::PI);
HXDLIN( 252)										bool clockwise = (fa < fb);
HXDLIN( 252)										Float dif1;
HXDLIN( 252)										if (clockwise) {
HXLINE( 252)											dif1 = theta;
            										}
            										else {
HXLINE( 252)											dif1 = -(theta);
            										}
HXDLIN( 252)										if (largest) {
HXLINE( 252)											dif = dif1;
            										}
            										else {
HXLINE( 252)											if (clockwise) {
HXLINE( 252)												dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            											}
            											else {
HXLINE( 252)												dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            											}
            										}
            									}
            									break;
            								}
HXDLIN( 252)								bool positive = (dif >= 0);
HXDLIN( 252)								int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 252)								Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 252)								Float angle = beta;
HXDLIN( 252)								Float cx;
HXDLIN( 252)								Float cy;
HXDLIN( 252)								Float bx = ( (Float)(0) );
HXDLIN( 252)								Float by = ( (Float)(0) );
HXDLIN( 252)								int p2 = temp->length;
HXDLIN( 252)								{
HXLINE( 252)									int _g = 0;
HXDLIN( 252)									int _g1 = (totalSteps + 1);
HXDLIN( 252)									while((_g < _g1)){
HXLINE( 252)										_g = (_g + 1);
HXDLIN( 252)										int i = (_g - 1);
HXDLIN( 252)										cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 252)										cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 252)										p2 = (p2 + 1);
HXDLIN( 252)										temp[(p2 - 1)] = cx;
HXDLIN( 252)										p2 = (p2 + 1);
HXDLIN( 252)										temp[(p2 - 1)] = cy;
HXDLIN( 252)										if ((i != 0)) {
HXLINE( 252)											::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            										}
HXDLIN( 252)										angle = (angle + step1);
HXDLIN( 252)										bx = cx;
HXDLIN( 252)										by = cy;
            									}
            								}
            							}
HXDLIN( 252)							int pA = _this->pointsAnti->length;
HXDLIN( 252)							int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 252)							{
HXLINE( 252)								int _g2 = 0;
HXDLIN( 252)								int _g3 = (len + 2);
HXDLIN( 252)								while((_g2 < _g3)){
HXLINE( 252)									_g2 = (_g2 + 1);
HXDLIN( 252)									int i = (_g2 - 1);
HXDLIN( 252)									pA = (pA + 1);
HXDLIN( 252)									_this->pointsAnti[(pA - 1)] = temp->__get(i);
            								}
            							}
HXDLIN( 252)							int pC = _this->pointsClock->length;
HXDLIN( 252)							{
HXLINE( 252)								int _g4 = 1;
HXDLIN( 252)								int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 252)								while((_g4 < _g5)){
HXLINE( 252)									_g4 = (_g4 + 1);
HXDLIN( 252)									int i = (_g4 - 1);
HXDLIN( 252)									pC = (pC + 1);
HXDLIN( 252)									_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 252)									pC = (pC + 1);
HXDLIN( 252)									_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            								}
            							}
            						}
            					}
HXDLIN( 252)					this->x = x_;
HXDLIN( 252)					this->y = y_;
HXDLIN( 252)					int l = this->points->length;
HXDLIN( 252)					this->points[l] = ::Array_obj< Float >::__new();
HXDLIN( 252)					this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXDLIN( 252)					this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXDLIN( 252)					this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXDLIN( 252)					this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXDLIN( 252)					this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            						->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            						->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            						->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            						->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXDLIN( 252)					{
HXLINE( 252)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 252)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 252)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 252)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 252)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 252)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 252)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 252)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 252)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 252)					this->contour->reset();
            				}
            				else {
HXLINE( 252)					Float x_ = arr->__get(0);
HXDLIN( 252)					Float y_ = arr->__get(1);
HXDLIN( 252)					bool repeat;
HXDLIN( 252)					if ((this->x == x_)) {
HXLINE( 252)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 252)						repeat = false;
            					}
HXDLIN( 252)					if (!(repeat)) {
HXLINE( 252)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 252)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 252)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 252)							this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            						}
HXDLIN( 252)						this->line(x_,y_);
HXDLIN( 252)						int l = this->points->length;
HXDLIN( 252)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 252)						int l2 = p->length;
HXDLIN( 252)						p[l2] = x_;
HXDLIN( 252)						p[(l2 + 1)] = y_;
HXDLIN( 252)						{
HXLINE( 252)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 252)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 252)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 252)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 252)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 252)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 252)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 252)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 252)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 252)						this->x = x_;
HXDLIN( 252)						this->y = y_;
            					}
            				}
HXDLIN( 252)				while((i < l1)){
HXLINE( 252)					{
HXLINE( 252)						Float x_ = arr->__get(i);
HXDLIN( 252)						Float y_ = arr->__get((i + 1));
HXDLIN( 252)						bool repeat;
HXDLIN( 252)						if ((this->x == x_)) {
HXLINE( 252)							repeat = (this->y == y_);
            						}
            						else {
HXLINE( 252)							repeat = false;
            						}
HXDLIN( 252)						if (!(repeat)) {
HXLINE( 252)							if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 252)								this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            							}
HXDLIN( 252)							if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 252)								this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            							}
HXDLIN( 252)							this->line(x_,y_);
HXDLIN( 252)							int l = this->points->length;
HXDLIN( 252)							::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 252)							int l2 = p->length;
HXDLIN( 252)							p[l2] = x_;
HXDLIN( 252)							p[(l2 + 1)] = y_;
HXDLIN( 252)							{
HXLINE( 252)								 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 252)								if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 252)									d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            								}
HXDLIN( 252)								if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 252)									d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            								}
HXDLIN( 252)								if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 252)									d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            								}
HXDLIN( 252)								if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 252)									d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            								}
            							}
HXDLIN( 252)							this->x = x_;
HXDLIN( 252)							this->y = y_;
            						}
            					}
HXDLIN( 252)					i = (i + 2);
            				}
            			}
HXDLIN( 252)			this->x = x2;
HXDLIN( 252)			this->y = y2;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketcher_obj,quadThru,(void))

void Sketcher_obj::curveTo(Float x1,Float y1,Float x2,Float y2,Float x3,Float y3){
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_255_curveTo)
HXLINE( 256)		this->tempArr = ::Array_obj< Float >::__new(0);
HXLINE( 257)		{
HXLINE( 257)			::Array< Float > p = this->tempArr;
HXDLIN( 257)			Float ax = this->x;
HXDLIN( 257)			Float ay = this->y;
HXDLIN( 257)			Float x = (ax - x1);
HXDLIN( 257)			Float y = (ay - y1);
HXDLIN( 257)			Float x4 = (x1 - x2);
HXDLIN( 257)			Float y4 = (y1 - y2);
HXDLIN( 257)			Float x5 = (x2 - x3);
HXDLIN( 257)			Float y5 = (y2 - y3);
HXDLIN( 257)			Float approxDistance = ((::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4)))) + ::Math_obj::sqrt(((x5 * x5) + (y5 * y5))));
HXDLIN( 257)			if ((approxDistance == 0)) {
HXLINE( 257)				approxDistance = ((Float)0.000001);
            			}
HXDLIN( 257)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),((Float)0.03));
HXDLIN( 257)			int l = p->length;
HXDLIN( 257)			l = (l + 1);
HXDLIN( 257)			p[(l - 1)] = ax;
HXDLIN( 257)			l = (l + 1);
HXDLIN( 257)			p[(l - 1)] = ay;
HXDLIN( 257)			Float t = step;
HXDLIN( 257)			while((t < ((Float)1.))){
HXLINE( 257)				l = (l + 1);
HXDLIN( 257)				Float u = (( (Float)(1) ) - t);
HXDLIN( 257)				p[(l - 1)] = ((((::Math_obj::pow(u,( (Float)(3) )) * ax) + (((( (Float)(3) ) * ::Math_obj::pow(u,( (Float)(2) ))) * t) * x1)) + (((( (Float)(3) ) * u) * ::Math_obj::pow(t,( (Float)(2) ))) * x2)) + (::Math_obj::pow(t,( (Float)(3) )) * x3));
HXDLIN( 257)				l = (l + 1);
HXDLIN( 257)				Float u1 = (( (Float)(1) ) - t);
HXDLIN( 257)				p[(l - 1)] = ((((::Math_obj::pow(u1,( (Float)(3) )) * ay) + (((( (Float)(3) ) * ::Math_obj::pow(u1,( (Float)(2) ))) * t) * y1)) + (((( (Float)(3) ) * u1) * ::Math_obj::pow(t,( (Float)(2) ))) * y2)) + (::Math_obj::pow(t,( (Float)(3) )) * y3));
HXDLIN( 257)				t = (t + step);
            			}
HXDLIN( 257)			l = (l + 1);
HXDLIN( 257)			p[(l - 1)] = x3;
HXDLIN( 257)			l = (l + 1);
HXDLIN( 257)			p[(l - 1)] = y3;
            		}
HXLINE( 258)		{
HXLINE( 258)			::Array< Float > arr = this->tempArr;
HXDLIN( 258)			 ::Dynamic withMove = false;
HXDLIN( 258)			if (::hx::IsNull( withMove )) {
HXLINE( 258)				withMove = true;
            			}
HXDLIN( 258)			int l1 = arr->length;
HXDLIN( 258)			int i = 2;
HXDLIN( 258)			if (( (bool)(withMove) )) {
HXLINE( 258)				Float x_ = arr->__get(0);
HXDLIN( 258)				Float y_ = arr->__get(1);
HXDLIN( 258)				bool _hx_tmp;
HXDLIN( 258)				if ((this->endLine != 2)) {
HXLINE( 258)					_hx_tmp = (this->endLine == 3);
            				}
            				else {
HXLINE( 258)					_hx_tmp = true;
            				}
HXDLIN( 258)				if (_hx_tmp) {
HXLINE( 258)					 ::cornerContour::Contour _this = this->contour;
HXDLIN( 258)					Float width_ = this->width;
HXDLIN( 258)					_this->endEdges();
HXDLIN( 258)					if ((_this->count != 0)) {
HXLINE( 258)						Float ax = _this->bx;
HXDLIN( 258)						Float ay = _this->by;
HXDLIN( 258)						Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 258)						Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 258)						Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 258)						::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 258)						{
HXLINE( 258)							int color = 0;
HXDLIN( 258)							 ::Dynamic sides = 36;
HXDLIN( 258)							if (::hx::IsNull( sides )) {
HXLINE( 258)								sides = 36;
            							}
HXDLIN( 258)							Float pi = ::Math_obj::PI;
HXDLIN( 258)							Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 258)							Float dif;
HXDLIN( 258)							switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            								case (int)0: {
HXLINE( 258)									Float f;
HXDLIN( 258)									bool f1;
HXDLIN( 258)									if ((beta >= 0)) {
HXLINE( 258)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f1 = false;
            									}
HXDLIN( 258)									if (f1) {
HXLINE( 258)										f = beta;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f = a;
            										}
            										else {
HXLINE( 258)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this1 = f;
HXDLIN( 258)									Float za = this1;
HXDLIN( 258)									Float f2;
HXDLIN( 258)									bool f3;
HXDLIN( 258)									if ((gamma >= 0)) {
HXLINE( 258)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f3 = false;
            									}
HXDLIN( 258)									if (f3) {
HXLINE( 258)										f2 = gamma;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f2 = a;
            										}
            										else {
HXLINE( 258)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this2 = f2;
HXDLIN( 258)									Float zb = this2;
HXDLIN( 258)									Float fa = za;
HXDLIN( 258)									Float fb = zb;
HXDLIN( 258)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 258)									bool clockwise = (fa < fb);
HXDLIN( 258)									Float dif1;
HXDLIN( 258)									if (clockwise) {
HXLINE( 258)										dif1 = theta;
            									}
            									else {
HXLINE( 258)										dif1 = -(theta);
            									}
HXDLIN( 258)									if ((dif1 > 0)) {
HXLINE( 258)										dif = dif1;
            									}
            									else {
HXLINE( 258)										dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            									}
            								}
            								break;
            								case (int)1: {
HXLINE( 258)									Float f;
HXDLIN( 258)									bool f1;
HXDLIN( 258)									if ((beta >= 0)) {
HXLINE( 258)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f1 = false;
            									}
HXDLIN( 258)									if (f1) {
HXLINE( 258)										f = beta;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f = a;
            										}
            										else {
HXLINE( 258)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this1 = f;
HXDLIN( 258)									Float za = this1;
HXDLIN( 258)									Float f2;
HXDLIN( 258)									bool f3;
HXDLIN( 258)									if ((gamma >= 0)) {
HXLINE( 258)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f3 = false;
            									}
HXDLIN( 258)									if (f3) {
HXLINE( 258)										f2 = gamma;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f2 = a;
            										}
            										else {
HXLINE( 258)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this2 = f2;
HXDLIN( 258)									Float zb = this2;
HXDLIN( 258)									Float fa = za;
HXDLIN( 258)									Float fb = zb;
HXDLIN( 258)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 258)									bool clockwise = (fa < fb);
HXDLIN( 258)									Float dif1;
HXDLIN( 258)									if (clockwise) {
HXLINE( 258)										dif1 = theta;
            									}
            									else {
HXLINE( 258)										dif1 = -(theta);
            									}
HXDLIN( 258)									if ((dif1 < 0)) {
HXLINE( 258)										dif = dif1;
            									}
            									else {
HXLINE( 258)										dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            									}
            								}
            								break;
            								case (int)2: {
HXLINE( 258)									Float f;
HXDLIN( 258)									bool f1;
HXDLIN( 258)									if ((beta >= 0)) {
HXLINE( 258)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f1 = false;
            									}
HXDLIN( 258)									if (f1) {
HXLINE( 258)										f = beta;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f = a;
            										}
            										else {
HXLINE( 258)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this1 = f;
HXDLIN( 258)									Float za = this1;
HXDLIN( 258)									Float f2;
HXDLIN( 258)									bool f3;
HXDLIN( 258)									if ((gamma >= 0)) {
HXLINE( 258)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f3 = false;
            									}
HXDLIN( 258)									if (f3) {
HXLINE( 258)										f2 = gamma;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f2 = a;
            										}
            										else {
HXLINE( 258)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this2 = f2;
HXDLIN( 258)									Float zb = this2;
HXDLIN( 258)									Float fa = za;
HXDLIN( 258)									Float fb = zb;
HXDLIN( 258)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 258)									bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 258)									bool clockwise = (fa < fb);
HXDLIN( 258)									Float dif1;
HXDLIN( 258)									if (clockwise) {
HXLINE( 258)										dif1 = theta;
            									}
            									else {
HXLINE( 258)										dif1 = -(theta);
            									}
HXDLIN( 258)									if (smallest) {
HXLINE( 258)										dif = dif1;
            									}
            									else {
HXLINE( 258)										if (clockwise) {
HXLINE( 258)											dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            										}
            										else {
HXLINE( 258)											dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            										}
            									}
            								}
            								break;
            								case (int)3: {
HXLINE( 258)									Float f;
HXDLIN( 258)									bool f1;
HXDLIN( 258)									if ((beta >= 0)) {
HXLINE( 258)										f1 = (beta > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f1 = false;
            									}
HXDLIN( 258)									if (f1) {
HXLINE( 258)										f = beta;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f = a;
            										}
            										else {
HXLINE( 258)											f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this1 = f;
HXDLIN( 258)									Float za = this1;
HXDLIN( 258)									Float f2;
HXDLIN( 258)									bool f3;
HXDLIN( 258)									if ((gamma >= 0)) {
HXLINE( 258)										f3 = (gamma > ::Math_obj::PI);
            									}
            									else {
HXLINE( 258)										f3 = false;
            									}
HXDLIN( 258)									if (f3) {
HXLINE( 258)										f2 = gamma;
            									}
            									else {
HXLINE( 258)										Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 258)										if ((a >= 0)) {
HXLINE( 258)											f2 = a;
            										}
            										else {
HXLINE( 258)											f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            										}
            									}
HXDLIN( 258)									Float this2 = f2;
HXDLIN( 258)									Float zb = this2;
HXDLIN( 258)									Float fa = za;
HXDLIN( 258)									Float fb = zb;
HXDLIN( 258)									Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 258)									bool largest = (theta > ::Math_obj::PI);
HXDLIN( 258)									bool clockwise = (fa < fb);
HXDLIN( 258)									Float dif1;
HXDLIN( 258)									if (clockwise) {
HXLINE( 258)										dif1 = theta;
            									}
            									else {
HXLINE( 258)										dif1 = -(theta);
            									}
HXDLIN( 258)									if (largest) {
HXLINE( 258)										dif = dif1;
            									}
            									else {
HXLINE( 258)										if (clockwise) {
HXLINE( 258)											dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            										}
            										else {
HXLINE( 258)											dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            										}
            									}
            								}
            								break;
            							}
HXDLIN( 258)							bool positive = (dif >= 0);
HXDLIN( 258)							int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 258)							Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 258)							Float angle = beta;
HXDLIN( 258)							Float cx;
HXDLIN( 258)							Float cy;
HXDLIN( 258)							Float bx = ( (Float)(0) );
HXDLIN( 258)							Float by = ( (Float)(0) );
HXDLIN( 258)							int p2 = temp->length;
HXDLIN( 258)							{
HXLINE( 258)								int _g = 0;
HXDLIN( 258)								int _g1 = (totalSteps + 1);
HXDLIN( 258)								while((_g < _g1)){
HXLINE( 258)									_g = (_g + 1);
HXDLIN( 258)									int i = (_g - 1);
HXDLIN( 258)									cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 258)									cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 258)									p2 = (p2 + 1);
HXDLIN( 258)									temp[(p2 - 1)] = cx;
HXDLIN( 258)									p2 = (p2 + 1);
HXDLIN( 258)									temp[(p2 - 1)] = cy;
HXDLIN( 258)									if ((i != 0)) {
HXLINE( 258)										::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            									}
HXDLIN( 258)									angle = (angle + step1);
HXDLIN( 258)									bx = cx;
HXDLIN( 258)									by = cy;
            								}
            							}
            						}
HXDLIN( 258)						int pA = _this->pointsAnti->length;
HXDLIN( 258)						int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 258)						{
HXLINE( 258)							int _g2 = 0;
HXDLIN( 258)							int _g3 = (len + 2);
HXDLIN( 258)							while((_g2 < _g3)){
HXLINE( 258)								_g2 = (_g2 + 1);
HXDLIN( 258)								int i = (_g2 - 1);
HXDLIN( 258)								pA = (pA + 1);
HXDLIN( 258)								_this->pointsAnti[(pA - 1)] = temp->__get(i);
            							}
            						}
HXDLIN( 258)						int pC = _this->pointsClock->length;
HXDLIN( 258)						{
HXLINE( 258)							int _g4 = 1;
HXDLIN( 258)							int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 258)							while((_g4 < _g5)){
HXLINE( 258)								_g4 = (_g4 + 1);
HXDLIN( 258)								int i = (_g4 - 1);
HXDLIN( 258)								pC = (pC + 1);
HXDLIN( 258)								_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 258)								pC = (pC + 1);
HXDLIN( 258)								_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            							}
            						}
            					}
            				}
HXDLIN( 258)				this->x = x_;
HXDLIN( 258)				this->y = y_;
HXDLIN( 258)				int l = this->points->length;
HXDLIN( 258)				this->points[l] = ::Array_obj< Float >::__new();
HXDLIN( 258)				this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXDLIN( 258)				this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXDLIN( 258)				this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXDLIN( 258)				this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXDLIN( 258)				this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            					->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            					->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            					->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            					->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXDLIN( 258)				{
HXLINE( 258)					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 258)					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 258)						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 258)					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 258)						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 258)					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 258)						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            					}
HXDLIN( 258)					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 258)						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            					}
            				}
HXDLIN( 258)				this->contour->reset();
            			}
            			else {
HXLINE( 258)				Float x_ = arr->__get(0);
HXDLIN( 258)				Float y_ = arr->__get(1);
HXDLIN( 258)				bool repeat;
HXDLIN( 258)				if ((this->x == x_)) {
HXLINE( 258)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 258)					repeat = false;
            				}
HXDLIN( 258)				if (!(repeat)) {
HXLINE( 258)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 258)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 258)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 258)						this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            					}
HXDLIN( 258)					this->line(x_,y_);
HXDLIN( 258)					int l = this->points->length;
HXDLIN( 258)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 258)					int l2 = p->length;
HXDLIN( 258)					p[l2] = x_;
HXDLIN( 258)					p[(l2 + 1)] = y_;
HXDLIN( 258)					{
HXLINE( 258)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 258)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 258)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 258)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 258)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 258)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 258)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 258)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 258)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 258)					this->x = x_;
HXDLIN( 258)					this->y = y_;
            				}
            			}
HXDLIN( 258)			while((i < l1)){
HXLINE( 258)				{
HXLINE( 258)					Float x_ = arr->__get(i);
HXDLIN( 258)					Float y_ = arr->__get((i + 1));
HXDLIN( 258)					bool repeat;
HXDLIN( 258)					if ((this->x == x_)) {
HXLINE( 258)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 258)						repeat = false;
            					}
HXDLIN( 258)					if (!(repeat)) {
HXLINE( 258)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 258)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 258)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 258)							this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            						}
HXDLIN( 258)						this->line(x_,y_);
HXDLIN( 258)						int l = this->points->length;
HXDLIN( 258)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 258)						int l2 = p->length;
HXDLIN( 258)						p[l2] = x_;
HXDLIN( 258)						p[(l2 + 1)] = y_;
HXDLIN( 258)						{
HXLINE( 258)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 258)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 258)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 258)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 258)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 258)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 258)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 258)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 258)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 258)						this->x = x_;
HXDLIN( 258)						this->y = y_;
            					}
            				}
HXDLIN( 258)				i = (i + 2);
            			}
            		}
HXLINE( 259)		this->x = x3;
HXLINE( 260)		this->y = y3;
            	}


HX_DEFINE_DYNAMIC_FUNC6(Sketcher_obj,curveTo,(void))

void Sketcher_obj::plotCoord(::Array< Float > arr, ::Dynamic __o_withMove){
            		 ::Dynamic withMove = __o_withMove;
            		if (::hx::IsNull(__o_withMove)) withMove = true;
            	HX_STACKFRAME(&_hx_pos_0fc6eed552804d6b_263_plotCoord)
HXLINE( 264)		int l = arr->length;
HXLINE( 265)		int i = 2;
HXLINE( 266)		if (( (bool)(withMove) )) {
HXLINE( 267)			Float x_ = arr->__get(0);
HXDLIN( 267)			Float y_ = arr->__get(1);
HXDLIN( 267)			bool _hx_tmp;
HXDLIN( 267)			if ((this->endLine != 2)) {
HXLINE( 267)				_hx_tmp = (this->endLine == 3);
            			}
            			else {
HXLINE( 267)				_hx_tmp = true;
            			}
HXDLIN( 267)			if (_hx_tmp) {
HXLINE( 267)				 ::cornerContour::Contour _this = this->contour;
HXDLIN( 267)				Float width_ = this->width;
HXDLIN( 267)				_this->endEdges();
HXDLIN( 267)				if ((_this->count != 0)) {
HXLINE( 267)					Float ax = _this->bx;
HXDLIN( 267)					Float ay = _this->by;
HXDLIN( 267)					Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 267)					Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 267)					Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 267)					::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 267)					{
HXLINE( 267)						int color = 0;
HXDLIN( 267)						 ::Dynamic sides = 36;
HXDLIN( 267)						if (::hx::IsNull( sides )) {
HXLINE( 267)							sides = 36;
            						}
HXDLIN( 267)						Float pi = ::Math_obj::PI;
HXDLIN( 267)						Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 267)						Float dif;
HXDLIN( 267)						switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            							case (int)0: {
HXLINE( 267)								Float f;
HXDLIN( 267)								bool f1;
HXDLIN( 267)								if ((beta >= 0)) {
HXLINE( 267)									f1 = (beta > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f1 = false;
            								}
HXDLIN( 267)								if (f1) {
HXLINE( 267)									f = beta;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f = a;
            									}
            									else {
HXLINE( 267)										f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this1 = f;
HXDLIN( 267)								Float za = this1;
HXDLIN( 267)								Float f2;
HXDLIN( 267)								bool f3;
HXDLIN( 267)								if ((gamma >= 0)) {
HXLINE( 267)									f3 = (gamma > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f3 = false;
            								}
HXDLIN( 267)								if (f3) {
HXLINE( 267)									f2 = gamma;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f2 = a;
            									}
            									else {
HXLINE( 267)										f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this2 = f2;
HXDLIN( 267)								Float zb = this2;
HXDLIN( 267)								Float fa = za;
HXDLIN( 267)								Float fb = zb;
HXDLIN( 267)								Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 267)								bool clockwise = (fa < fb);
HXDLIN( 267)								Float dif1;
HXDLIN( 267)								if (clockwise) {
HXLINE( 267)									dif1 = theta;
            								}
            								else {
HXLINE( 267)									dif1 = -(theta);
            								}
HXDLIN( 267)								if ((dif1 > 0)) {
HXLINE( 267)									dif = dif1;
            								}
            								else {
HXLINE( 267)									dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            								}
            							}
            							break;
            							case (int)1: {
HXLINE( 267)								Float f;
HXDLIN( 267)								bool f1;
HXDLIN( 267)								if ((beta >= 0)) {
HXLINE( 267)									f1 = (beta > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f1 = false;
            								}
HXDLIN( 267)								if (f1) {
HXLINE( 267)									f = beta;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f = a;
            									}
            									else {
HXLINE( 267)										f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this1 = f;
HXDLIN( 267)								Float za = this1;
HXDLIN( 267)								Float f2;
HXDLIN( 267)								bool f3;
HXDLIN( 267)								if ((gamma >= 0)) {
HXLINE( 267)									f3 = (gamma > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f3 = false;
            								}
HXDLIN( 267)								if (f3) {
HXLINE( 267)									f2 = gamma;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f2 = a;
            									}
            									else {
HXLINE( 267)										f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this2 = f2;
HXDLIN( 267)								Float zb = this2;
HXDLIN( 267)								Float fa = za;
HXDLIN( 267)								Float fb = zb;
HXDLIN( 267)								Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 267)								bool clockwise = (fa < fb);
HXDLIN( 267)								Float dif1;
HXDLIN( 267)								if (clockwise) {
HXLINE( 267)									dif1 = theta;
            								}
            								else {
HXLINE( 267)									dif1 = -(theta);
            								}
HXDLIN( 267)								if ((dif1 < 0)) {
HXLINE( 267)									dif = dif1;
            								}
            								else {
HXLINE( 267)									dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            								}
            							}
            							break;
            							case (int)2: {
HXLINE( 267)								Float f;
HXDLIN( 267)								bool f1;
HXDLIN( 267)								if ((beta >= 0)) {
HXLINE( 267)									f1 = (beta > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f1 = false;
            								}
HXDLIN( 267)								if (f1) {
HXLINE( 267)									f = beta;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f = a;
            									}
            									else {
HXLINE( 267)										f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this1 = f;
HXDLIN( 267)								Float za = this1;
HXDLIN( 267)								Float f2;
HXDLIN( 267)								bool f3;
HXDLIN( 267)								if ((gamma >= 0)) {
HXLINE( 267)									f3 = (gamma > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f3 = false;
            								}
HXDLIN( 267)								if (f3) {
HXLINE( 267)									f2 = gamma;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f2 = a;
            									}
            									else {
HXLINE( 267)										f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this2 = f2;
HXDLIN( 267)								Float zb = this2;
HXDLIN( 267)								Float fa = za;
HXDLIN( 267)								Float fb = zb;
HXDLIN( 267)								Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 267)								bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 267)								bool clockwise = (fa < fb);
HXDLIN( 267)								Float dif1;
HXDLIN( 267)								if (clockwise) {
HXLINE( 267)									dif1 = theta;
            								}
            								else {
HXLINE( 267)									dif1 = -(theta);
            								}
HXDLIN( 267)								if (smallest) {
HXLINE( 267)									dif = dif1;
            								}
            								else {
HXLINE( 267)									if (clockwise) {
HXLINE( 267)										dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            									}
            									else {
HXLINE( 267)										dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            									}
            								}
            							}
            							break;
            							case (int)3: {
HXLINE( 267)								Float f;
HXDLIN( 267)								bool f1;
HXDLIN( 267)								if ((beta >= 0)) {
HXLINE( 267)									f1 = (beta > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f1 = false;
            								}
HXDLIN( 267)								if (f1) {
HXLINE( 267)									f = beta;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f = a;
            									}
            									else {
HXLINE( 267)										f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this1 = f;
HXDLIN( 267)								Float za = this1;
HXDLIN( 267)								Float f2;
HXDLIN( 267)								bool f3;
HXDLIN( 267)								if ((gamma >= 0)) {
HXLINE( 267)									f3 = (gamma > ::Math_obj::PI);
            								}
            								else {
HXLINE( 267)									f3 = false;
            								}
HXDLIN( 267)								if (f3) {
HXLINE( 267)									f2 = gamma;
            								}
            								else {
HXLINE( 267)									Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 267)									if ((a >= 0)) {
HXLINE( 267)										f2 = a;
            									}
            									else {
HXLINE( 267)										f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            									}
            								}
HXDLIN( 267)								Float this2 = f2;
HXDLIN( 267)								Float zb = this2;
HXDLIN( 267)								Float fa = za;
HXDLIN( 267)								Float fb = zb;
HXDLIN( 267)								Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 267)								bool largest = (theta > ::Math_obj::PI);
HXDLIN( 267)								bool clockwise = (fa < fb);
HXDLIN( 267)								Float dif1;
HXDLIN( 267)								if (clockwise) {
HXLINE( 267)									dif1 = theta;
            								}
            								else {
HXLINE( 267)									dif1 = -(theta);
            								}
HXDLIN( 267)								if (largest) {
HXLINE( 267)									dif = dif1;
            								}
            								else {
HXLINE( 267)									if (clockwise) {
HXLINE( 267)										dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            									}
            									else {
HXLINE( 267)										dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            									}
            								}
            							}
            							break;
            						}
HXDLIN( 267)						bool positive = (dif >= 0);
HXDLIN( 267)						int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 267)						Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 267)						Float angle = beta;
HXDLIN( 267)						Float cx;
HXDLIN( 267)						Float cy;
HXDLIN( 267)						Float bx = ( (Float)(0) );
HXDLIN( 267)						Float by = ( (Float)(0) );
HXDLIN( 267)						int p2 = temp->length;
HXDLIN( 267)						{
HXLINE( 267)							int _g = 0;
HXDLIN( 267)							int _g1 = (totalSteps + 1);
HXDLIN( 267)							while((_g < _g1)){
HXLINE( 267)								_g = (_g + 1);
HXDLIN( 267)								int i = (_g - 1);
HXDLIN( 267)								cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 267)								cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 267)								p2 = (p2 + 1);
HXDLIN( 267)								temp[(p2 - 1)] = cx;
HXDLIN( 267)								p2 = (p2 + 1);
HXDLIN( 267)								temp[(p2 - 1)] = cy;
HXDLIN( 267)								if ((i != 0)) {
HXLINE( 267)									::cornerContour::IPen_obj::triangle2DFill(_this->pen,ax,ay,bx,by,cx,cy,color);
            								}
HXDLIN( 267)								angle = (angle + step1);
HXDLIN( 267)								bx = cx;
HXDLIN( 267)								by = cy;
            							}
            						}
            					}
HXDLIN( 267)					int pA = _this->pointsAnti->length;
HXDLIN( 267)					int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 267)					{
HXLINE( 267)						int _g2 = 0;
HXDLIN( 267)						int _g3 = (len + 2);
HXDLIN( 267)						while((_g2 < _g3)){
HXLINE( 267)							_g2 = (_g2 + 1);
HXDLIN( 267)							int i = (_g2 - 1);
HXDLIN( 267)							pA = (pA + 1);
HXDLIN( 267)							_this->pointsAnti[(pA - 1)] = temp->__get(i);
            						}
            					}
HXDLIN( 267)					int pC = _this->pointsClock->length;
HXDLIN( 267)					{
HXLINE( 267)						int _g4 = 1;
HXDLIN( 267)						int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 267)						while((_g4 < _g5)){
HXLINE( 267)							_g4 = (_g4 + 1);
HXDLIN( 267)							int i = (_g4 - 1);
HXDLIN( 267)							pC = (pC + 1);
HXDLIN( 267)							_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 267)							pC = (pC + 1);
HXDLIN( 267)							_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            						}
            					}
            				}
            			}
HXDLIN( 267)			this->x = x_;
HXDLIN( 267)			this->y = y_;
HXDLIN( 267)			int l = this->points->length;
HXDLIN( 267)			this->points[l] = ::Array_obj< Float >::__new();
HXDLIN( 267)			this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXDLIN( 267)			this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXDLIN( 267)			this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXDLIN( 267)			this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXDLIN( 267)			this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            				->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            				->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            				->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXDLIN( 267)			{
HXLINE( 267)				 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 267)				if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 267)					d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 267)				if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 267)					d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 267)				if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 267)					d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            				}
HXDLIN( 267)				if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 267)					d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            				}
            			}
HXDLIN( 267)			this->contour->reset();
            		}
            		else {
HXLINE( 269)			Float x_ = arr->__get(0);
HXDLIN( 269)			Float y_ = arr->__get(1);
HXDLIN( 269)			bool repeat;
HXDLIN( 269)			if ((this->x == x_)) {
HXLINE( 269)				repeat = (this->y == y_);
            			}
            			else {
HXLINE( 269)				repeat = false;
            			}
HXDLIN( 269)			if (!(repeat)) {
HXLINE( 269)				if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 269)					this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            				}
HXDLIN( 269)				if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 269)					this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            				}
HXDLIN( 269)				this->line(x_,y_);
HXDLIN( 269)				int l = this->points->length;
HXDLIN( 269)				::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 269)				int l2 = p->length;
HXDLIN( 269)				p[l2] = x_;
HXDLIN( 269)				p[(l2 + 1)] = y_;
HXDLIN( 269)				{
HXLINE( 269)					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 269)					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 269)						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 269)					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 269)						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 269)					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 269)						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            					}
HXDLIN( 269)					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 269)						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            					}
            				}
HXDLIN( 269)				this->x = x_;
HXDLIN( 269)				this->y = y_;
            			}
            		}
HXLINE( 271)		while((i < l)){
HXLINE( 272)			{
HXLINE( 272)				Float x_ = arr->__get(i);
HXDLIN( 272)				Float y_ = arr->__get((i + 1));
HXDLIN( 272)				bool repeat;
HXDLIN( 272)				if ((this->x == x_)) {
HXLINE( 272)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 272)					repeat = false;
            				}
HXDLIN( 272)				if (!(repeat)) {
HXLINE( 272)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 272)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 272)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 272)						this->pen->__SetField(HX_("currentColor",6a,56,68,91),this->colourFunction( ::Dynamic(this->pen->__Field(HX_("currentColor",6a,56,68,91),::hx::paccDynamic)),this->x,this->y,x_,y_),::hx::paccDynamic);
            					}
HXDLIN( 272)					this->line(x_,y_);
HXDLIN( 272)					int l = this->points->length;
HXDLIN( 272)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 272)					int l2 = p->length;
HXDLIN( 272)					p[l2] = x_;
HXDLIN( 272)					p[(l2 + 1)] = y_;
HXDLIN( 272)					{
HXLINE( 272)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 272)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 272)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 272)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 272)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 272)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 272)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 272)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 272)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 272)					this->x = x_;
HXDLIN( 272)					this->y = y_;
            				}
            			}
HXLINE( 273)			i = (i + 2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketcher_obj,plotCoord,(void))


::hx::ObjectPtr< Sketcher_obj > Sketcher_obj::__new(::Dynamic pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Sketcher_obj > __this = new Sketcher_obj();
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Sketcher_obj > Sketcher_obj::__alloc(::hx::Ctx *_hx_ctx,::Dynamic pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	Sketcher_obj *__this = (Sketcher_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sketcher_obj), true, "cornerContour.Sketcher"));
	*(void **)__this = Sketcher_obj::_hx_vtable;
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

Sketcher_obj::Sketcher_obj()
{
}

void Sketcher_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Sketcher);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(widthFunction,"widthFunction");
	HX_MARK_MEMBER_NAME(colourFunction,"colourFunction");
	HX_MARK_MEMBER_NAME(tempArr,"tempArr");
	HX_MARK_MEMBER_NAME(contour,"contour");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(sketchForm,"sketchForm");
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(line,"line");
	HX_MARK_END_CLASS();
}

void Sketcher_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(widthFunction,"widthFunction");
	HX_VISIT_MEMBER_NAME(colourFunction,"colourFunction");
	HX_VISIT_MEMBER_NAME(tempArr,"tempArr");
	HX_VISIT_MEMBER_NAME(contour,"contour");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(sketchForm,"sketchForm");
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(line,"line");
}

::hx::Val Sketcher_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"dim") ) { return ::hx::Val( dim ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"lineTo") ) { return ::hx::Val( lineTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadTo") ) { return ::hx::Val( quadTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { return ::hx::Val( tempArr ); }
		if (HX_FIELD_EQ(inName,"contour") ) { return ::hx::Val( contour ); }
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		if (HX_FIELD_EQ(inName,"initDim") ) { return ::hx::Val( initDim_dyn() ); }
		if (HX_FIELD_EQ(inName,"curveTo") ) { return ::hx::Val( curveTo_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"baseLine") ) { return ::hx::Val( baseLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"fineLine") ) { return ::hx::Val( fineLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"getEdges") ) { return ::hx::Val( getEdges_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadThru") ) { return ::hx::Val( quadThru_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"crudeLine") ) { return ::hx::Val( crudeLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateDim") ) { return ::hx::Val( updateDim_dyn() ); }
		if (HX_FIELD_EQ(inName,"lastClock") ) { return ::hx::Val( lastClock_dyn() ); }
		if (HX_FIELD_EQ(inName,"plotCoord") ) { return ::hx::Val( plotCoord_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { return ::hx::Val( sketchForm ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"tracerLine") ) { return ::hx::Val( tracerLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"mediumLine") ) { return ::hx::Val( mediumLine_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillOnlyLine") ) { return ::hx::Val( fillOnlyLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"roundEndLine") ) { return ::hx::Val( roundEndLine_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { return ::hx::Val( widthFunction ); }
		if (HX_FIELD_EQ(inName,"pointsRewound") ) { return ::hx::Val( pointsRewound_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { return ::hx::Val( colourFunction ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fineOverlapLine") ) { return ::hx::Val( fineOverlapLine_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"mediumOverlapLine") ) { return ::hx::Val( mediumOverlapLine_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"pointsNoEndOverlap") ) { return ::hx::Val( pointsNoEndOverlap_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Sketcher_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast< ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { line=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { tempArr=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"contour") ) { contour=inValue.Cast<  ::cornerContour::Contour >(); return inValue; }
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { sketchForm=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { widthFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { colourFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sketcher_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("tempArr",ad,17,ac,46));
	outFields->push(HX_("contour",da,29,7f,19));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("sketchForm",d0,2c,96,9a));
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("dim",48,3d,4c,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sketcher_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Sketcher_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketcher_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketcher_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketcher_obj,widthFunction),HX_("widthFunction",3e,93,b5,7c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketcher_obj,colourFunction),HX_("colourFunction",84,5b,3e,e4)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Sketcher_obj,tempArr),HX_("tempArr",ad,17,ac,46)},
	{::hx::fsObject /*  ::cornerContour::Contour */ ,(int)offsetof(Sketcher_obj,contour),HX_("contour",da,29,7f,19)},
	{::hx::fsObject /* ::Dynamic */ ,(int)offsetof(Sketcher_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Sketcher_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsInt,(int)offsetof(Sketcher_obj,sketchForm),HX_("sketchForm",d0,2c,96,9a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketcher_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketcher_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketcher_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketcher_obj,dim),HX_("dim",48,3d,4c,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketcher_obj,line),HX_("line",f4,17,b3,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sketcher_obj_sStaticStorageInfo = 0;
#endif

static ::String Sketcher_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("width",06,b6,62,ca),
	HX_("widthFunction",3e,93,b5,7c),
	HX_("colourFunction",84,5b,3e,e4),
	HX_("tempArr",ad,17,ac,46),
	HX_("contour",da,29,7f,19),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("sketchForm",d0,2c,96,9a),
	HX_("points",23,12,2e,f7),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("dim",48,3d,4c,00),
	HX_("tracerLine",e1,14,6f,0a),
	HX_("fillOnlyLine",23,35,20,bc),
	HX_("baseLine",a5,08,01,fc),
	HX_("crudeLine",7b,a3,d6,62),
	HX_("roundEndLine",c1,c6,50,fc),
	HX_("mediumLine",09,77,f0,3b),
	HX_("mediumOverlapLine",a6,34,72,5e),
	HX_("fineLine",4e,b9,ad,2d),
	HX_("fineOverlapLine",01,f5,59,3a),
	HX_("line",f4,17,b3,47),
	HX_("reset",cf,49,c8,e6),
	HX_("pointsNoEndOverlap",50,8f,f9,44),
	HX_("pointsRewound",5d,22,d0,4a),
	HX_("initDim",18,04,83,cb),
	HX_("updateDim",bf,1a,d9,82),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("lastClock",98,37,10,95),
	HX_("getEdges",20,7d,b7,c9),
	HX_("lineTo",8f,46,a0,ec),
	HX_("quadTo",22,82,9f,cc),
	HX_("quadThru",9e,e2,18,d5),
	HX_("curveTo",0a,60,88,ce),
	HX_("plotCoord",d4,98,a6,b1),
	::String(null()) };

::hx::Class Sketcher_obj::__mClass;

void Sketcher_obj::__register()
{
	Sketcher_obj _hx_dummy;
	Sketcher_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("cornerContour.Sketcher",02,40,bc,91);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sketcher_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sketcher_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sketcher_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sketcher_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace cornerContour
