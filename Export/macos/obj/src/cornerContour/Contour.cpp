// Generated by Haxe 4.3.0-rc.1+5f599ba
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_cornerContour_Contour
#include <cornerContour/Contour.h>
#endif
#ifndef INCLUDED_cornerContour_IPen
#include <cornerContour/IPen.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a86754e404cc2b8f_11_new,"cornerContour.Contour","new",0x4dba2443,"cornerContour.Contour.new","cornerContour/Contour.hx",11,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_85_reset,"cornerContour.Contour","reset",0x19559c72,"cornerContour.Contour.reset","cornerContour/Contour.hx",85,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_124_computeDE,"cornerContour.Contour","computeDE",0x3aa16edb,"cornerContour.Contour.computeDE","cornerContour/Contour.hx",124,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_140_anglesCompute,"cornerContour.Contour","anglesCompute",0x8daeafba,"cornerContour.Contour.anglesCompute","cornerContour/Contour.hx",140,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_162_thetaComputeAdj,"cornerContour.Contour","thetaComputeAdj",0xf8635d11,"cornerContour.Contour.thetaComputeAdj","cornerContour/Contour.hx",162,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_178_triangleJoin,"cornerContour.Contour","triangleJoin",0x4c9eba8f,"cornerContour.Contour.triangleJoin","cornerContour/Contour.hx",178,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_260_overlapQuad,"cornerContour.Contour","overlapQuad",0xaf6ae6d1,"cornerContour.Contour.overlapQuad","cornerContour/Contour.hx",260,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_268_end,"cornerContour.Contour","end",0x4db357be,"cornerContour.Contour.end","cornerContour/Contour.hx",268,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_274_triangle2DFill,"cornerContour.Contour","triangle2DFill",0x4bbc3d3a,"cornerContour.Contour.triangle2DFill","cornerContour/Contour.hx",274,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_277_addPieXstart,"cornerContour.Contour","addPieXstart",0x56cd87b2,"cornerContour.Contour.addPieXstart","cornerContour/Contour.hx",277,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_295_addPieX,"cornerContour.Contour","addPieX",0x7516aeb0,"cornerContour.Contour.addPieX","cornerContour/Contour.hx",295,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_312_addPie,"cornerContour.Contour","addPie",0xa82164a8,"cornerContour.Contour.addPie","cornerContour/Contour.hx",312,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_315_computeJ,"cornerContour.Contour","computeJ",0x4895f630,"cornerContour.Contour.computeJ","cornerContour/Contour.hx",315,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_325_addDot,"cornerContour.Contour","addDot",0xa8184ee5,"cornerContour.Contour.addDot","cornerContour/Contour.hx",325,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_349_addSmallTriangles,"cornerContour.Contour","addSmallTriangles",0x5c512808,"cornerContour.Contour.addSmallTriangles","cornerContour/Contour.hx",349,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_360_triangle2DFillangleCorners,"cornerContour.Contour","triangle2DFillangleCorners",0x077c1ba5,"cornerContour.Contour.triangle2DFillangleCorners","cornerContour/Contour.hx",360,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_368_triangle2DFillangleCornersLess,"cornerContour.Contour","triangle2DFillangleCornersLess",0x7acc919e,"cornerContour.Contour.triangle2DFillangleCornersLess","cornerContour/Contour.hx",368,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_377_connectQuadsWhenQuadsOverlay,"cornerContour.Contour","connectQuadsWhenQuadsOverlay",0xab0a045d,"cornerContour.Contour.connectQuadsWhenQuadsOverlay","cornerContour/Contour.hx",377,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_392_connectQuads,"cornerContour.Contour","connectQuads",0x0620d13f,"cornerContour.Contour.connectQuads","cornerContour/Contour.hx",392,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_407_addInitialQuads,"cornerContour.Contour","addInitialQuads",0xb90cfecc,"cornerContour.Contour.addInitialQuads","cornerContour/Contour.hx",407,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_490_endEdges,"cornerContour.Contour","endEdges",0x2aadb4f8,"cornerContour.Contour.endEdges","cornerContour/Contour.hx",490,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_516_addQuads,"cornerContour.Contour","addQuads",0x9a145128,"cornerContour.Contour.addQuads","cornerContour/Contour.hx",516,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_682_storeLastQuads,"cornerContour.Contour","storeLastQuads",0xfb8d2c72,"cornerContour.Contour.storeLastQuads","cornerContour/Contour.hx",682,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_693_isClockwise,"cornerContour.Contour","isClockwise",0x8fa1a38b,"cornerContour.Contour.isClockwise","cornerContour/Contour.hx",693,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_697_line,"cornerContour.Contour","line",0xb3d62ab1,"cornerContour.Contour.line","cornerContour/Contour.hx",697,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_738_circle,"cornerContour.Contour","circle",0x5f286e0d,"cornerContour.Contour.circle","cornerContour/Contour.hx",738,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_765_pie,"cornerContour.Contour","pie",0x4dbbac2f,"cornerContour.Contour.pie","cornerContour/Contour.hx",765,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_801_pieX,"cornerContour.Contour","pieX",0xb67afd49,"cornerContour.Contour.pieX","cornerContour/Contour.hx",801,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_835_pieDifX,"cornerContour.Contour","pieDifX",0x701977c6,"cornerContour.Contour.pieDifX","cornerContour/Contour.hx",835,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_166_thetaCompute,"cornerContour.Contour","thetaCompute",0x118462b6,"cornerContour.Contour.thetaCompute","cornerContour/Contour.hx",166,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_169_dist,"cornerContour.Contour","dist",0xae8c7a23,"cornerContour.Contour.dist","cornerContour/Contour.hx",169,0xc4f2bfce)
HX_LOCAL_STACK_FRAME(_hx_pos_a86754e404cc2b8f_83_boot,"cornerContour.Contour","boot",0xad3e96ef,"cornerContour.Contour.boot","cornerContour/Contour.hx",83,0xc4f2bfce)
namespace cornerContour{

void Contour_obj::__construct(::Dynamic pen_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_11_new)
HXLINE( 513)		this->counter = 0;
HXLINE( 117)		this->count = 0;
HXLINE(  26)		this->pointsAnti = ::Array_obj< Float >::__new(0);
HXLINE(  25)		this->pointsClock = ::Array_obj< Float >::__new(0);
HXLINE(  24)		this->debugCol12 = -893376;
HXLINE(  23)		this->debugCol11 = -3986796;
HXLINE(  22)		this->debugCol10 = -9230154;
HXLINE(  21)		this->debugCol9 = -13354819;
HXLINE(  20)		this->debugCol8 = -12617788;
HXLINE(  19)		this->debugCol7 = -11686193;
HXLINE(  18)		this->debugCol6 = -11288539;
HXLINE(  17)		this->debugCol5 = -5778134;
HXLINE(  16)		this->debugCol4 = -211;
HXLINE(  15)		this->debugCol3 = -338891;
HXLINE(  14)		this->debugCol2 = -742865;
HXLINE(  13)		this->debugCol1 = -884166;
HXLINE(  12)		this->debugCol0 = -1098686;
HXLINE( 119)		this->pen = pen_;
HXLINE( 120)		this->endLine = endLine_;
            	}

Dynamic Contour_obj::__CreateEmpty() { return new Contour_obj; }

void *Contour_obj::_hx_vtable = 0;

Dynamic Contour_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Contour_obj > _hx_result = new Contour_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Contour_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x077dda95;
}

void Contour_obj::reset(){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_85_reset)
HXLINE(  86)		this->angleA = ( (Float)(0) );
HXLINE(  87)		this->count = 0;
HXLINE(  88)		this->kax = ( (Float)(0) );
HXLINE(  89)		this->kay = ( (Float)(0) );
HXLINE(  90)		this->kbx = ( (Float)(0) );
HXLINE(  91)		this->kby = ( (Float)(0) );
HXLINE(  92)		this->kcx = ( (Float)(0) );
HXLINE(  93)		this->kcy = ( (Float)(0) );
HXLINE(  94)		this->ncx = ( (Float)(0) );
HXLINE(  95)		this->ncy = ( (Float)(0) );
HXLINE(  96)		this->ax = ( (Float)(0) );
HXLINE(  97)		this->ay = ( (Float)(0) );
HXLINE(  98)		this->bx = ( (Float)(0) );
HXLINE(  99)		this->by = ( (Float)(0) );
HXLINE( 100)		this->cx = ( (Float)(0) );
HXLINE( 101)		this->cy = ( (Float)(0) );
HXLINE( 103)		this->dx = null();
HXLINE( 104)		this->dy = null();
HXLINE( 105)		this->ex = null();
HXLINE( 106)		this->ey = null();
HXLINE( 112)		this->pointsClock->resize(0);
HXLINE( 113)		this->pointsAnti->resize(0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,reset,(void))

void Contour_obj::computeDE(){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_124_computeDE)
HXLINE( 125)		{
HXLINE( 125)			this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 125)			if ((this->theta > 0)) {
HXLINE( 125)				if ((this->halfA < 0)) {
HXLINE( 125)					this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 125)					this->angle1 = (this->theta - this->halfA);
            				}
            				else {
HXLINE( 125)					this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 125)					this->angle2 = (this->theta + this->halfA);
            				}
            			}
            			else {
HXLINE( 125)				if ((this->halfA > 0)) {
HXLINE( 125)					this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 125)					this->angle2 = (this->theta + this->halfA);
            				}
            				else {
HXLINE( 125)					this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 125)					this->angle1 = (this->theta - this->halfA);
            				}
            			}
            		}
HXLINE( 126)		if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 126)			this->dxOld = this->dxPrev;
            		}
HXLINE( 127)		if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 127)			this->dyOld = this->dyPrev;
            		}
HXLINE( 128)		if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 128)			this->exOld = this->exPrev;
            		}
HXLINE( 129)		if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 129)			this->eyOld = this->eyPrev;
            		}
HXLINE( 130)		if (::hx::IsNotNull( this->dx )) {
HXLINE( 130)			this->dxPrev = this->dx;
            		}
HXLINE( 131)		if (::hx::IsNotNull( this->dy )) {
HXLINE( 131)			this->dyPrev = this->dy;
            		}
HXLINE( 132)		if (::hx::IsNotNull( this->ex )) {
HXLINE( 132)			this->exPrev = this->ex;
            		}
HXLINE( 133)		if (::hx::IsNotNull( this->ey )) {
HXLINE( 133)			this->eyPrev = this->ey;
            		}
HXLINE( 134)		this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXLINE( 135)		this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXLINE( 136)		this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXLINE( 137)		this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,computeDE,(void))

void Contour_obj::anglesCompute(){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_140_anglesCompute)
HXLINE( 141)		this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXLINE( 142)		if ((this->theta > 0)) {
HXLINE( 143)			if ((this->halfA < 0)) {
HXLINE( 144)				this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 145)				this->angle1 = (this->theta - this->halfA);
            			}
            			else {
HXLINE( 147)				this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXLINE( 148)				this->angle2 = (this->theta + this->halfA);
            			}
            		}
            		else {
HXLINE( 151)			if ((this->halfA > 0)) {
HXLINE( 152)				this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXLINE( 153)				this->angle2 = (this->theta + this->halfA);
            			}
            			else {
HXLINE( 155)				this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 156)				this->angle1 = (this->theta - this->halfA);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,anglesCompute,(void))

Float Contour_obj::thetaComputeAdj(Float qx,Float qy){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_162_thetaComputeAdj)
HXDLIN( 162)		return (-(::Math_obj::atan2((this->ay - qy),(this->ax - qx))) - (::Math_obj::PI / ( (Float)(2) )));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,thetaComputeAdj,return )

void Contour_obj::triangleJoin(Float ax_,Float ay_,Float bx_,Float by_,Float width_,::hx::Null< bool >  __o_curveEnds,::hx::Null< bool >  __o_overlap){
            		bool curveEnds = __o_curveEnds.Default(false);
            		bool overlap = __o_overlap.Default(false);
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_178_triangleJoin)
HXLINE( 179)		 ::Dynamic oldAngle;
HXDLIN( 179)		if (::hx::IsNotNull( this->dx )) {
HXLINE( 179)			oldAngle = this->angle1;
            		}
            		else {
HXLINE( 179)			oldAngle = null();
            		}
HXLINE( 180)		this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXLINE( 185)		this->ax = bx_;
HXLINE( 186)		this->ay = by_;
HXLINE( 187)		this->bx = ax_;
HXLINE( 188)		this->by = ay_;
HXLINE( 189)		this->beta = ((::Math_obj::PI / ( (Float)(2) )) - this->halfA);
HXLINE( 190)		this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(this->beta));
HXLINE( 191)		{
HXLINE( 191)			{
HXLINE( 191)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 191)				if ((this->theta > 0)) {
HXLINE( 191)					if ((this->halfA < 0)) {
HXLINE( 191)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 191)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 191)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 191)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 191)					if ((this->halfA > 0)) {
HXLINE( 191)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 191)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 191)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 191)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 191)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 191)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 191)				this->exOld = this->exPrev;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 191)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 191)				this->dxPrev = this->dx;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 191)				this->dyPrev = this->dy;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 191)				this->exPrev = this->ex;
            			}
HXDLIN( 191)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 191)				this->eyPrev = this->ey;
            			}
HXDLIN( 191)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 191)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 191)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 191)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 194)		this->ax = ax_;
HXLINE( 195)		this->ay = ay_;
HXLINE( 196)		this->bx = bx_;
HXLINE( 197)		this->by = by_;
HXLINE( 198)		{
HXLINE( 198)			{
HXLINE( 198)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 198)				if ((this->theta > 0)) {
HXLINE( 198)					if ((this->halfA < 0)) {
HXLINE( 198)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 198)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 198)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 198)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 198)					if ((this->halfA > 0)) {
HXLINE( 198)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 198)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 198)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 198)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 198)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 198)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 198)				this->exOld = this->exPrev;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 198)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 198)				this->dxPrev = this->dx;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 198)				this->dyPrev = this->dy;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 198)				this->exPrev = this->ex;
            			}
HXDLIN( 198)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 198)				this->eyPrev = this->ey;
            			}
HXDLIN( 198)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 198)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 198)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 198)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 200)		Float x = (( (Float)(this->dxOld) ) - bx_);
HXDLIN( 200)		Float y = (( (Float)(this->dyOld) ) - by_);
HXDLIN( 200)		Float x1 = (( (Float)(this->exOld) ) - bx_);
HXDLIN( 200)		Float y1 = (( (Float)(this->eyOld) ) - by_);
HXDLIN( 200)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXLINE( 201)		Float theta0;
HXLINE( 202)		Float theta1;
HXLINE( 203)		if (clockWise) {
HXLINE( 204)			theta0 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->dyOld) )),(this->ax - ( (Float)(this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 205)			theta1 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->eyPrev) )),(this->ax - ( (Float)(this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXLINE( 207)			theta0 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->eyOld) )),(this->ax - ( (Float)(this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 208)			theta1 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->dyPrev) )),(this->ax - ( (Float)(this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXLINE( 210)		Float dif;
HXDLIN( 210)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 210)				Float f;
HXDLIN( 210)				bool f1;
HXDLIN( 210)				if ((theta0 >= 0)) {
HXLINE( 210)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f1 = false;
            				}
HXDLIN( 210)				if (f1) {
HXLINE( 210)					f = theta0;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f = a;
            					}
            					else {
HXLINE( 210)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this1 = f;
HXDLIN( 210)				Float za = this1;
HXDLIN( 210)				Float f2;
HXDLIN( 210)				bool f3;
HXDLIN( 210)				if ((theta1 >= 0)) {
HXLINE( 210)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f3 = false;
            				}
HXDLIN( 210)				if (f3) {
HXLINE( 210)					f2 = theta1;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f2 = a;
            					}
            					else {
HXLINE( 210)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this2 = f2;
HXDLIN( 210)				Float zb = this2;
HXDLIN( 210)				Float fa = za;
HXDLIN( 210)				Float fb = zb;
HXDLIN( 210)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 210)				bool clockwise = (fa < fb);
HXDLIN( 210)				Float dif1;
HXDLIN( 210)				if (clockwise) {
HXLINE( 210)					dif1 = theta;
            				}
            				else {
HXLINE( 210)					dif1 = -(theta);
            				}
HXDLIN( 210)				if ((dif1 > 0)) {
HXLINE( 210)					dif = dif1;
            				}
            				else {
HXLINE( 210)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 210)				Float f;
HXDLIN( 210)				bool f1;
HXDLIN( 210)				if ((theta0 >= 0)) {
HXLINE( 210)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f1 = false;
            				}
HXDLIN( 210)				if (f1) {
HXLINE( 210)					f = theta0;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f = a;
            					}
            					else {
HXLINE( 210)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this1 = f;
HXDLIN( 210)				Float za = this1;
HXDLIN( 210)				Float f2;
HXDLIN( 210)				bool f3;
HXDLIN( 210)				if ((theta1 >= 0)) {
HXLINE( 210)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f3 = false;
            				}
HXDLIN( 210)				if (f3) {
HXLINE( 210)					f2 = theta1;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f2 = a;
            					}
            					else {
HXLINE( 210)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this2 = f2;
HXDLIN( 210)				Float zb = this2;
HXDLIN( 210)				Float fa = za;
HXDLIN( 210)				Float fb = zb;
HXDLIN( 210)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 210)				bool clockwise = (fa < fb);
HXDLIN( 210)				Float dif1;
HXDLIN( 210)				if (clockwise) {
HXLINE( 210)					dif1 = theta;
            				}
            				else {
HXLINE( 210)					dif1 = -(theta);
            				}
HXDLIN( 210)				if ((dif1 < 0)) {
HXLINE( 210)					dif = dif1;
            				}
            				else {
HXLINE( 210)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 210)				Float f;
HXDLIN( 210)				bool f1;
HXDLIN( 210)				if ((theta0 >= 0)) {
HXLINE( 210)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f1 = false;
            				}
HXDLIN( 210)				if (f1) {
HXLINE( 210)					f = theta0;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f = a;
            					}
            					else {
HXLINE( 210)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this1 = f;
HXDLIN( 210)				Float za = this1;
HXDLIN( 210)				Float f2;
HXDLIN( 210)				bool f3;
HXDLIN( 210)				if ((theta1 >= 0)) {
HXLINE( 210)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f3 = false;
            				}
HXDLIN( 210)				if (f3) {
HXLINE( 210)					f2 = theta1;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f2 = a;
            					}
            					else {
HXLINE( 210)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this2 = f2;
HXDLIN( 210)				Float zb = this2;
HXDLIN( 210)				Float fa = za;
HXDLIN( 210)				Float fb = zb;
HXDLIN( 210)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 210)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 210)				bool clockwise = (fa < fb);
HXDLIN( 210)				Float dif1;
HXDLIN( 210)				if (clockwise) {
HXLINE( 210)					dif1 = theta;
            				}
            				else {
HXLINE( 210)					dif1 = -(theta);
            				}
HXDLIN( 210)				if (smallest) {
HXLINE( 210)					dif = dif1;
            				}
            				else {
HXLINE( 210)					if (clockwise) {
HXLINE( 210)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 210)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 210)				Float f;
HXDLIN( 210)				bool f1;
HXDLIN( 210)				if ((theta0 >= 0)) {
HXLINE( 210)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f1 = false;
            				}
HXDLIN( 210)				if (f1) {
HXLINE( 210)					f = theta0;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f = a;
            					}
            					else {
HXLINE( 210)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this1 = f;
HXDLIN( 210)				Float za = this1;
HXDLIN( 210)				Float f2;
HXDLIN( 210)				bool f3;
HXDLIN( 210)				if ((theta1 >= 0)) {
HXLINE( 210)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 210)					f3 = false;
            				}
HXDLIN( 210)				if (f3) {
HXLINE( 210)					f2 = theta1;
            				}
            				else {
HXLINE( 210)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 210)					if ((a >= 0)) {
HXLINE( 210)						f2 = a;
            					}
            					else {
HXLINE( 210)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 210)				Float this2 = f2;
HXDLIN( 210)				Float zb = this2;
HXDLIN( 210)				Float fa = za;
HXDLIN( 210)				Float fb = zb;
HXDLIN( 210)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 210)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 210)				bool clockwise = (fa < fb);
HXDLIN( 210)				Float dif1;
HXDLIN( 210)				if (clockwise) {
HXLINE( 210)					dif1 = theta;
            				}
            				else {
HXLINE( 210)					dif1 = -(theta);
            				}
HXDLIN( 210)				if (largest) {
HXLINE( 210)					dif = dif1;
            				}
            				else {
HXLINE( 210)					if (clockwise) {
HXLINE( 210)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 210)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 211)		bool _hx_tmp;
HXDLIN( 211)		if (!(overlap)) {
HXLINE( 211)			_hx_tmp = (this->count != 0);
            		}
            		else {
HXLINE( 211)			_hx_tmp = false;
            		}
HXDLIN( 211)		if (_hx_tmp) {
HXLINE( 211)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN( 211)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN( 211)			Float f;
HXDLIN( 211)			bool f1;
HXDLIN( 211)			if ((theta0 <= ::Math_obj::PI)) {
HXLINE( 211)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXLINE( 211)				f1 = false;
            			}
HXDLIN( 211)			if (f1) {
HXLINE( 211)				f = theta0;
            			}
            			else {
HXLINE( 211)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 211)				if ((a >= 0)) {
HXLINE( 211)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXLINE( 211)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN( 211)			Float this1 = f;
HXDLIN( 211)			Float start = this1;
HXDLIN( 211)			Float start2 = start;
HXDLIN( 211)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 211)			this->jx = (this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN( 211)			this->jy = (this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXLINE( 213)		bool _hx_tmp1;
HXDLIN( 213)		if ((this->count == 0)) {
HXLINE( 213)			if ((this->endLine != 1)) {
HXLINE( 213)				_hx_tmp1 = (this->endLine == 3);
            			}
            			else {
HXLINE( 213)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 213)			_hx_tmp1 = false;
            		}
HXDLIN( 213)		if (_hx_tmp1) {
HXLINE( 213)			Float ax = this->ax;
HXDLIN( 213)			Float ay = this->ay;
HXDLIN( 213)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 213)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 213)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 213)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 213)			{
HXLINE( 213)				int color = -1;
HXDLIN( 213)				 ::Dynamic sides = 36;
HXDLIN( 213)				if (::hx::IsNull( sides )) {
HXLINE( 213)					sides = 36;
            				}
HXDLIN( 213)				Float pi = ::Math_obj::PI;
HXDLIN( 213)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 213)				Float dif;
HXDLIN( 213)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 213)						Float f;
HXDLIN( 213)						bool f1;
HXDLIN( 213)						if ((beta >= 0)) {
HXLINE( 213)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f1 = false;
            						}
HXDLIN( 213)						if (f1) {
HXLINE( 213)							f = beta;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f = a;
            							}
            							else {
HXLINE( 213)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this1 = f;
HXDLIN( 213)						Float za = this1;
HXDLIN( 213)						Float f2;
HXDLIN( 213)						bool f3;
HXDLIN( 213)						if ((gamma >= 0)) {
HXLINE( 213)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f3 = false;
            						}
HXDLIN( 213)						if (f3) {
HXLINE( 213)							f2 = gamma;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f2 = a;
            							}
            							else {
HXLINE( 213)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this2 = f2;
HXDLIN( 213)						Float zb = this2;
HXDLIN( 213)						Float fa = za;
HXDLIN( 213)						Float fb = zb;
HXDLIN( 213)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 213)						bool clockwise = (fa < fb);
HXDLIN( 213)						Float dif1;
HXDLIN( 213)						if (clockwise) {
HXLINE( 213)							dif1 = theta;
            						}
            						else {
HXLINE( 213)							dif1 = -(theta);
            						}
HXDLIN( 213)						if ((dif1 > 0)) {
HXLINE( 213)							dif = dif1;
            						}
            						else {
HXLINE( 213)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 213)						Float f;
HXDLIN( 213)						bool f1;
HXDLIN( 213)						if ((beta >= 0)) {
HXLINE( 213)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f1 = false;
            						}
HXDLIN( 213)						if (f1) {
HXLINE( 213)							f = beta;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f = a;
            							}
            							else {
HXLINE( 213)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this1 = f;
HXDLIN( 213)						Float za = this1;
HXDLIN( 213)						Float f2;
HXDLIN( 213)						bool f3;
HXDLIN( 213)						if ((gamma >= 0)) {
HXLINE( 213)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f3 = false;
            						}
HXDLIN( 213)						if (f3) {
HXLINE( 213)							f2 = gamma;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f2 = a;
            							}
            							else {
HXLINE( 213)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this2 = f2;
HXDLIN( 213)						Float zb = this2;
HXDLIN( 213)						Float fa = za;
HXDLIN( 213)						Float fb = zb;
HXDLIN( 213)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 213)						bool clockwise = (fa < fb);
HXDLIN( 213)						Float dif1;
HXDLIN( 213)						if (clockwise) {
HXLINE( 213)							dif1 = theta;
            						}
            						else {
HXLINE( 213)							dif1 = -(theta);
            						}
HXDLIN( 213)						if ((dif1 < 0)) {
HXLINE( 213)							dif = dif1;
            						}
            						else {
HXLINE( 213)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 213)						Float f;
HXDLIN( 213)						bool f1;
HXDLIN( 213)						if ((beta >= 0)) {
HXLINE( 213)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f1 = false;
            						}
HXDLIN( 213)						if (f1) {
HXLINE( 213)							f = beta;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f = a;
            							}
            							else {
HXLINE( 213)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this1 = f;
HXDLIN( 213)						Float za = this1;
HXDLIN( 213)						Float f2;
HXDLIN( 213)						bool f3;
HXDLIN( 213)						if ((gamma >= 0)) {
HXLINE( 213)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f3 = false;
            						}
HXDLIN( 213)						if (f3) {
HXLINE( 213)							f2 = gamma;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f2 = a;
            							}
            							else {
HXLINE( 213)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this2 = f2;
HXDLIN( 213)						Float zb = this2;
HXDLIN( 213)						Float fa = za;
HXDLIN( 213)						Float fb = zb;
HXDLIN( 213)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 213)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 213)						bool clockwise = (fa < fb);
HXDLIN( 213)						Float dif1;
HXDLIN( 213)						if (clockwise) {
HXLINE( 213)							dif1 = theta;
            						}
            						else {
HXLINE( 213)							dif1 = -(theta);
            						}
HXDLIN( 213)						if (smallest) {
HXLINE( 213)							dif = dif1;
            						}
            						else {
HXLINE( 213)							if (clockwise) {
HXLINE( 213)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 213)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 213)						Float f;
HXDLIN( 213)						bool f1;
HXDLIN( 213)						if ((beta >= 0)) {
HXLINE( 213)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f1 = false;
            						}
HXDLIN( 213)						if (f1) {
HXLINE( 213)							f = beta;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f = a;
            							}
            							else {
HXLINE( 213)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this1 = f;
HXDLIN( 213)						Float za = this1;
HXDLIN( 213)						Float f2;
HXDLIN( 213)						bool f3;
HXDLIN( 213)						if ((gamma >= 0)) {
HXLINE( 213)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 213)							f3 = false;
            						}
HXDLIN( 213)						if (f3) {
HXLINE( 213)							f2 = gamma;
            						}
            						else {
HXLINE( 213)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 213)							if ((a >= 0)) {
HXLINE( 213)								f2 = a;
            							}
            							else {
HXLINE( 213)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 213)						Float this2 = f2;
HXDLIN( 213)						Float zb = this2;
HXDLIN( 213)						Float fa = za;
HXDLIN( 213)						Float fb = zb;
HXDLIN( 213)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 213)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 213)						bool clockwise = (fa < fb);
HXDLIN( 213)						Float dif1;
HXDLIN( 213)						if (clockwise) {
HXLINE( 213)							dif1 = theta;
            						}
            						else {
HXLINE( 213)							dif1 = -(theta);
            						}
HXDLIN( 213)						if (largest) {
HXLINE( 213)							dif = dif1;
            						}
            						else {
HXLINE( 213)							if (clockwise) {
HXLINE( 213)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 213)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 213)				bool positive = (dif >= 0);
HXDLIN( 213)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 213)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 213)				Float angle = beta;
HXDLIN( 213)				Float cx;
HXDLIN( 213)				Float cy;
HXDLIN( 213)				Float bx = ( (Float)(0) );
HXDLIN( 213)				Float by = ( (Float)(0) );
HXDLIN( 213)				int p2 = temp->length;
HXDLIN( 213)				{
HXLINE( 213)					int _g = 0;
HXDLIN( 213)					int _g1 = (totalSteps + 1);
HXDLIN( 213)					while((_g < _g1)){
HXLINE( 213)						_g = (_g + 1);
HXDLIN( 213)						int i = (_g - 1);
HXDLIN( 213)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 213)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 213)						p2 = (p2 + 1);
HXDLIN( 213)						temp[(p2 - 1)] = cx;
HXDLIN( 213)						p2 = (p2 + 1);
HXDLIN( 213)						temp[(p2 - 1)] = cy;
HXDLIN( 213)						if ((i != 0)) {
HXLINE( 213)							::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            						}
HXDLIN( 213)						angle = (angle + step1);
HXDLIN( 213)						bx = cx;
HXDLIN( 213)						by = cy;
            					}
            				}
            			}
HXDLIN( 213)			int pA = this->pointsAnti->length;
HXDLIN( 213)			int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 213)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN( 213)			{
HXLINE( 213)				int _g2 = 0;
HXDLIN( 213)				int _g3 = p4;
HXDLIN( 213)				while((_g2 < _g3)){
HXLINE( 213)					_g2 = (_g2 + 1);
HXDLIN( 213)					int i = (_g2 - 1);
HXDLIN( 213)					pA = (pA + 1);
HXDLIN( 213)					this->pointsAnti[(pA - 1)] = temp->__get(((len - (2 * i)) + 1));
HXDLIN( 213)					pA = (pA + 1);
HXDLIN( 213)					this->pointsAnti[(pA - 1)] = temp->__get((len - (2 * i)));
            				}
            			}
HXDLIN( 213)			int pC = this->pointsClock->length;
HXDLIN( 213)			{
HXLINE( 213)				int _g4 = 0;
HXDLIN( 213)				int _g5 = p4;
HXDLIN( 213)				while((_g4 < _g5)){
HXLINE( 213)					_g4 = (_g4 + 1);
HXDLIN( 213)					int i = (_g4 - 1);
HXDLIN( 213)					pC = (pC + 1);
HXDLIN( 213)					this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len) + 1));
HXDLIN( 213)					pC = (pC + 1);
HXDLIN( 213)					this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len));
            				}
            			}
            		}
HXLINE( 214)		if (overlap) {
HXLINE( 215)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXDLIN( 215)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            		}
            		else {
HXLINE( 217)			if ((this->count != 0)) {
HXLINE( 217)				this->addQuads(clockWise,width_);
            			}
HXLINE( 218)			{
HXLINE( 218)				this->quadIndex = ::cornerContour::IPen_obj::get_pos(this->pen);
HXDLIN( 218)				if ((this->count == 0)) {
HXLINE( 218)					this->penultimateAX = ( (Float)(this->dxPrev) );
HXDLIN( 218)					this->penultimateAY = ( (Float)(this->dyPrev) );
HXDLIN( 218)					this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 218)					this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 218)					this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 218)					this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 218)					this->lastClockX = ( (Float)(this->exPrev) );
HXDLIN( 218)					this->lastClockY = ( (Float)(this->eyPrev) );
HXDLIN( 218)					::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXDLIN( 218)					::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            				}
            				else {
HXLINE( 218)					bool _hx_tmp;
HXDLIN( 218)					if (clockWise) {
HXLINE( 218)						_hx_tmp = !(this->lastClock);
            					}
            					else {
HXLINE( 218)						_hx_tmp = false;
            					}
HXDLIN( 218)					if (_hx_tmp) {
HXLINE( 218)						this->penultimateAX = this->jx;
HXDLIN( 218)						this->penultimateAY = this->jy;
HXDLIN( 218)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 218)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 218)						this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 218)						this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 218)						this->lastClockX = ( (Float)(this->exPrev) );
HXDLIN( 218)						this->lastClockY = ( (Float)(this->eyPrev) );
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            					}
HXDLIN( 218)					bool _hx_tmp1;
HXDLIN( 218)					if (clockWise) {
HXLINE( 218)						_hx_tmp1 = this->lastClock;
            					}
            					else {
HXLINE( 218)						_hx_tmp1 = false;
            					}
HXDLIN( 218)					if (_hx_tmp1) {
HXLINE( 218)						this->penultimateAX = this->jx;
HXDLIN( 218)						this->penultimateAY = this->jy;
HXDLIN( 218)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 218)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 218)						this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 218)						this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 218)						this->lastClockX = ( (Float)(this->exPrev) );
HXDLIN( 218)						this->lastClockY = ( (Float)(this->eyPrev) );
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            					}
HXDLIN( 218)					bool _hx_tmp2;
HXDLIN( 218)					if (!(clockWise)) {
HXLINE( 218)						_hx_tmp2 = !(this->lastClock);
            					}
            					else {
HXLINE( 218)						_hx_tmp2 = false;
            					}
HXDLIN( 218)					if (_hx_tmp2) {
HXLINE( 218)						this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 218)						this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 218)						this->lastClockX = this->jx;
HXDLIN( 218)						this->lastClockY = this->jy;
HXDLIN( 218)						this->penultimateAX = ( (Float)(this->dxPrev) );
HXDLIN( 218)						this->penultimateAY = ( (Float)(this->dyPrev) );
HXDLIN( 218)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 218)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),this->jx,this->jy,-1);
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
            					}
HXDLIN( 218)					bool _hx_tmp3;
HXDLIN( 218)					if (!(clockWise)) {
HXLINE( 218)						_hx_tmp3 = this->lastClock;
            					}
            					else {
HXLINE( 218)						_hx_tmp3 = false;
            					}
HXDLIN( 218)					if (_hx_tmp3) {
HXLINE( 218)						this->penultimateAX = ( (Float)(this->dxPrev) );
HXDLIN( 218)						this->penultimateAY = ( (Float)(this->dyPrev) );
HXDLIN( 218)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 218)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 218)						this->penultimateCX = this->jx;
HXDLIN( 218)						this->penultimateCY = this->jy;
HXDLIN( 218)						this->lastClockX = ( (Float)(this->dx) );
HXDLIN( 218)						this->lastClockY = ( (Float)(this->dy) );
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXDLIN( 218)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->jx,this->jy,( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
            					}
            				}
            			}
            		}
HXLINE( 221)		if (curveEnds) {
HXLINE( 223)			if (clockWise) {
HXLINE( 224)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 224)				::Array< Float > edgePoly = this->pointsClock;
HXDLIN( 224)				int color = -1;
HXDLIN( 224)				Float pi = ::Math_obj::PI;
HXDLIN( 224)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 224)				bool positive = (dif >= 0);
HXDLIN( 224)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 224)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 224)				Float angle = theta0;
HXDLIN( 224)				Float cx;
HXDLIN( 224)				Float cy;
HXDLIN( 224)				Float bx = ( (Float)(0) );
HXDLIN( 224)				Float by = ( (Float)(0) );
HXDLIN( 224)				int p2 = edgePoly->length;
HXDLIN( 224)				{
HXLINE( 224)					int _g = 0;
HXDLIN( 224)					int _g1 = (totalSteps + 1);
HXDLIN( 224)					while((_g < _g1)){
HXLINE( 224)						_g = (_g + 1);
HXDLIN( 224)						int i = (_g - 1);
HXDLIN( 224)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 224)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 224)						p2 = (p2 + 1);
HXDLIN( 224)						edgePoly[(p2 - 1)] = cx;
HXDLIN( 224)						p2 = (p2 + 1);
HXDLIN( 224)						edgePoly[(p2 - 1)] = cy;
HXDLIN( 224)						if ((i != 0)) {
HXLINE( 224)							::cornerContour::IPen_obj::triangle2DFill(this->pen,ax_,ay_,bx,by,cx,cy,color);
            						}
HXDLIN( 224)						angle = (angle + step1);
HXDLIN( 224)						bx = cx;
HXDLIN( 224)						by = cy;
            					}
            				}
            			}
            			else {
HXLINE( 226)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 226)				::Array< Float > edgePoly = this->pointsAnti;
HXDLIN( 226)				int color = -1;
HXDLIN( 226)				Float pi = ::Math_obj::PI;
HXDLIN( 226)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 226)				bool positive = (dif >= 0);
HXDLIN( 226)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 226)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 226)				Float angle = theta0;
HXDLIN( 226)				Float cx;
HXDLIN( 226)				Float cy;
HXDLIN( 226)				Float bx = ( (Float)(0) );
HXDLIN( 226)				Float by = ( (Float)(0) );
HXDLIN( 226)				int p2 = edgePoly->length;
HXDLIN( 226)				{
HXLINE( 226)					int _g = 0;
HXDLIN( 226)					int _g1 = (totalSteps + 1);
HXDLIN( 226)					while((_g < _g1)){
HXLINE( 226)						_g = (_g + 1);
HXDLIN( 226)						int i = (_g - 1);
HXDLIN( 226)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 226)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 226)						p2 = (p2 + 1);
HXDLIN( 226)						edgePoly[(p2 - 1)] = cx;
HXDLIN( 226)						p2 = (p2 + 1);
HXDLIN( 226)						edgePoly[(p2 - 1)] = cy;
HXDLIN( 226)						if ((i != 0)) {
HXLINE( 226)							::cornerContour::IPen_obj::triangle2DFill(this->pen,ax_,ay_,bx,by,cx,cy,color);
            						}
HXDLIN( 226)						angle = (angle + step1);
HXDLIN( 226)						bx = cx;
HXDLIN( 226)						by = cy;
            					}
            				}
            			}
            		}
            		else {
HXLINE( 230)			if ((this->count != 0)) {
HXLINE( 231)				if (overlap) {
HXLINE( 232)					if (clockWise) {
HXLINE( 232)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),this->ax,this->ay,-1);
            					}
            					else {
HXLINE( 232)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->ax,this->ay,-1);
            					}
            				}
            				else {
HXLINE( 234)					if (clockWise) {
HXLINE( 234)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),this->jx,this->jy,-1);
            					}
            					else {
HXLINE( 234)						::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->jx,this->jy,-1);
            					}
            				}
            			}
            		}
HXLINE( 240)		{
HXLINE( 240)			this->kax = ( (Float)(this->dxPrev) );
HXDLIN( 240)			this->kay = ( (Float)(this->dyPrev) );
HXDLIN( 240)			this->kbx = ( (Float)(this->dx) );
HXDLIN( 240)			this->kby = ( (Float)(this->dy) );
HXDLIN( 240)			this->ncx = ( (Float)(this->exPrev) );
HXDLIN( 240)			this->ncy = ( (Float)(this->eyPrev) );
HXDLIN( 240)			this->kcx = ( (Float)(this->ex) );
HXDLIN( 240)			this->kcy = ( (Float)(this->ey) );
            		}
HXLINE( 243)		bool _hx_tmp2;
HXDLIN( 243)		bool _hx_tmp3;
HXDLIN( 243)		if (curveEnds) {
HXLINE( 243)			_hx_tmp3 = !(overlap);
            		}
            		else {
HXLINE( 243)			_hx_tmp3 = false;
            		}
HXDLIN( 243)		if (_hx_tmp3) {
HXLINE( 243)			_hx_tmp2 = (this->count != 0);
            		}
            		else {
HXLINE( 243)			_hx_tmp2 = false;
            		}
HXDLIN( 243)		if (_hx_tmp2) {
HXLINE( 243)			if (clockWise) {
HXLINE( 243)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),this->jx,this->jy,-1);
HXDLIN( 243)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),this->jx,this->jy,-1);
            			}
            			else {
HXLINE( 243)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),this->jx,this->jy,-1);
HXDLIN( 243)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->jx,this->jy,-1);
            			}
            		}
HXLINE( 253)		this->jxOld = this->jx;
HXLINE( 254)		this->jyOld = this->jy;
HXLINE( 255)		this->lastClock = clockWise;
HXLINE( 256)		this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC7(Contour_obj,triangleJoin,(void))

void Contour_obj::overlapQuad(){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_260_overlapQuad)
HXLINE( 261)		::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXLINE( 263)		::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,overlapQuad,(void))

void Contour_obj::end(Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_268_end)
HXLINE( 269)		this->endEdges();
HXLINE( 270)		if ((this->count != 0)) {
HXLINE( 270)			Float ax = this->bx;
HXDLIN( 270)			Float ay = this->by;
HXDLIN( 270)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 270)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 270)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 270)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 270)			{
HXLINE( 270)				int color = 0;
HXDLIN( 270)				 ::Dynamic sides = 36;
HXDLIN( 270)				if (::hx::IsNull( sides )) {
HXLINE( 270)					sides = 36;
            				}
HXDLIN( 270)				Float pi = ::Math_obj::PI;
HXDLIN( 270)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 270)				Float dif;
HXDLIN( 270)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 270)						Float f;
HXDLIN( 270)						bool f1;
HXDLIN( 270)						if ((beta >= 0)) {
HXLINE( 270)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f1 = false;
            						}
HXDLIN( 270)						if (f1) {
HXLINE( 270)							f = beta;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f = a;
            							}
            							else {
HXLINE( 270)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this1 = f;
HXDLIN( 270)						Float za = this1;
HXDLIN( 270)						Float f2;
HXDLIN( 270)						bool f3;
HXDLIN( 270)						if ((gamma >= 0)) {
HXLINE( 270)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f3 = false;
            						}
HXDLIN( 270)						if (f3) {
HXLINE( 270)							f2 = gamma;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f2 = a;
            							}
            							else {
HXLINE( 270)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this2 = f2;
HXDLIN( 270)						Float zb = this2;
HXDLIN( 270)						Float fa = za;
HXDLIN( 270)						Float fb = zb;
HXDLIN( 270)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 270)						bool clockwise = (fa < fb);
HXDLIN( 270)						Float dif1;
HXDLIN( 270)						if (clockwise) {
HXLINE( 270)							dif1 = theta;
            						}
            						else {
HXLINE( 270)							dif1 = -(theta);
            						}
HXDLIN( 270)						if ((dif1 > 0)) {
HXLINE( 270)							dif = dif1;
            						}
            						else {
HXLINE( 270)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 270)						Float f;
HXDLIN( 270)						bool f1;
HXDLIN( 270)						if ((beta >= 0)) {
HXLINE( 270)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f1 = false;
            						}
HXDLIN( 270)						if (f1) {
HXLINE( 270)							f = beta;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f = a;
            							}
            							else {
HXLINE( 270)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this1 = f;
HXDLIN( 270)						Float za = this1;
HXDLIN( 270)						Float f2;
HXDLIN( 270)						bool f3;
HXDLIN( 270)						if ((gamma >= 0)) {
HXLINE( 270)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f3 = false;
            						}
HXDLIN( 270)						if (f3) {
HXLINE( 270)							f2 = gamma;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f2 = a;
            							}
            							else {
HXLINE( 270)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this2 = f2;
HXDLIN( 270)						Float zb = this2;
HXDLIN( 270)						Float fa = za;
HXDLIN( 270)						Float fb = zb;
HXDLIN( 270)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 270)						bool clockwise = (fa < fb);
HXDLIN( 270)						Float dif1;
HXDLIN( 270)						if (clockwise) {
HXLINE( 270)							dif1 = theta;
            						}
            						else {
HXLINE( 270)							dif1 = -(theta);
            						}
HXDLIN( 270)						if ((dif1 < 0)) {
HXLINE( 270)							dif = dif1;
            						}
            						else {
HXLINE( 270)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 270)						Float f;
HXDLIN( 270)						bool f1;
HXDLIN( 270)						if ((beta >= 0)) {
HXLINE( 270)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f1 = false;
            						}
HXDLIN( 270)						if (f1) {
HXLINE( 270)							f = beta;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f = a;
            							}
            							else {
HXLINE( 270)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this1 = f;
HXDLIN( 270)						Float za = this1;
HXDLIN( 270)						Float f2;
HXDLIN( 270)						bool f3;
HXDLIN( 270)						if ((gamma >= 0)) {
HXLINE( 270)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f3 = false;
            						}
HXDLIN( 270)						if (f3) {
HXLINE( 270)							f2 = gamma;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f2 = a;
            							}
            							else {
HXLINE( 270)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this2 = f2;
HXDLIN( 270)						Float zb = this2;
HXDLIN( 270)						Float fa = za;
HXDLIN( 270)						Float fb = zb;
HXDLIN( 270)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 270)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 270)						bool clockwise = (fa < fb);
HXDLIN( 270)						Float dif1;
HXDLIN( 270)						if (clockwise) {
HXLINE( 270)							dif1 = theta;
            						}
            						else {
HXLINE( 270)							dif1 = -(theta);
            						}
HXDLIN( 270)						if (smallest) {
HXLINE( 270)							dif = dif1;
            						}
            						else {
HXLINE( 270)							if (clockwise) {
HXLINE( 270)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 270)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 270)						Float f;
HXDLIN( 270)						bool f1;
HXDLIN( 270)						if ((beta >= 0)) {
HXLINE( 270)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f1 = false;
            						}
HXDLIN( 270)						if (f1) {
HXLINE( 270)							f = beta;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f = a;
            							}
            							else {
HXLINE( 270)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this1 = f;
HXDLIN( 270)						Float za = this1;
HXDLIN( 270)						Float f2;
HXDLIN( 270)						bool f3;
HXDLIN( 270)						if ((gamma >= 0)) {
HXLINE( 270)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 270)							f3 = false;
            						}
HXDLIN( 270)						if (f3) {
HXLINE( 270)							f2 = gamma;
            						}
            						else {
HXLINE( 270)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 270)							if ((a >= 0)) {
HXLINE( 270)								f2 = a;
            							}
            							else {
HXLINE( 270)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 270)						Float this2 = f2;
HXDLIN( 270)						Float zb = this2;
HXDLIN( 270)						Float fa = za;
HXDLIN( 270)						Float fb = zb;
HXDLIN( 270)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 270)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 270)						bool clockwise = (fa < fb);
HXDLIN( 270)						Float dif1;
HXDLIN( 270)						if (clockwise) {
HXLINE( 270)							dif1 = theta;
            						}
            						else {
HXLINE( 270)							dif1 = -(theta);
            						}
HXDLIN( 270)						if (largest) {
HXLINE( 270)							dif = dif1;
            						}
            						else {
HXLINE( 270)							if (clockwise) {
HXLINE( 270)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 270)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 270)				bool positive = (dif >= 0);
HXDLIN( 270)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 270)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 270)				Float angle = beta;
HXDLIN( 270)				Float cx;
HXDLIN( 270)				Float cy;
HXDLIN( 270)				Float bx = ( (Float)(0) );
HXDLIN( 270)				Float by = ( (Float)(0) );
HXDLIN( 270)				int p2 = temp->length;
HXDLIN( 270)				{
HXLINE( 270)					int _g = 0;
HXDLIN( 270)					int _g1 = (totalSteps + 1);
HXDLIN( 270)					while((_g < _g1)){
HXLINE( 270)						_g = (_g + 1);
HXDLIN( 270)						int i = (_g - 1);
HXDLIN( 270)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 270)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 270)						p2 = (p2 + 1);
HXDLIN( 270)						temp[(p2 - 1)] = cx;
HXDLIN( 270)						p2 = (p2 + 1);
HXDLIN( 270)						temp[(p2 - 1)] = cy;
HXDLIN( 270)						if ((i != 0)) {
HXLINE( 270)							::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            						}
HXDLIN( 270)						angle = (angle + step1);
HXDLIN( 270)						bx = cx;
HXDLIN( 270)						by = cy;
            					}
            				}
            			}
HXDLIN( 270)			int pA = this->pointsAnti->length;
HXDLIN( 270)			int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 270)			{
HXLINE( 270)				int _g2 = 0;
HXDLIN( 270)				int _g3 = (len + 2);
HXDLIN( 270)				while((_g2 < _g3)){
HXLINE( 270)					_g2 = (_g2 + 1);
HXDLIN( 270)					int i = (_g2 - 1);
HXDLIN( 270)					pA = (pA + 1);
HXDLIN( 270)					this->pointsAnti[(pA - 1)] = temp->__get(i);
            				}
            			}
HXDLIN( 270)			int pC = this->pointsClock->length;
HXDLIN( 270)			{
HXLINE( 270)				int _g4 = 1;
HXDLIN( 270)				int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 270)				while((_g4 < _g5)){
HXLINE( 270)					_g4 = (_g4 + 1);
HXDLIN( 270)					int i = (_g4 - 1);
HXDLIN( 270)					pC = (pC + 1);
HXDLIN( 270)					this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 270)					pC = (pC + 1);
HXDLIN( 270)					this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Contour_obj,end,(void))

void Contour_obj::triangle2DFill(Float ax_,Float ay_,Float bx_,Float by_,Float cx_,Float cy_,::hx::Null< int >  __o_color_){
            		int color_ = __o_color_.Default(-1);
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_274_triangle2DFill)
HXDLIN( 274)		::cornerContour::IPen_obj::triangle2DFill(this->pen,ax_,ay_,bx_,by_,cx_,cy_,color_);
            	}


HX_DEFINE_DYNAMIC_FUNC7(Contour_obj,triangle2DFill,(void))

void Contour_obj::addPieXstart(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_mark, ::Dynamic __o_sides){
            		 ::Dynamic mark = __o_mark;
            		if (::hx::IsNull(__o_mark)) mark = -1;
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_277_addPieXstart)
HXLINE( 278)		::Array< Float > temp = ::Array_obj< Float >::__new();
HXLINE( 279)		{
HXLINE( 279)			int color = ( (int)(mark) );
HXDLIN( 279)			 ::Dynamic sides1 = sides;
HXDLIN( 279)			if (::hx::IsNull( sides1 )) {
HXLINE( 279)				sides1 = 36;
            			}
HXDLIN( 279)			Float pi = ::Math_obj::PI;
HXDLIN( 279)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 279)			Float dif;
HXDLIN( 279)			switch((int)(prefer->_hx_getIndex())){
            				case (int)0: {
HXLINE( 279)					Float f;
HXDLIN( 279)					bool f1;
HXDLIN( 279)					if ((beta >= 0)) {
HXLINE( 279)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f1 = false;
            					}
HXDLIN( 279)					if (f1) {
HXLINE( 279)						f = beta;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f = a;
            						}
            						else {
HXLINE( 279)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this1 = f;
HXDLIN( 279)					Float za = this1;
HXDLIN( 279)					Float f2;
HXDLIN( 279)					bool f3;
HXDLIN( 279)					if ((gamma >= 0)) {
HXLINE( 279)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f3 = false;
            					}
HXDLIN( 279)					if (f3) {
HXLINE( 279)						f2 = gamma;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f2 = a;
            						}
            						else {
HXLINE( 279)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this2 = f2;
HXDLIN( 279)					Float zb = this2;
HXDLIN( 279)					Float fa = za;
HXDLIN( 279)					Float fb = zb;
HXDLIN( 279)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 279)					bool clockwise = (fa < fb);
HXDLIN( 279)					Float dif1;
HXDLIN( 279)					if (clockwise) {
HXLINE( 279)						dif1 = theta;
            					}
            					else {
HXLINE( 279)						dif1 = -(theta);
            					}
HXDLIN( 279)					if ((dif1 > 0)) {
HXLINE( 279)						dif = dif1;
            					}
            					else {
HXLINE( 279)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 279)					Float f;
HXDLIN( 279)					bool f1;
HXDLIN( 279)					if ((beta >= 0)) {
HXLINE( 279)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f1 = false;
            					}
HXDLIN( 279)					if (f1) {
HXLINE( 279)						f = beta;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f = a;
            						}
            						else {
HXLINE( 279)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this1 = f;
HXDLIN( 279)					Float za = this1;
HXDLIN( 279)					Float f2;
HXDLIN( 279)					bool f3;
HXDLIN( 279)					if ((gamma >= 0)) {
HXLINE( 279)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f3 = false;
            					}
HXDLIN( 279)					if (f3) {
HXLINE( 279)						f2 = gamma;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f2 = a;
            						}
            						else {
HXLINE( 279)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this2 = f2;
HXDLIN( 279)					Float zb = this2;
HXDLIN( 279)					Float fa = za;
HXDLIN( 279)					Float fb = zb;
HXDLIN( 279)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 279)					bool clockwise = (fa < fb);
HXDLIN( 279)					Float dif1;
HXDLIN( 279)					if (clockwise) {
HXLINE( 279)						dif1 = theta;
            					}
            					else {
HXLINE( 279)						dif1 = -(theta);
            					}
HXDLIN( 279)					if ((dif1 < 0)) {
HXLINE( 279)						dif = dif1;
            					}
            					else {
HXLINE( 279)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 279)					Float f;
HXDLIN( 279)					bool f1;
HXDLIN( 279)					if ((beta >= 0)) {
HXLINE( 279)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f1 = false;
            					}
HXDLIN( 279)					if (f1) {
HXLINE( 279)						f = beta;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f = a;
            						}
            						else {
HXLINE( 279)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this1 = f;
HXDLIN( 279)					Float za = this1;
HXDLIN( 279)					Float f2;
HXDLIN( 279)					bool f3;
HXDLIN( 279)					if ((gamma >= 0)) {
HXLINE( 279)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f3 = false;
            					}
HXDLIN( 279)					if (f3) {
HXLINE( 279)						f2 = gamma;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f2 = a;
            						}
            						else {
HXLINE( 279)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this2 = f2;
HXDLIN( 279)					Float zb = this2;
HXDLIN( 279)					Float fa = za;
HXDLIN( 279)					Float fb = zb;
HXDLIN( 279)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 279)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 279)					bool clockwise = (fa < fb);
HXDLIN( 279)					Float dif1;
HXDLIN( 279)					if (clockwise) {
HXLINE( 279)						dif1 = theta;
            					}
            					else {
HXLINE( 279)						dif1 = -(theta);
            					}
HXDLIN( 279)					if (smallest) {
HXLINE( 279)						dif = dif1;
            					}
            					else {
HXLINE( 279)						if (clockwise) {
HXLINE( 279)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 279)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 279)					Float f;
HXDLIN( 279)					bool f1;
HXDLIN( 279)					if ((beta >= 0)) {
HXLINE( 279)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f1 = false;
            					}
HXDLIN( 279)					if (f1) {
HXLINE( 279)						f = beta;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f = a;
            						}
            						else {
HXLINE( 279)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this1 = f;
HXDLIN( 279)					Float za = this1;
HXDLIN( 279)					Float f2;
HXDLIN( 279)					bool f3;
HXDLIN( 279)					if ((gamma >= 0)) {
HXLINE( 279)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 279)						f3 = false;
            					}
HXDLIN( 279)					if (f3) {
HXLINE( 279)						f2 = gamma;
            					}
            					else {
HXLINE( 279)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 279)						if ((a >= 0)) {
HXLINE( 279)							f2 = a;
            						}
            						else {
HXLINE( 279)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 279)					Float this2 = f2;
HXDLIN( 279)					Float zb = this2;
HXDLIN( 279)					Float fa = za;
HXDLIN( 279)					Float fb = zb;
HXDLIN( 279)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 279)					bool largest = (theta > ::Math_obj::PI);
HXDLIN( 279)					bool clockwise = (fa < fb);
HXDLIN( 279)					Float dif1;
HXDLIN( 279)					if (clockwise) {
HXLINE( 279)						dif1 = theta;
            					}
            					else {
HXLINE( 279)						dif1 = -(theta);
            					}
HXDLIN( 279)					if (largest) {
HXLINE( 279)						dif = dif1;
            					}
            					else {
HXLINE( 279)						if (clockwise) {
HXLINE( 279)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 279)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN( 279)			bool positive = (dif >= 0);
HXDLIN( 279)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 279)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 279)			Float angle = beta;
HXDLIN( 279)			Float cx;
HXDLIN( 279)			Float cy;
HXDLIN( 279)			Float bx = ( (Float)(0) );
HXDLIN( 279)			Float by = ( (Float)(0) );
HXDLIN( 279)			int p2 = temp->length;
HXDLIN( 279)			{
HXLINE( 279)				int _g = 0;
HXDLIN( 279)				int _g1 = (totalSteps + 1);
HXDLIN( 279)				while((_g < _g1)){
HXLINE( 279)					_g = (_g + 1);
HXDLIN( 279)					int i = (_g - 1);
HXDLIN( 279)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 279)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 279)					p2 = (p2 + 1);
HXDLIN( 279)					temp[(p2 - 1)] = cx;
HXDLIN( 279)					p2 = (p2 + 1);
HXDLIN( 279)					temp[(p2 - 1)] = cy;
HXDLIN( 279)					if ((i != 0)) {
HXLINE( 279)						::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            					}
HXDLIN( 279)					angle = (angle + step1);
HXDLIN( 279)					bx = cx;
HXDLIN( 279)					by = cy;
            				}
            			}
            		}
HXLINE( 280)		int pA = this->pointsAnti->length;
HXLINE( 281)		int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXLINE( 282)		int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXLINE( 283)		{
HXLINE( 283)			int _g2 = 0;
HXDLIN( 283)			int _g3 = p4;
HXDLIN( 283)			while((_g2 < _g3)){
HXLINE( 283)				_g2 = (_g2 + 1);
HXDLIN( 283)				int i = (_g2 - 1);
HXLINE( 284)				pA = (pA + 1);
HXDLIN( 284)				this->pointsAnti[(pA - 1)] = temp->__get(((len - (2 * i)) + 1));
HXLINE( 285)				pA = (pA + 1);
HXDLIN( 285)				this->pointsAnti[(pA - 1)] = temp->__get((len - (2 * i)));
            			}
            		}
HXLINE( 287)		int pC = this->pointsClock->length;
HXLINE( 288)		{
HXLINE( 288)			int _g4 = 0;
HXDLIN( 288)			int _g5 = p4;
HXDLIN( 288)			while((_g4 < _g5)){
HXLINE( 288)				_g4 = (_g4 + 1);
HXDLIN( 288)				int i = (_g4 - 1);
HXLINE( 289)				pC = (pC + 1);
HXDLIN( 289)				this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len) + 1));
HXLINE( 290)				pC = (pC + 1);
HXDLIN( 290)				this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,addPieXstart,(void))

void Contour_obj::addPieX(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_mark, ::Dynamic __o_sides){
            		 ::Dynamic mark = __o_mark;
            		if (::hx::IsNull(__o_mark)) mark = 0;
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_295_addPieX)
HXLINE( 296)		::Array< Float > temp = ::Array_obj< Float >::__new();
HXLINE( 297)		{
HXLINE( 297)			int color = ( (int)(mark) );
HXDLIN( 297)			 ::Dynamic sides1 = sides;
HXDLIN( 297)			if (::hx::IsNull( sides1 )) {
HXLINE( 297)				sides1 = 36;
            			}
HXDLIN( 297)			Float pi = ::Math_obj::PI;
HXDLIN( 297)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 297)			Float dif;
HXDLIN( 297)			switch((int)(prefer->_hx_getIndex())){
            				case (int)0: {
HXLINE( 297)					Float f;
HXDLIN( 297)					bool f1;
HXDLIN( 297)					if ((beta >= 0)) {
HXLINE( 297)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f1 = false;
            					}
HXDLIN( 297)					if (f1) {
HXLINE( 297)						f = beta;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f = a;
            						}
            						else {
HXLINE( 297)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this1 = f;
HXDLIN( 297)					Float za = this1;
HXDLIN( 297)					Float f2;
HXDLIN( 297)					bool f3;
HXDLIN( 297)					if ((gamma >= 0)) {
HXLINE( 297)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f3 = false;
            					}
HXDLIN( 297)					if (f3) {
HXLINE( 297)						f2 = gamma;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f2 = a;
            						}
            						else {
HXLINE( 297)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this2 = f2;
HXDLIN( 297)					Float zb = this2;
HXDLIN( 297)					Float fa = za;
HXDLIN( 297)					Float fb = zb;
HXDLIN( 297)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 297)					bool clockwise = (fa < fb);
HXDLIN( 297)					Float dif1;
HXDLIN( 297)					if (clockwise) {
HXLINE( 297)						dif1 = theta;
            					}
            					else {
HXLINE( 297)						dif1 = -(theta);
            					}
HXDLIN( 297)					if ((dif1 > 0)) {
HXLINE( 297)						dif = dif1;
            					}
            					else {
HXLINE( 297)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 297)					Float f;
HXDLIN( 297)					bool f1;
HXDLIN( 297)					if ((beta >= 0)) {
HXLINE( 297)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f1 = false;
            					}
HXDLIN( 297)					if (f1) {
HXLINE( 297)						f = beta;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f = a;
            						}
            						else {
HXLINE( 297)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this1 = f;
HXDLIN( 297)					Float za = this1;
HXDLIN( 297)					Float f2;
HXDLIN( 297)					bool f3;
HXDLIN( 297)					if ((gamma >= 0)) {
HXLINE( 297)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f3 = false;
            					}
HXDLIN( 297)					if (f3) {
HXLINE( 297)						f2 = gamma;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f2 = a;
            						}
            						else {
HXLINE( 297)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this2 = f2;
HXDLIN( 297)					Float zb = this2;
HXDLIN( 297)					Float fa = za;
HXDLIN( 297)					Float fb = zb;
HXDLIN( 297)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 297)					bool clockwise = (fa < fb);
HXDLIN( 297)					Float dif1;
HXDLIN( 297)					if (clockwise) {
HXLINE( 297)						dif1 = theta;
            					}
            					else {
HXLINE( 297)						dif1 = -(theta);
            					}
HXDLIN( 297)					if ((dif1 < 0)) {
HXLINE( 297)						dif = dif1;
            					}
            					else {
HXLINE( 297)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 297)					Float f;
HXDLIN( 297)					bool f1;
HXDLIN( 297)					if ((beta >= 0)) {
HXLINE( 297)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f1 = false;
            					}
HXDLIN( 297)					if (f1) {
HXLINE( 297)						f = beta;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f = a;
            						}
            						else {
HXLINE( 297)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this1 = f;
HXDLIN( 297)					Float za = this1;
HXDLIN( 297)					Float f2;
HXDLIN( 297)					bool f3;
HXDLIN( 297)					if ((gamma >= 0)) {
HXLINE( 297)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f3 = false;
            					}
HXDLIN( 297)					if (f3) {
HXLINE( 297)						f2 = gamma;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f2 = a;
            						}
            						else {
HXLINE( 297)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this2 = f2;
HXDLIN( 297)					Float zb = this2;
HXDLIN( 297)					Float fa = za;
HXDLIN( 297)					Float fb = zb;
HXDLIN( 297)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 297)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 297)					bool clockwise = (fa < fb);
HXDLIN( 297)					Float dif1;
HXDLIN( 297)					if (clockwise) {
HXLINE( 297)						dif1 = theta;
            					}
            					else {
HXLINE( 297)						dif1 = -(theta);
            					}
HXDLIN( 297)					if (smallest) {
HXLINE( 297)						dif = dif1;
            					}
            					else {
HXLINE( 297)						if (clockwise) {
HXLINE( 297)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 297)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 297)					Float f;
HXDLIN( 297)					bool f1;
HXDLIN( 297)					if ((beta >= 0)) {
HXLINE( 297)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f1 = false;
            					}
HXDLIN( 297)					if (f1) {
HXLINE( 297)						f = beta;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f = a;
            						}
            						else {
HXLINE( 297)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this1 = f;
HXDLIN( 297)					Float za = this1;
HXDLIN( 297)					Float f2;
HXDLIN( 297)					bool f3;
HXDLIN( 297)					if ((gamma >= 0)) {
HXLINE( 297)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 297)						f3 = false;
            					}
HXDLIN( 297)					if (f3) {
HXLINE( 297)						f2 = gamma;
            					}
            					else {
HXLINE( 297)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 297)						if ((a >= 0)) {
HXLINE( 297)							f2 = a;
            						}
            						else {
HXLINE( 297)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 297)					Float this2 = f2;
HXDLIN( 297)					Float zb = this2;
HXDLIN( 297)					Float fa = za;
HXDLIN( 297)					Float fb = zb;
HXDLIN( 297)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 297)					bool largest = (theta > ::Math_obj::PI);
HXDLIN( 297)					bool clockwise = (fa < fb);
HXDLIN( 297)					Float dif1;
HXDLIN( 297)					if (clockwise) {
HXLINE( 297)						dif1 = theta;
            					}
            					else {
HXLINE( 297)						dif1 = -(theta);
            					}
HXDLIN( 297)					if (largest) {
HXLINE( 297)						dif = dif1;
            					}
            					else {
HXLINE( 297)						if (clockwise) {
HXLINE( 297)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 297)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN( 297)			bool positive = (dif >= 0);
HXDLIN( 297)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 297)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 297)			Float angle = beta;
HXDLIN( 297)			Float cx;
HXDLIN( 297)			Float cy;
HXDLIN( 297)			Float bx = ( (Float)(0) );
HXDLIN( 297)			Float by = ( (Float)(0) );
HXDLIN( 297)			int p2 = temp->length;
HXDLIN( 297)			{
HXLINE( 297)				int _g = 0;
HXDLIN( 297)				int _g1 = (totalSteps + 1);
HXDLIN( 297)				while((_g < _g1)){
HXLINE( 297)					_g = (_g + 1);
HXDLIN( 297)					int i = (_g - 1);
HXDLIN( 297)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 297)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 297)					p2 = (p2 + 1);
HXDLIN( 297)					temp[(p2 - 1)] = cx;
HXDLIN( 297)					p2 = (p2 + 1);
HXDLIN( 297)					temp[(p2 - 1)] = cy;
HXDLIN( 297)					if ((i != 0)) {
HXLINE( 297)						::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            					}
HXDLIN( 297)					angle = (angle + step1);
HXDLIN( 297)					bx = cx;
HXDLIN( 297)					by = cy;
            				}
            			}
            		}
HXLINE( 298)		int pA = this->pointsAnti->length;
HXLINE( 299)		int len = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXLINE( 300)		{
HXLINE( 300)			int _g2 = 0;
HXDLIN( 300)			int _g3 = (len + 2);
HXDLIN( 300)			while((_g2 < _g3)){
HXLINE( 300)				_g2 = (_g2 + 1);
HXDLIN( 300)				int i = (_g2 - 1);
HXLINE( 301)				pA = (pA + 1);
HXDLIN( 301)				this->pointsAnti[(pA - 1)] = temp->__get(i);
            			}
            		}
HXLINE( 303)		int pC = this->pointsClock->length;
HXLINE( 304)		{
HXLINE( 304)			int _g4 = 1;
HXDLIN( 304)			int _g5 = ::Std_obj::_hx_int(((( (Float)(len) ) / ( (Float)(2) )) + 1));
HXDLIN( 304)			while((_g4 < _g5)){
HXLINE( 304)				_g4 = (_g4 + 1);
HXDLIN( 304)				int i = (_g4 - 1);
HXLINE( 305)				pC = (pC + 1);
HXDLIN( 305)				this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXLINE( 306)				pC = (pC + 1);
HXDLIN( 306)				this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,addPieX,(void))

void Contour_obj::addPie(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_mark, ::Dynamic __o_sides){
            		 ::Dynamic mark = __o_mark;
            		if (::hx::IsNull(__o_mark)) mark = 0;
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_312_addPie)
HXDLIN( 312)		int color = ( (int)(mark) );
HXDLIN( 312)		 ::Dynamic sides1 = sides;
HXDLIN( 312)		if (::hx::IsNull( sides1 )) {
HXDLIN( 312)			sides1 = 36;
            		}
HXDLIN( 312)		Float pi = ::Math_obj::PI;
HXDLIN( 312)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 312)		Float dif;
HXDLIN( 312)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXDLIN( 312)				Float f;
HXDLIN( 312)				bool f1;
HXDLIN( 312)				if ((beta >= 0)) {
HXDLIN( 312)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f1 = false;
            				}
HXDLIN( 312)				if (f1) {
HXDLIN( 312)					f = beta;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f = a;
            					}
            					else {
HXDLIN( 312)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this1 = f;
HXDLIN( 312)				Float za = this1;
HXDLIN( 312)				Float f2;
HXDLIN( 312)				bool f3;
HXDLIN( 312)				if ((gamma >= 0)) {
HXDLIN( 312)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f3 = false;
            				}
HXDLIN( 312)				if (f3) {
HXDLIN( 312)					f2 = gamma;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f2 = a;
            					}
            					else {
HXDLIN( 312)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this2 = f2;
HXDLIN( 312)				Float zb = this2;
HXDLIN( 312)				Float fa = za;
HXDLIN( 312)				Float fb = zb;
HXDLIN( 312)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 312)				bool clockwise = (fa < fb);
HXDLIN( 312)				Float dif1;
HXDLIN( 312)				if (clockwise) {
HXDLIN( 312)					dif1 = theta;
            				}
            				else {
HXDLIN( 312)					dif1 = -(theta);
            				}
HXDLIN( 312)				if ((dif1 > 0)) {
HXDLIN( 312)					dif = dif1;
            				}
            				else {
HXDLIN( 312)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN( 312)				Float f;
HXDLIN( 312)				bool f1;
HXDLIN( 312)				if ((beta >= 0)) {
HXDLIN( 312)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f1 = false;
            				}
HXDLIN( 312)				if (f1) {
HXDLIN( 312)					f = beta;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f = a;
            					}
            					else {
HXDLIN( 312)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this1 = f;
HXDLIN( 312)				Float za = this1;
HXDLIN( 312)				Float f2;
HXDLIN( 312)				bool f3;
HXDLIN( 312)				if ((gamma >= 0)) {
HXDLIN( 312)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f3 = false;
            				}
HXDLIN( 312)				if (f3) {
HXDLIN( 312)					f2 = gamma;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f2 = a;
            					}
            					else {
HXDLIN( 312)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this2 = f2;
HXDLIN( 312)				Float zb = this2;
HXDLIN( 312)				Float fa = za;
HXDLIN( 312)				Float fb = zb;
HXDLIN( 312)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 312)				bool clockwise = (fa < fb);
HXDLIN( 312)				Float dif1;
HXDLIN( 312)				if (clockwise) {
HXDLIN( 312)					dif1 = theta;
            				}
            				else {
HXDLIN( 312)					dif1 = -(theta);
            				}
HXDLIN( 312)				if ((dif1 < 0)) {
HXDLIN( 312)					dif = dif1;
            				}
            				else {
HXDLIN( 312)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN( 312)				Float f;
HXDLIN( 312)				bool f1;
HXDLIN( 312)				if ((beta >= 0)) {
HXDLIN( 312)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f1 = false;
            				}
HXDLIN( 312)				if (f1) {
HXDLIN( 312)					f = beta;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f = a;
            					}
            					else {
HXDLIN( 312)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this1 = f;
HXDLIN( 312)				Float za = this1;
HXDLIN( 312)				Float f2;
HXDLIN( 312)				bool f3;
HXDLIN( 312)				if ((gamma >= 0)) {
HXDLIN( 312)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f3 = false;
            				}
HXDLIN( 312)				if (f3) {
HXDLIN( 312)					f2 = gamma;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f2 = a;
            					}
            					else {
HXDLIN( 312)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this2 = f2;
HXDLIN( 312)				Float zb = this2;
HXDLIN( 312)				Float fa = za;
HXDLIN( 312)				Float fb = zb;
HXDLIN( 312)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 312)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 312)				bool clockwise = (fa < fb);
HXDLIN( 312)				Float dif1;
HXDLIN( 312)				if (clockwise) {
HXDLIN( 312)					dif1 = theta;
            				}
            				else {
HXDLIN( 312)					dif1 = -(theta);
            				}
HXDLIN( 312)				if (smallest) {
HXDLIN( 312)					dif = dif1;
            				}
            				else {
HXDLIN( 312)					if (clockwise) {
HXDLIN( 312)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN( 312)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN( 312)				Float f;
HXDLIN( 312)				bool f1;
HXDLIN( 312)				if ((beta >= 0)) {
HXDLIN( 312)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f1 = false;
            				}
HXDLIN( 312)				if (f1) {
HXDLIN( 312)					f = beta;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f = a;
            					}
            					else {
HXDLIN( 312)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this1 = f;
HXDLIN( 312)				Float za = this1;
HXDLIN( 312)				Float f2;
HXDLIN( 312)				bool f3;
HXDLIN( 312)				if ((gamma >= 0)) {
HXDLIN( 312)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXDLIN( 312)					f3 = false;
            				}
HXDLIN( 312)				if (f3) {
HXDLIN( 312)					f2 = gamma;
            				}
            				else {
HXDLIN( 312)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 312)					if ((a >= 0)) {
HXDLIN( 312)						f2 = a;
            					}
            					else {
HXDLIN( 312)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 312)				Float this2 = f2;
HXDLIN( 312)				Float zb = this2;
HXDLIN( 312)				Float fa = za;
HXDLIN( 312)				Float fb = zb;
HXDLIN( 312)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 312)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 312)				bool clockwise = (fa < fb);
HXDLIN( 312)				Float dif1;
HXDLIN( 312)				if (clockwise) {
HXDLIN( 312)					dif1 = theta;
            				}
            				else {
HXDLIN( 312)					dif1 = -(theta);
            				}
HXDLIN( 312)				if (largest) {
HXDLIN( 312)					dif = dif1;
            				}
            				else {
HXDLIN( 312)					if (clockwise) {
HXDLIN( 312)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN( 312)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 312)		bool positive = (dif >= 0);
HXDLIN( 312)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 312)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 312)		Float angle = beta;
HXDLIN( 312)		Float cx;
HXDLIN( 312)		Float cy;
HXDLIN( 312)		Float bx = ( (Float)(0) );
HXDLIN( 312)		Float by = ( (Float)(0) );
HXDLIN( 312)		{
HXDLIN( 312)			int _g = 0;
HXDLIN( 312)			int _g1 = (totalSteps + 1);
HXDLIN( 312)			while((_g < _g1)){
HXDLIN( 312)				_g = (_g + 1);
HXDLIN( 312)				int i = (_g - 1);
HXDLIN( 312)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 312)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 312)				if ((i != 0)) {
HXDLIN( 312)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            				}
HXDLIN( 312)				angle = (angle + step1);
HXDLIN( 312)				bx = cx;
HXDLIN( 312)				by = cy;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,addPie,(void))

void Contour_obj::computeJ(Float width_,Float theta0,Float dif){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_315_computeJ)
HXLINE( 316)		Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXLINE( 317)		Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXLINE( 318)		Float f;
HXDLIN( 318)		bool f1;
HXDLIN( 318)		if ((theta0 <= ::Math_obj::PI)) {
HXLINE( 318)			f1 = (theta0 > -(::Math_obj::PI));
            		}
            		else {
HXLINE( 318)			f1 = false;
            		}
HXDLIN( 318)		if (f1) {
HXLINE( 318)			f = theta0;
            		}
            		else {
HXLINE( 318)			Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 318)			if ((a >= 0)) {
HXLINE( 318)				f = (a - ::Math_obj::PI);
            			}
            			else {
HXLINE( 318)				f = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN( 318)		Float this1 = f;
HXDLIN( 318)		Float start = this1;
HXLINE( 319)		Float start2 = start;
HXLINE( 320)		Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXLINE( 321)		this->jx = (this->ax + (h * ::Math_obj::sin(delta)));
HXLINE( 322)		this->jy = (this->ay + (h * ::Math_obj::cos(delta)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(Contour_obj,computeJ,(void))

void Contour_obj::addDot(Float x,Float y,int color,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_325_addDot)
HXLINE( 326)		Float w = (width_ * ((Float)0.07));
HXLINE( 327)		{
HXLINE( 327)			Float pi = ::Math_obj::PI;
HXDLIN( 327)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 327)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 327)			Float bx;
HXDLIN( 327)			Float by;
HXDLIN( 327)			Float cx;
HXDLIN( 327)			Float cy;
HXDLIN( 327)			{
HXLINE( 327)				int _g = 0;
HXDLIN( 327)				 ::Dynamic _g1 = 36;
HXDLIN( 327)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 327)					_g = (_g + 1);
HXDLIN( 327)					int i = (_g - 1);
HXDLIN( 327)					bx = (x + (w * ::Math_obj::sin(theta)));
HXDLIN( 327)					by = (y + (w * ::Math_obj::cos(theta)));
HXDLIN( 327)					theta = (theta + step);
HXDLIN( 327)					cx = (x + (w * ::Math_obj::sin(theta)));
HXDLIN( 327)					cy = (y + (w * ::Math_obj::cos(theta)));
HXDLIN( 327)					::cornerContour::IPen_obj::triangle2DFill(this->pen,x,y,bx,by,cx,cy,color);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Contour_obj,addDot,(void))

void Contour_obj::addSmallTriangles(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_349_addSmallTriangles)
HXDLIN( 349)		if (clockWise) {
HXLINE( 350)			::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),this->jx,this->jy,-1);
HXLINE( 351)			::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),this->jx,this->jy,-1);
            		}
            		else {
HXLINE( 354)			::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),this->jx,this->jy,-1);
HXLINE( 355)			::cornerContour::IPen_obj::triangle2DFill(this->pen,this->ax,this->ay,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->jx,this->jy,-1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,addSmallTriangles,(void))

void Contour_obj::triangle2DFillangleCorners(Float oldx_,Float oldy_,Float prevx_,Float prevy_,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_360_triangle2DFillangleCorners)
HXLINE( 361)		Float w = (width_ * ((Float)0.07));
HXLINE( 362)		{
HXLINE( 362)			int color = this->debugCol4;
HXDLIN( 362)			Float pi = ::Math_obj::PI;
HXDLIN( 362)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 362)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 362)			Float bx;
HXDLIN( 362)			Float by;
HXDLIN( 362)			Float cx;
HXDLIN( 362)			Float cy;
HXDLIN( 362)			{
HXLINE( 362)				int _g = 0;
HXDLIN( 362)				 ::Dynamic _g1 = 36;
HXDLIN( 362)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 362)					_g = (_g + 1);
HXDLIN( 362)					int i = (_g - 1);
HXDLIN( 362)					bx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 362)					by = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 362)					theta = (theta + step);
HXDLIN( 362)					cx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 362)					cy = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 362)					::cornerContour::IPen_obj::triangle2DFill(this->pen,oldx_,oldy_,bx,by,cx,cy,color);
            				}
            			}
            		}
HXLINE( 363)		{
HXLINE( 363)			int color1 = this->debugCol3;
HXDLIN( 363)			Float pi1 = ::Math_obj::PI;
HXDLIN( 363)			Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN( 363)			Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 363)			Float bx1;
HXDLIN( 363)			Float by1;
HXDLIN( 363)			Float cx1;
HXDLIN( 363)			Float cy1;
HXDLIN( 363)			{
HXLINE( 363)				int _g2 = 0;
HXDLIN( 363)				 ::Dynamic _g3 = 36;
HXDLIN( 363)				while(::hx::IsLess( _g2,_g3 )){
HXLINE( 363)					_g2 = (_g2 + 1);
HXDLIN( 363)					int i = (_g2 - 1);
HXDLIN( 363)					bx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 363)					by1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 363)					theta1 = (theta1 + step1);
HXDLIN( 363)					cx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 363)					cy1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 363)					::cornerContour::IPen_obj::triangle2DFill(this->pen,prevx_,prevy_,bx1,by1,cx1,cy1,color1);
            				}
            			}
            		}
HXLINE( 364)		{
HXLINE( 364)			Float ax = this->ax;
HXDLIN( 364)			Float ay = this->ay;
HXDLIN( 364)			int color2 = this->debugCol10;
HXDLIN( 364)			Float pi2 = ::Math_obj::PI;
HXDLIN( 364)			Float theta2 = (pi2 / ( (Float)(2) ));
HXDLIN( 364)			Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 364)			Float bx2;
HXDLIN( 364)			Float by2;
HXDLIN( 364)			Float cx2;
HXDLIN( 364)			Float cy2;
HXDLIN( 364)			{
HXLINE( 364)				int _g4 = 0;
HXDLIN( 364)				 ::Dynamic _g5 = 36;
HXDLIN( 364)				while(::hx::IsLess( _g4,_g5 )){
HXLINE( 364)					_g4 = (_g4 + 1);
HXDLIN( 364)					int i = (_g4 - 1);
HXDLIN( 364)					bx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 364)					by2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 364)					theta2 = (theta2 + step2);
HXDLIN( 364)					cx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 364)					cy2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 364)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx2,by2,cx2,cy2,color2);
            				}
            			}
            		}
HXLINE( 365)		{
HXLINE( 365)			Float ax1 = this->jx;
HXDLIN( 365)			Float ay1 = this->jy;
HXDLIN( 365)			int color3 = this->debugCol5;
HXDLIN( 365)			Float pi3 = ::Math_obj::PI;
HXDLIN( 365)			Float theta3 = (pi3 / ( (Float)(2) ));
HXDLIN( 365)			Float step3 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 365)			Float bx3;
HXDLIN( 365)			Float by3;
HXDLIN( 365)			Float cx3;
HXDLIN( 365)			Float cy3;
HXDLIN( 365)			{
HXLINE( 365)				int _g6 = 0;
HXDLIN( 365)				 ::Dynamic _g7 = 36;
HXDLIN( 365)				while(::hx::IsLess( _g6,_g7 )){
HXLINE( 365)					_g6 = (_g6 + 1);
HXDLIN( 365)					int i = (_g6 - 1);
HXDLIN( 365)					bx3 = (ax1 + (w * ::Math_obj::sin(theta3)));
HXDLIN( 365)					by3 = (ay1 + (w * ::Math_obj::cos(theta3)));
HXDLIN( 365)					theta3 = (theta3 + step3);
HXDLIN( 365)					cx3 = (ax1 + (w * ::Math_obj::sin(theta3)));
HXDLIN( 365)					cy3 = (ay1 + (w * ::Math_obj::cos(theta3)));
HXDLIN( 365)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax1,ay1,bx3,by3,cx3,cy3,color3);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Contour_obj,triangle2DFillangleCorners,(void))

void Contour_obj::triangle2DFillangleCornersLess(Float oldx_,Float oldy_,Float prevx_,Float prevy_,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_368_triangle2DFillangleCornersLess)
HXLINE( 369)		Float w = (width_ * ((Float)0.07));
HXLINE( 370)		{
HXLINE( 370)			int color = this->debugCol4;
HXDLIN( 370)			Float pi = ::Math_obj::PI;
HXDLIN( 370)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 370)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 370)			Float bx;
HXDLIN( 370)			Float by;
HXDLIN( 370)			Float cx;
HXDLIN( 370)			Float cy;
HXDLIN( 370)			{
HXLINE( 370)				int _g = 0;
HXDLIN( 370)				 ::Dynamic _g1 = 36;
HXDLIN( 370)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 370)					_g = (_g + 1);
HXDLIN( 370)					int i = (_g - 1);
HXDLIN( 370)					bx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 370)					by = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 370)					theta = (theta + step);
HXDLIN( 370)					cx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 370)					cy = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 370)					::cornerContour::IPen_obj::triangle2DFill(this->pen,oldx_,oldy_,bx,by,cx,cy,color);
            				}
            			}
            		}
HXLINE( 371)		{
HXLINE( 371)			int color1 = this->debugCol3;
HXDLIN( 371)			Float pi1 = ::Math_obj::PI;
HXDLIN( 371)			Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN( 371)			Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 371)			Float bx1;
HXDLIN( 371)			Float by1;
HXDLIN( 371)			Float cx1;
HXDLIN( 371)			Float cy1;
HXDLIN( 371)			{
HXLINE( 371)				int _g2 = 0;
HXDLIN( 371)				 ::Dynamic _g3 = 36;
HXDLIN( 371)				while(::hx::IsLess( _g2,_g3 )){
HXLINE( 371)					_g2 = (_g2 + 1);
HXDLIN( 371)					int i = (_g2 - 1);
HXDLIN( 371)					bx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 371)					by1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 371)					theta1 = (theta1 + step1);
HXDLIN( 371)					cx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 371)					cy1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 371)					::cornerContour::IPen_obj::triangle2DFill(this->pen,prevx_,prevy_,bx1,by1,cx1,cy1,color1);
            				}
            			}
            		}
HXLINE( 372)		{
HXLINE( 372)			Float ax = this->jx;
HXDLIN( 372)			Float ay = this->jy;
HXDLIN( 372)			int color2 = this->debugCol5;
HXDLIN( 372)			Float pi2 = ::Math_obj::PI;
HXDLIN( 372)			Float theta2 = (pi2 / ( (Float)(2) ));
HXDLIN( 372)			Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 372)			Float bx2;
HXDLIN( 372)			Float by2;
HXDLIN( 372)			Float cx2;
HXDLIN( 372)			Float cy2;
HXDLIN( 372)			{
HXLINE( 372)				int _g4 = 0;
HXDLIN( 372)				 ::Dynamic _g5 = 36;
HXDLIN( 372)				while(::hx::IsLess( _g4,_g5 )){
HXLINE( 372)					_g4 = (_g4 + 1);
HXDLIN( 372)					int i = (_g4 - 1);
HXDLIN( 372)					bx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 372)					by2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 372)					theta2 = (theta2 + step2);
HXDLIN( 372)					cx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 372)					cy2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 372)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx2,by2,cx2,cy2,color2);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Contour_obj,triangle2DFillangleCornersLess,(void))

void Contour_obj::connectQuadsWhenQuadsOverlay(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_377_connectQuadsWhenQuadsOverlay)
HXDLIN( 377)		if (clockWise) {
HXLINE( 378)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),this->ax,this->ay,-1);
            		}
            		else {
HXLINE( 383)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->ax,this->ay,-1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,connectQuadsWhenQuadsOverlay,(void))

void Contour_obj::connectQuads(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_392_connectQuads)
HXDLIN( 392)		if (clockWise) {
HXLINE( 393)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),this->jx,this->jy,-1);
            		}
            		else {
HXLINE( 398)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->jx,this->jy,-1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,connectQuads,(void))

void Contour_obj::addInitialQuads(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_407_addInitialQuads)
HXLINE( 410)		this->quadIndex = ::cornerContour::IPen_obj::get_pos(this->pen);
HXLINE( 412)		if ((this->count == 0)) {
HXLINE( 413)			this->penultimateAX = ( (Float)(this->dxPrev) );
HXLINE( 414)			this->penultimateAY = ( (Float)(this->dyPrev) );
HXLINE( 415)			this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 416)			this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 417)			this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 418)			this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 419)			this->lastClockX = ( (Float)(this->exPrev) );
HXLINE( 420)			this->lastClockY = ( (Float)(this->eyPrev) );
HXLINE( 421)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXLINE( 423)			::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            		}
            		else {
HXLINE( 426)			bool _hx_tmp;
HXDLIN( 426)			if (clockWise) {
HXLINE( 426)				_hx_tmp = !(this->lastClock);
            			}
            			else {
HXLINE( 426)				_hx_tmp = false;
            			}
HXDLIN( 426)			if (_hx_tmp) {
HXLINE( 427)				this->penultimateAX = this->jx;
HXLINE( 428)				this->penultimateAY = this->jy;
HXLINE( 429)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 430)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 431)				this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 432)				this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 433)				this->lastClockX = ( (Float)(this->exPrev) );
HXLINE( 434)				this->lastClockY = ( (Float)(this->eyPrev) );
HXLINE( 436)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXLINE( 438)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            			}
HXLINE( 441)			bool _hx_tmp1;
HXDLIN( 441)			if (clockWise) {
HXLINE( 441)				_hx_tmp1 = this->lastClock;
            			}
            			else {
HXLINE( 441)				_hx_tmp1 = false;
            			}
HXDLIN( 441)			if (_hx_tmp1) {
HXLINE( 442)				this->penultimateAX = this->jx;
HXLINE( 443)				this->penultimateAY = this->jy;
HXLINE( 444)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 445)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 446)				this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 447)				this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 448)				this->lastClockX = ( (Float)(this->exPrev) );
HXLINE( 449)				this->lastClockY = ( (Float)(this->eyPrev) );
HXLINE( 451)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXLINE( 453)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),-1);
            			}
HXLINE( 456)			bool _hx_tmp2;
HXDLIN( 456)			if (!(clockWise)) {
HXLINE( 456)				_hx_tmp2 = !(this->lastClock);
            			}
            			else {
HXLINE( 456)				_hx_tmp2 = false;
            			}
HXDLIN( 456)			if (_hx_tmp2) {
HXLINE( 457)				this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 458)				this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 459)				this->lastClockX = this->jx;
HXLINE( 460)				this->lastClockY = this->jy;
HXLINE( 461)				this->penultimateAX = ( (Float)(this->dxPrev) );
HXLINE( 462)				this->penultimateAY = ( (Float)(this->dyPrev) );
HXLINE( 463)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 464)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 466)				::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),this->jx,this->jy,-1);
HXLINE( 468)				::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
            			}
HXLINE( 471)			bool _hx_tmp3;
HXDLIN( 471)			if (!(clockWise)) {
HXLINE( 471)				_hx_tmp3 = this->lastClock;
            			}
            			else {
HXLINE( 471)				_hx_tmp3 = false;
            			}
HXDLIN( 471)			if (_hx_tmp3) {
HXLINE( 472)				this->penultimateAX = ( (Float)(this->dxPrev) );
HXLINE( 473)				this->penultimateAY = ( (Float)(this->dyPrev) );
HXLINE( 474)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 475)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 477)				this->penultimateCX = this->jx;
HXLINE( 478)				this->penultimateCY = this->jy;
HXLINE( 479)				this->lastClockX = ( (Float)(this->dx) );
HXLINE( 480)				this->lastClockY = ( (Float)(this->dy) );
HXLINE( 482)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jx,this->jy,( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
HXLINE( 484)				::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),this->jx,this->jy,( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,addInitialQuads,(void))

void Contour_obj::endEdges(){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_490_endEdges)
HXLINE( 491)		int pC = this->pointsClock->length;
HXLINE( 492)		int pA = this->pointsAnti->length;
HXLINE( 493)		pC = (pC + 1);
HXDLIN( 493)		this->pointsClock[(pC - 1)] = this->penultimateCX;
HXLINE( 494)		pC = (pC + 1);
HXDLIN( 494)		this->pointsClock[(pC - 1)] = this->penultimateCY;
HXLINE( 495)		pC = (pC + 1);
HXDLIN( 495)		this->pointsClock[(pC - 1)] = this->lastClockX;
HXLINE( 496)		pC = (pC + 1);
HXDLIN( 496)		this->pointsClock[(pC - 1)] = this->lastClockY;
HXLINE( 497)		pA = (pA + 1);
HXDLIN( 497)		this->pointsAnti[(pA - 1)] = this->penultimateAX;
HXLINE( 498)		pA = (pA + 1);
HXDLIN( 498)		this->pointsAnti[(pA - 1)] = this->penultimateAY;
HXLINE( 499)		pA = (pA + 1);
HXDLIN( 499)		this->pointsAnti[(pA - 1)] = this->lastAntiX;
HXLINE( 500)		pA = (pA + 1);
HXDLIN( 500)		this->pointsAnti[(pA - 1)] = this->lastAntiY;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,endEdges,(void))

void Contour_obj::addQuads(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_516_addQuads)
HXLINE( 522)		Float currQuadIndex = ::cornerContour::IPen_obj::get_pos(this->pen);
HXLINE( 524)		int pC = 0;
HXLINE( 525)		int pA = 0;
HXLINE( 526)		bool _hx_tmp;
HXDLIN( 526)		if (clockWise) {
HXLINE( 526)			_hx_tmp = !(this->lastClock);
            		}
            		else {
HXLINE( 526)			_hx_tmp = false;
            		}
HXDLIN( 526)		if (_hx_tmp) {
HXLINE( 527)			if ((this->count == 1)) {
HXLINE( 528)				pA = this->pointsAnti->length;
HXLINE( 529)				pA = (pA + 1);
HXDLIN( 529)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 530)				pA = (pA + 1);
HXDLIN( 530)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 531)				pA = (pA + 1);
HXDLIN( 531)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 532)				pA = (pA + 1);
HXDLIN( 532)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 533)				pC = this->pointsClock->length;
HXLINE( 534)				pC = (pC + 1);
HXDLIN( 534)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 535)				pC = (pC + 1);
HXDLIN( 535)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 536)				pC = (pC + 1);
HXDLIN( 536)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 537)				pC = (pC + 1);
HXDLIN( 537)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 539)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 540)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->kbx,this->kby,this->ncx,this->ncy,-1);
            			}
            			else {
HXLINE( 544)				pA = this->pointsAnti->length;
HXLINE( 545)				pA = (pA + 1);
HXDLIN( 545)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 546)				pA = (pA + 1);
HXDLIN( 546)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 547)				pA = (pA + 1);
HXDLIN( 547)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 548)				pA = (pA + 1);
HXDLIN( 548)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 549)				pC = this->pointsClock->length;
HXLINE( 550)				pC = (pC + 1);
HXDLIN( 550)				this->pointsClock[(pC - 1)] = this->jxOld;
HXLINE( 551)				pC = (pC + 1);
HXDLIN( 551)				this->pointsClock[(pC - 1)] = this->jyOld;
HXLINE( 552)				pC = (pC + 1);
HXDLIN( 552)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 553)				pC = (pC + 1);
HXDLIN( 553)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 555)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 556)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->kbx,this->kby,this->jxOld,this->jyOld,-1);
            			}
HXLINE( 560)			::cornerContour::IPen_obj::set_pos(this->pen,this->quadIndex);
HXLINE( 561)			::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->kbx,this->kby,this->jx,this->jy,-1);
            		}
HXLINE( 565)		bool _hx_tmp1;
HXDLIN( 565)		if (clockWise) {
HXLINE( 565)			_hx_tmp1 = this->lastClock;
            		}
            		else {
HXLINE( 565)			_hx_tmp1 = false;
            		}
HXDLIN( 565)		if (_hx_tmp1) {
HXLINE( 566)			if ((this->count == 1)) {
HXLINE( 568)				pA = this->pointsAnti->length;
HXLINE( 569)				pA = (pA + 1);
HXDLIN( 569)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 570)				pA = (pA + 1);
HXDLIN( 570)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 571)				pA = (pA + 1);
HXDLIN( 571)				this->pointsAnti[(pA - 1)] = this->kbx;
HXLINE( 572)				pA = (pA + 1);
HXDLIN( 572)				this->pointsAnti[(pA - 1)] = this->kby;
HXLINE( 573)				pC = this->pointsClock->length;
HXLINE( 574)				pC = (pC + 1);
HXDLIN( 574)				this->pointsClock[(pC - 1)] = this->kax;
HXLINE( 575)				pC = (pC + 1);
HXDLIN( 575)				this->pointsClock[(pC - 1)] = this->kay;
HXLINE( 576)				pC = (pC + 1);
HXDLIN( 576)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 577)				pC = (pC + 1);
HXDLIN( 577)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 579)				::cornerContour::IPen_obj::set_pos(this->pen,this->quadIndex);
HXLINE( 580)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->kbx,this->kby,this->jx,this->jy,-1);
HXLINE( 581)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 582)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->kbx,this->kby,this->ncx,this->ncy,-1);
            			}
            			else {
HXLINE( 585)				pA = this->pointsAnti->length;
HXLINE( 586)				pA = (pA + 1);
HXDLIN( 586)				this->pointsAnti[(pA - 1)] = this->jxOld;
HXLINE( 587)				pA = (pA + 1);
HXDLIN( 587)				this->pointsAnti[(pA - 1)] = this->jyOld;
HXLINE( 588)				pA = (pA + 1);
HXDLIN( 588)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 589)				pA = (pA + 1);
HXDLIN( 589)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 590)				pC = this->pointsClock->length;
HXLINE( 591)				pC = (pC + 1);
HXDLIN( 591)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 592)				pC = (pC + 1);
HXDLIN( 592)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 593)				pC = (pC + 1);
HXDLIN( 593)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 594)				pC = (pC + 1);
HXDLIN( 594)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 596)				::cornerContour::IPen_obj::set_pos(this->pen,this->quadIndex);
HXLINE( 597)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jxOld,this->jyOld,this->kbx,this->kby,this->jx,this->jy,-1);
HXLINE( 599)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 600)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jxOld,this->jyOld,this->kbx,this->kby,this->ncx,this->ncy,-1);
            			}
            		}
HXLINE( 608)		bool _hx_tmp2;
HXDLIN( 608)		if (!(clockWise)) {
HXLINE( 608)			_hx_tmp2 = !(this->lastClock);
            		}
            		else {
HXLINE( 608)			_hx_tmp2 = false;
            		}
HXDLIN( 608)		if (_hx_tmp2) {
HXLINE( 610)			::cornerContour::IPen_obj::set_pos(this->pen,this->quadIndex);
HXLINE( 611)			::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->jx,this->jy,this->kcx,this->kcy,-1);
HXLINE( 614)			if ((this->count == 1)) {
HXLINE( 615)				pA = this->pointsAnti->length;
HXLINE( 616)				pA = (pA + 1);
HXDLIN( 616)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 617)				pA = (pA + 1);
HXDLIN( 617)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 618)				pA = (pA + 1);
HXDLIN( 618)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 619)				pA = (pA + 1);
HXDLIN( 619)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 620)				pC = this->pointsClock->length;
HXLINE( 621)				pC = (pC + 1);
HXDLIN( 621)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 622)				pC = (pC + 1);
HXDLIN( 622)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 623)				pC = (pC + 1);
HXDLIN( 623)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 624)				pC = (pC + 1);
HXDLIN( 624)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 625)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 626)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->jx,this->jy,this->ncx,this->ncy,-1);
            			}
            			else {
HXLINE( 629)				pA = this->pointsAnti->length;
HXLINE( 630)				pA = (pA + 1);
HXDLIN( 630)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 631)				pA = (pA + 1);
HXDLIN( 631)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 632)				pA = (pA + 1);
HXDLIN( 632)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 633)				pA = (pA + 1);
HXDLIN( 633)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 634)				pC = this->pointsClock->length;
HXLINE( 635)				pC = (pC + 1);
HXDLIN( 635)				this->pointsClock[(pC - 1)] = this->jxOld;
HXLINE( 636)				pC = (pC + 1);
HXDLIN( 636)				this->pointsClock[(pC - 1)] = this->jyOld;
HXLINE( 637)				pC = (pC + 1);
HXDLIN( 637)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 638)				pC = (pC + 1);
HXDLIN( 638)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 639)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 640)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->jx,this->jy,this->jxOld,this->jyOld,-1);
            			}
            		}
HXLINE( 645)		bool _hx_tmp3;
HXDLIN( 645)		if (!(clockWise)) {
HXLINE( 645)			_hx_tmp3 = this->lastClock;
            		}
            		else {
HXLINE( 645)			_hx_tmp3 = false;
            		}
HXDLIN( 645)		if (_hx_tmp3) {
HXLINE( 646)			if ((this->count == 1)) {
HXLINE( 647)				pA = this->pointsAnti->length;
HXLINE( 648)				pA = (pA + 1);
HXDLIN( 648)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 649)				pA = (pA + 1);
HXDLIN( 649)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 650)				pA = (pA + 1);
HXDLIN( 650)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 651)				pA = (pA + 1);
HXDLIN( 651)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 652)				pC = this->pointsClock->length;
HXLINE( 653)				pC = (pC + 1);
HXDLIN( 653)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 654)				pC = (pC + 1);
HXDLIN( 654)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 655)				pC = (pC + 1);
HXDLIN( 655)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 656)				pC = (pC + 1);
HXDLIN( 656)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 657)				::cornerContour::IPen_obj::set_pos(this->pen,this->quadIndex);
HXLINE( 658)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->jx,this->jy,this->kcx,this->kcy,-1);
HXLINE( 659)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 660)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->kax,this->kay,this->jx,this->jy,this->ncx,this->ncy,-1);
            			}
            			else {
HXLINE( 662)				pA = this->pointsAnti->length;
HXLINE( 663)				pA = (pA + 1);
HXDLIN( 663)				this->pointsAnti[(pA - 1)] = this->jxOld;
HXLINE( 664)				pA = (pA + 1);
HXDLIN( 664)				this->pointsAnti[(pA - 1)] = this->jyOld;
HXLINE( 665)				pA = (pA + 1);
HXDLIN( 665)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 666)				pA = (pA + 1);
HXDLIN( 666)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 667)				pC = this->pointsClock->length;
HXLINE( 668)				pC = (pC + 1);
HXDLIN( 668)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 669)				pC = (pC + 1);
HXDLIN( 669)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 670)				pC = (pC + 1);
HXDLIN( 670)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 671)				pC = (pC + 1);
HXDLIN( 671)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 672)				::cornerContour::IPen_obj::set_pos(this->pen,this->quadIndex);
HXLINE( 673)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jxOld,this->jyOld,this->jx,this->jy,this->kcx,this->kcy,-1);
HXLINE( 674)				::cornerContour::IPen_obj::set_pos(this->pen,(this->quadIndex + 1));
HXLINE( 675)				::cornerContour::IPen_obj::triangle2DFill(this->pen,this->jxOld,this->jyOld,this->jx,this->jy,this->ncx,this->ncy,-1);
            			}
            		}
HXLINE( 679)		::cornerContour::IPen_obj::set_pos(this->pen,currQuadIndex);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,addQuads,(void))

void Contour_obj::storeLastQuads(){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_682_storeLastQuads)
HXLINE( 683)		this->kax = ( (Float)(this->dxPrev) );
HXLINE( 684)		this->kay = ( (Float)(this->dyPrev) );
HXLINE( 685)		this->kbx = ( (Float)(this->dx) );
HXLINE( 686)		this->kby = ( (Float)(this->dy) );
HXLINE( 687)		this->ncx = ( (Float)(this->exPrev) );
HXLINE( 688)		this->ncy = ( (Float)(this->eyPrev) );
HXLINE( 689)		this->kcx = ( (Float)(this->ex) );
HXLINE( 690)		this->kcy = ( (Float)(this->ey) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,storeLastQuads,(void))

bool Contour_obj::isClockwise(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_693_isClockwise)
HXDLIN( 693)		Float x1 = (( (Float)(this->dxOld) ) - x);
HXDLIN( 693)		Float y1 = (( (Float)(this->dyOld) ) - y);
HXDLIN( 693)		Float x2 = (( (Float)(this->exOld) ) - x);
HXDLIN( 693)		Float y2 = (( (Float)(this->eyOld) ) - y);
HXDLIN( 693)		return (((x1 * x1) + (y1 * y1)) > ((x2 * x2) + (y2 * y2)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,isClockwise,return )

void Contour_obj::line(Float ax_,Float ay_,Float bx_,Float by_,Float width_, ::Dynamic __o_endLineCurve){
            		 ::Dynamic endLineCurve = __o_endLineCurve;
            		if (::hx::IsNull(__o_endLineCurve)) endLineCurve = 0;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_697_line)
HXLINE( 699)		this->ax = bx_;
HXLINE( 700)		this->ay = by_;
HXLINE( 701)		this->bx = ax_;
HXLINE( 702)		this->by = ay_;
HXLINE( 703)		this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXLINE( 705)		this->beta = ((::Math_obj::PI / ( (Float)(2) )) - this->halfA);
HXLINE( 706)		this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(this->beta));
HXLINE( 708)		{
HXLINE( 708)			{
HXLINE( 708)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 708)				if ((this->theta > 0)) {
HXLINE( 708)					if ((this->halfA < 0)) {
HXLINE( 708)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 708)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 708)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 708)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 708)					if ((this->halfA > 0)) {
HXLINE( 708)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 708)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 708)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 708)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 708)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 708)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 708)				this->exOld = this->exPrev;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 708)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 708)				this->dxPrev = this->dx;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 708)				this->dyPrev = this->dy;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 708)				this->exPrev = this->ex;
            			}
HXDLIN( 708)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 708)				this->eyPrev = this->ey;
            			}
HXDLIN( 708)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 708)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 708)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 708)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 709)		 ::Dynamic dxPrev_ = this->dx;
HXLINE( 710)		 ::Dynamic dyPrev_ = this->dy;
HXLINE( 711)		 ::Dynamic exPrev_ = this->ex;
HXLINE( 712)		 ::Dynamic eyPrev_ = this->ey;
HXLINE( 714)		this->ax = ax_;
HXLINE( 715)		this->ay = ay_;
HXLINE( 716)		this->bx = bx_;
HXLINE( 717)		this->by = by_;
HXLINE( 718)		{
HXLINE( 718)			{
HXLINE( 718)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 718)				if ((this->theta > 0)) {
HXLINE( 718)					if ((this->halfA < 0)) {
HXLINE( 718)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 718)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 718)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 718)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 718)					if ((this->halfA > 0)) {
HXLINE( 718)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 718)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 718)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 718)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 718)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 718)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 718)				this->exOld = this->exPrev;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 718)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 718)				this->dxPrev = this->dx;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 718)				this->dyPrev = this->dy;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 718)				this->exPrev = this->ex;
            			}
HXDLIN( 718)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 718)				this->eyPrev = this->ey;
            			}
HXDLIN( 718)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 718)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 718)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 718)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 719)		 ::Dynamic _hx_switch_0 = endLineCurve;
            		if (  (_hx_switch_0==0) ){
HXLINE( 720)			goto _hx_goto_47;
            		}
            		if (  (_hx_switch_0==1) ){
HXLINE( 723)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 723)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 723)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 723)			{
HXLINE( 723)				int color = 0;
HXDLIN( 723)				 ::Dynamic sides = 36;
HXDLIN( 723)				if (::hx::IsNull( sides )) {
HXLINE( 723)					sides = 36;
            				}
HXDLIN( 723)				Float pi = ::Math_obj::PI;
HXDLIN( 723)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 723)				Float dif;
HXDLIN( 723)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 723)						Float f;
HXDLIN( 723)						bool f1;
HXDLIN( 723)						if ((beta >= 0)) {
HXLINE( 723)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f1 = false;
            						}
HXDLIN( 723)						if (f1) {
HXLINE( 723)							f = beta;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f = a;
            							}
            							else {
HXLINE( 723)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this1 = f;
HXDLIN( 723)						Float za = this1;
HXDLIN( 723)						Float f2;
HXDLIN( 723)						bool f3;
HXDLIN( 723)						if ((gamma >= 0)) {
HXLINE( 723)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f3 = false;
            						}
HXDLIN( 723)						if (f3) {
HXLINE( 723)							f2 = gamma;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f2 = a;
            							}
            							else {
HXLINE( 723)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this2 = f2;
HXDLIN( 723)						Float zb = this2;
HXDLIN( 723)						Float fa = za;
HXDLIN( 723)						Float fb = zb;
HXDLIN( 723)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 723)						bool clockwise = (fa < fb);
HXDLIN( 723)						Float dif1;
HXDLIN( 723)						if (clockwise) {
HXLINE( 723)							dif1 = theta;
            						}
            						else {
HXLINE( 723)							dif1 = -(theta);
            						}
HXDLIN( 723)						if ((dif1 > 0)) {
HXLINE( 723)							dif = dif1;
            						}
            						else {
HXLINE( 723)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 723)						Float f;
HXDLIN( 723)						bool f1;
HXDLIN( 723)						if ((beta >= 0)) {
HXLINE( 723)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f1 = false;
            						}
HXDLIN( 723)						if (f1) {
HXLINE( 723)							f = beta;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f = a;
            							}
            							else {
HXLINE( 723)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this1 = f;
HXDLIN( 723)						Float za = this1;
HXDLIN( 723)						Float f2;
HXDLIN( 723)						bool f3;
HXDLIN( 723)						if ((gamma >= 0)) {
HXLINE( 723)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f3 = false;
            						}
HXDLIN( 723)						if (f3) {
HXLINE( 723)							f2 = gamma;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f2 = a;
            							}
            							else {
HXLINE( 723)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this2 = f2;
HXDLIN( 723)						Float zb = this2;
HXDLIN( 723)						Float fa = za;
HXDLIN( 723)						Float fb = zb;
HXDLIN( 723)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 723)						bool clockwise = (fa < fb);
HXDLIN( 723)						Float dif1;
HXDLIN( 723)						if (clockwise) {
HXLINE( 723)							dif1 = theta;
            						}
            						else {
HXLINE( 723)							dif1 = -(theta);
            						}
HXDLIN( 723)						if ((dif1 < 0)) {
HXLINE( 723)							dif = dif1;
            						}
            						else {
HXLINE( 723)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 723)						Float f;
HXDLIN( 723)						bool f1;
HXDLIN( 723)						if ((beta >= 0)) {
HXLINE( 723)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f1 = false;
            						}
HXDLIN( 723)						if (f1) {
HXLINE( 723)							f = beta;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f = a;
            							}
            							else {
HXLINE( 723)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this1 = f;
HXDLIN( 723)						Float za = this1;
HXDLIN( 723)						Float f2;
HXDLIN( 723)						bool f3;
HXDLIN( 723)						if ((gamma >= 0)) {
HXLINE( 723)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f3 = false;
            						}
HXDLIN( 723)						if (f3) {
HXLINE( 723)							f2 = gamma;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f2 = a;
            							}
            							else {
HXLINE( 723)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this2 = f2;
HXDLIN( 723)						Float zb = this2;
HXDLIN( 723)						Float fa = za;
HXDLIN( 723)						Float fb = zb;
HXDLIN( 723)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 723)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 723)						bool clockwise = (fa < fb);
HXDLIN( 723)						Float dif1;
HXDLIN( 723)						if (clockwise) {
HXLINE( 723)							dif1 = theta;
            						}
            						else {
HXLINE( 723)							dif1 = -(theta);
            						}
HXDLIN( 723)						if (smallest) {
HXLINE( 723)							dif = dif1;
            						}
            						else {
HXLINE( 723)							if (clockwise) {
HXLINE( 723)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 723)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 723)						Float f;
HXDLIN( 723)						bool f1;
HXDLIN( 723)						if ((beta >= 0)) {
HXLINE( 723)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f1 = false;
            						}
HXDLIN( 723)						if (f1) {
HXLINE( 723)							f = beta;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f = a;
            							}
            							else {
HXLINE( 723)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this1 = f;
HXDLIN( 723)						Float za = this1;
HXDLIN( 723)						Float f2;
HXDLIN( 723)						bool f3;
HXDLIN( 723)						if ((gamma >= 0)) {
HXLINE( 723)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 723)							f3 = false;
            						}
HXDLIN( 723)						if (f3) {
HXLINE( 723)							f2 = gamma;
            						}
            						else {
HXLINE( 723)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 723)							if ((a >= 0)) {
HXLINE( 723)								f2 = a;
            							}
            							else {
HXLINE( 723)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 723)						Float this2 = f2;
HXDLIN( 723)						Float zb = this2;
HXDLIN( 723)						Float fa = za;
HXDLIN( 723)						Float fb = zb;
HXDLIN( 723)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 723)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 723)						bool clockwise = (fa < fb);
HXDLIN( 723)						Float dif1;
HXDLIN( 723)						if (clockwise) {
HXLINE( 723)							dif1 = theta;
            						}
            						else {
HXLINE( 723)							dif1 = -(theta);
            						}
HXDLIN( 723)						if (largest) {
HXLINE( 723)							dif = dif1;
            						}
            						else {
HXLINE( 723)							if (clockwise) {
HXLINE( 723)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 723)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 723)				bool positive = (dif >= 0);
HXDLIN( 723)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 723)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 723)				Float angle = beta;
HXDLIN( 723)				Float cx;
HXDLIN( 723)				Float cy;
HXDLIN( 723)				Float bx = ( (Float)(0) );
HXDLIN( 723)				Float by = ( (Float)(0) );
HXDLIN( 723)				{
HXLINE( 723)					int _g = 0;
HXDLIN( 723)					int _g1 = (totalSteps + 1);
HXDLIN( 723)					while((_g < _g1)){
HXLINE( 723)						_g = (_g + 1);
HXDLIN( 723)						int i = (_g - 1);
HXDLIN( 723)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 723)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 723)						if ((i != 0)) {
HXLINE( 723)							::cornerContour::IPen_obj::triangle2DFill(this->pen,ax_,ay_,bx,by,cx,cy,color);
            						}
HXDLIN( 723)						angle = (angle + step1);
HXDLIN( 723)						bx = cx;
HXDLIN( 723)						by = cy;
            					}
            				}
            			}
HXDLIN( 723)			goto _hx_goto_47;
            		}
            		if (  (_hx_switch_0==2) ){
HXLINE( 726)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 726)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 726)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 726)			{
HXLINE( 726)				int color = 0;
HXDLIN( 726)				 ::Dynamic sides = 36;
HXDLIN( 726)				if (::hx::IsNull( sides )) {
HXLINE( 726)					sides = 36;
            				}
HXDLIN( 726)				Float pi = ::Math_obj::PI;
HXDLIN( 726)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 726)				Float dif;
HXDLIN( 726)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 726)						Float f;
HXDLIN( 726)						bool f1;
HXDLIN( 726)						if ((beta >= 0)) {
HXLINE( 726)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f1 = false;
            						}
HXDLIN( 726)						if (f1) {
HXLINE( 726)							f = beta;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f = a;
            							}
            							else {
HXLINE( 726)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this1 = f;
HXDLIN( 726)						Float za = this1;
HXDLIN( 726)						Float f2;
HXDLIN( 726)						bool f3;
HXDLIN( 726)						if ((gamma >= 0)) {
HXLINE( 726)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f3 = false;
            						}
HXDLIN( 726)						if (f3) {
HXLINE( 726)							f2 = gamma;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f2 = a;
            							}
            							else {
HXLINE( 726)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this2 = f2;
HXDLIN( 726)						Float zb = this2;
HXDLIN( 726)						Float fa = za;
HXDLIN( 726)						Float fb = zb;
HXDLIN( 726)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 726)						bool clockwise = (fa < fb);
HXDLIN( 726)						Float dif1;
HXDLIN( 726)						if (clockwise) {
HXLINE( 726)							dif1 = theta;
            						}
            						else {
HXLINE( 726)							dif1 = -(theta);
            						}
HXDLIN( 726)						if ((dif1 > 0)) {
HXLINE( 726)							dif = dif1;
            						}
            						else {
HXLINE( 726)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 726)						Float f;
HXDLIN( 726)						bool f1;
HXDLIN( 726)						if ((beta >= 0)) {
HXLINE( 726)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f1 = false;
            						}
HXDLIN( 726)						if (f1) {
HXLINE( 726)							f = beta;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f = a;
            							}
            							else {
HXLINE( 726)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this1 = f;
HXDLIN( 726)						Float za = this1;
HXDLIN( 726)						Float f2;
HXDLIN( 726)						bool f3;
HXDLIN( 726)						if ((gamma >= 0)) {
HXLINE( 726)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f3 = false;
            						}
HXDLIN( 726)						if (f3) {
HXLINE( 726)							f2 = gamma;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f2 = a;
            							}
            							else {
HXLINE( 726)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this2 = f2;
HXDLIN( 726)						Float zb = this2;
HXDLIN( 726)						Float fa = za;
HXDLIN( 726)						Float fb = zb;
HXDLIN( 726)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 726)						bool clockwise = (fa < fb);
HXDLIN( 726)						Float dif1;
HXDLIN( 726)						if (clockwise) {
HXLINE( 726)							dif1 = theta;
            						}
            						else {
HXLINE( 726)							dif1 = -(theta);
            						}
HXDLIN( 726)						if ((dif1 < 0)) {
HXLINE( 726)							dif = dif1;
            						}
            						else {
HXLINE( 726)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 726)						Float f;
HXDLIN( 726)						bool f1;
HXDLIN( 726)						if ((beta >= 0)) {
HXLINE( 726)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f1 = false;
            						}
HXDLIN( 726)						if (f1) {
HXLINE( 726)							f = beta;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f = a;
            							}
            							else {
HXLINE( 726)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this1 = f;
HXDLIN( 726)						Float za = this1;
HXDLIN( 726)						Float f2;
HXDLIN( 726)						bool f3;
HXDLIN( 726)						if ((gamma >= 0)) {
HXLINE( 726)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f3 = false;
            						}
HXDLIN( 726)						if (f3) {
HXLINE( 726)							f2 = gamma;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f2 = a;
            							}
            							else {
HXLINE( 726)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this2 = f2;
HXDLIN( 726)						Float zb = this2;
HXDLIN( 726)						Float fa = za;
HXDLIN( 726)						Float fb = zb;
HXDLIN( 726)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 726)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 726)						bool clockwise = (fa < fb);
HXDLIN( 726)						Float dif1;
HXDLIN( 726)						if (clockwise) {
HXLINE( 726)							dif1 = theta;
            						}
            						else {
HXLINE( 726)							dif1 = -(theta);
            						}
HXDLIN( 726)						if (smallest) {
HXLINE( 726)							dif = dif1;
            						}
            						else {
HXLINE( 726)							if (clockwise) {
HXLINE( 726)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 726)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 726)						Float f;
HXDLIN( 726)						bool f1;
HXDLIN( 726)						if ((beta >= 0)) {
HXLINE( 726)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f1 = false;
            						}
HXDLIN( 726)						if (f1) {
HXLINE( 726)							f = beta;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f = a;
            							}
            							else {
HXLINE( 726)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this1 = f;
HXDLIN( 726)						Float za = this1;
HXDLIN( 726)						Float f2;
HXDLIN( 726)						bool f3;
HXDLIN( 726)						if ((gamma >= 0)) {
HXLINE( 726)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 726)							f3 = false;
            						}
HXDLIN( 726)						if (f3) {
HXLINE( 726)							f2 = gamma;
            						}
            						else {
HXLINE( 726)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 726)							if ((a >= 0)) {
HXLINE( 726)								f2 = a;
            							}
            							else {
HXLINE( 726)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 726)						Float this2 = f2;
HXDLIN( 726)						Float zb = this2;
HXDLIN( 726)						Float fa = za;
HXDLIN( 726)						Float fb = zb;
HXDLIN( 726)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 726)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 726)						bool clockwise = (fa < fb);
HXDLIN( 726)						Float dif1;
HXDLIN( 726)						if (clockwise) {
HXLINE( 726)							dif1 = theta;
            						}
            						else {
HXLINE( 726)							dif1 = -(theta);
            						}
HXDLIN( 726)						if (largest) {
HXLINE( 726)							dif = dif1;
            						}
            						else {
HXLINE( 726)							if (clockwise) {
HXLINE( 726)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 726)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 726)				bool positive = (dif >= 0);
HXDLIN( 726)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 726)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 726)				Float angle = beta;
HXDLIN( 726)				Float cx;
HXDLIN( 726)				Float cy;
HXDLIN( 726)				Float bx = ( (Float)(0) );
HXDLIN( 726)				Float by = ( (Float)(0) );
HXDLIN( 726)				{
HXLINE( 726)					int _g = 0;
HXDLIN( 726)					int _g1 = (totalSteps + 1);
HXDLIN( 726)					while((_g < _g1)){
HXLINE( 726)						_g = (_g + 1);
HXDLIN( 726)						int i = (_g - 1);
HXDLIN( 726)						cx = (bx_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 726)						cy = (by_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 726)						if ((i != 0)) {
HXLINE( 726)							::cornerContour::IPen_obj::triangle2DFill(this->pen,bx_,by_,bx,by,cx,cy,color);
            						}
HXDLIN( 726)						angle = (angle + step1);
HXDLIN( 726)						bx = cx;
HXDLIN( 726)						by = cy;
            					}
            				}
            			}
HXDLIN( 726)			goto _hx_goto_47;
            		}
            		if (  (_hx_switch_0==3) ){
HXLINE( 728)			{
HXLINE( 728)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 728)				Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 728)				Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 728)				{
HXLINE( 728)					int color = 0;
HXDLIN( 728)					 ::Dynamic sides = 36;
HXDLIN( 728)					if (::hx::IsNull( sides )) {
HXLINE( 728)						sides = 36;
            					}
HXDLIN( 728)					Float pi = ::Math_obj::PI;
HXDLIN( 728)					Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 728)					Float dif;
HXDLIN( 728)					switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            						case (int)0: {
HXLINE( 728)							Float f;
HXDLIN( 728)							bool f1;
HXDLIN( 728)							if ((beta >= 0)) {
HXLINE( 728)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f1 = false;
            							}
HXDLIN( 728)							if (f1) {
HXLINE( 728)								f = beta;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f = a;
            								}
            								else {
HXLINE( 728)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this1 = f;
HXDLIN( 728)							Float za = this1;
HXDLIN( 728)							Float f2;
HXDLIN( 728)							bool f3;
HXDLIN( 728)							if ((gamma >= 0)) {
HXLINE( 728)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f3 = false;
            							}
HXDLIN( 728)							if (f3) {
HXLINE( 728)								f2 = gamma;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f2 = a;
            								}
            								else {
HXLINE( 728)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this2 = f2;
HXDLIN( 728)							Float zb = this2;
HXDLIN( 728)							Float fa = za;
HXDLIN( 728)							Float fb = zb;
HXDLIN( 728)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 728)							bool clockwise = (fa < fb);
HXDLIN( 728)							Float dif1;
HXDLIN( 728)							if (clockwise) {
HXLINE( 728)								dif1 = theta;
            							}
            							else {
HXLINE( 728)								dif1 = -(theta);
            							}
HXDLIN( 728)							if ((dif1 > 0)) {
HXLINE( 728)								dif = dif1;
            							}
            							else {
HXLINE( 728)								dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            							}
            						}
            						break;
            						case (int)1: {
HXLINE( 728)							Float f;
HXDLIN( 728)							bool f1;
HXDLIN( 728)							if ((beta >= 0)) {
HXLINE( 728)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f1 = false;
            							}
HXDLIN( 728)							if (f1) {
HXLINE( 728)								f = beta;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f = a;
            								}
            								else {
HXLINE( 728)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this1 = f;
HXDLIN( 728)							Float za = this1;
HXDLIN( 728)							Float f2;
HXDLIN( 728)							bool f3;
HXDLIN( 728)							if ((gamma >= 0)) {
HXLINE( 728)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f3 = false;
            							}
HXDLIN( 728)							if (f3) {
HXLINE( 728)								f2 = gamma;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f2 = a;
            								}
            								else {
HXLINE( 728)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this2 = f2;
HXDLIN( 728)							Float zb = this2;
HXDLIN( 728)							Float fa = za;
HXDLIN( 728)							Float fb = zb;
HXDLIN( 728)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 728)							bool clockwise = (fa < fb);
HXDLIN( 728)							Float dif1;
HXDLIN( 728)							if (clockwise) {
HXLINE( 728)								dif1 = theta;
            							}
            							else {
HXLINE( 728)								dif1 = -(theta);
            							}
HXDLIN( 728)							if ((dif1 < 0)) {
HXLINE( 728)								dif = dif1;
            							}
            							else {
HXLINE( 728)								dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            							}
            						}
            						break;
            						case (int)2: {
HXLINE( 728)							Float f;
HXDLIN( 728)							bool f1;
HXDLIN( 728)							if ((beta >= 0)) {
HXLINE( 728)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f1 = false;
            							}
HXDLIN( 728)							if (f1) {
HXLINE( 728)								f = beta;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f = a;
            								}
            								else {
HXLINE( 728)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this1 = f;
HXDLIN( 728)							Float za = this1;
HXDLIN( 728)							Float f2;
HXDLIN( 728)							bool f3;
HXDLIN( 728)							if ((gamma >= 0)) {
HXLINE( 728)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f3 = false;
            							}
HXDLIN( 728)							if (f3) {
HXLINE( 728)								f2 = gamma;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f2 = a;
            								}
            								else {
HXLINE( 728)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this2 = f2;
HXDLIN( 728)							Float zb = this2;
HXDLIN( 728)							Float fa = za;
HXDLIN( 728)							Float fb = zb;
HXDLIN( 728)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 728)							bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 728)							bool clockwise = (fa < fb);
HXDLIN( 728)							Float dif1;
HXDLIN( 728)							if (clockwise) {
HXLINE( 728)								dif1 = theta;
            							}
            							else {
HXLINE( 728)								dif1 = -(theta);
            							}
HXDLIN( 728)							if (smallest) {
HXLINE( 728)								dif = dif1;
            							}
            							else {
HXLINE( 728)								if (clockwise) {
HXLINE( 728)									dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXLINE( 728)									dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            						case (int)3: {
HXLINE( 728)							Float f;
HXDLIN( 728)							bool f1;
HXDLIN( 728)							if ((beta >= 0)) {
HXLINE( 728)								f1 = (beta > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f1 = false;
            							}
HXDLIN( 728)							if (f1) {
HXLINE( 728)								f = beta;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f = a;
            								}
            								else {
HXLINE( 728)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this1 = f;
HXDLIN( 728)							Float za = this1;
HXDLIN( 728)							Float f2;
HXDLIN( 728)							bool f3;
HXDLIN( 728)							if ((gamma >= 0)) {
HXLINE( 728)								f3 = (gamma > ::Math_obj::PI);
            							}
            							else {
HXLINE( 728)								f3 = false;
            							}
HXDLIN( 728)							if (f3) {
HXLINE( 728)								f2 = gamma;
            							}
            							else {
HXLINE( 728)								Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 728)								if ((a >= 0)) {
HXLINE( 728)									f2 = a;
            								}
            								else {
HXLINE( 728)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 728)							Float this2 = f2;
HXDLIN( 728)							Float zb = this2;
HXDLIN( 728)							Float fa = za;
HXDLIN( 728)							Float fb = zb;
HXDLIN( 728)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 728)							bool largest = (theta > ::Math_obj::PI);
HXDLIN( 728)							bool clockwise = (fa < fb);
HXDLIN( 728)							Float dif1;
HXDLIN( 728)							if (clockwise) {
HXLINE( 728)								dif1 = theta;
            							}
            							else {
HXLINE( 728)								dif1 = -(theta);
            							}
HXDLIN( 728)							if (largest) {
HXLINE( 728)								dif = dif1;
            							}
            							else {
HXLINE( 728)								if (clockwise) {
HXLINE( 728)									dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXLINE( 728)									dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            					}
HXDLIN( 728)					bool positive = (dif >= 0);
HXDLIN( 728)					int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 728)					Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 728)					Float angle = beta;
HXDLIN( 728)					Float cx;
HXDLIN( 728)					Float cy;
HXDLIN( 728)					Float bx = ( (Float)(0) );
HXDLIN( 728)					Float by = ( (Float)(0) );
HXDLIN( 728)					{
HXLINE( 728)						int _g = 0;
HXDLIN( 728)						int _g1 = (totalSteps + 1);
HXDLIN( 728)						while((_g < _g1)){
HXLINE( 728)							_g = (_g + 1);
HXDLIN( 728)							int i = (_g - 1);
HXDLIN( 728)							cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 728)							cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 728)							if ((i != 0)) {
HXLINE( 728)								::cornerContour::IPen_obj::triangle2DFill(this->pen,ax_,ay_,bx,by,cx,cy,color);
            							}
HXDLIN( 728)							angle = (angle + step1);
HXDLIN( 728)							bx = cx;
HXDLIN( 728)							by = cy;
            						}
            					}
            				}
            			}
HXLINE( 729)			{
HXLINE( 729)				Float radius1 = (width_ / ( (Float)(2) ));
HXDLIN( 729)				Float beta1 = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 729)				Float gamma1 = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 729)				{
HXLINE( 729)					int color1 = 0;
HXDLIN( 729)					 ::Dynamic sides1 = 36;
HXDLIN( 729)					if (::hx::IsNull( sides1 )) {
HXLINE( 729)						sides1 = 36;
            					}
HXDLIN( 729)					Float pi1 = ::Math_obj::PI;
HXDLIN( 729)					Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 729)					Float dif1;
HXDLIN( 729)					switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            						case (int)0: {
HXLINE( 729)							Float f;
HXDLIN( 729)							bool f1;
HXDLIN( 729)							if ((beta1 >= 0)) {
HXLINE( 729)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f1 = false;
            							}
HXDLIN( 729)							if (f1) {
HXLINE( 729)								f = beta1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f = a;
            								}
            								else {
HXLINE( 729)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this1 = f;
HXDLIN( 729)							Float za = this1;
HXDLIN( 729)							Float f2;
HXDLIN( 729)							bool f3;
HXDLIN( 729)							if ((gamma1 >= 0)) {
HXLINE( 729)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f3 = false;
            							}
HXDLIN( 729)							if (f3) {
HXLINE( 729)								f2 = gamma1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f2 = a;
            								}
            								else {
HXLINE( 729)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this2 = f2;
HXDLIN( 729)							Float zb = this2;
HXDLIN( 729)							Float fa = za;
HXDLIN( 729)							Float fb = zb;
HXDLIN( 729)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 729)							bool clockwise = (fa < fb);
HXDLIN( 729)							Float dif;
HXDLIN( 729)							if (clockwise) {
HXLINE( 729)								dif = theta;
            							}
            							else {
HXLINE( 729)								dif = -(theta);
            							}
HXDLIN( 729)							if ((dif > 0)) {
HXLINE( 729)								dif1 = dif;
            							}
            							else {
HXLINE( 729)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            							}
            						}
            						break;
            						case (int)1: {
HXLINE( 729)							Float f;
HXDLIN( 729)							bool f1;
HXDLIN( 729)							if ((beta1 >= 0)) {
HXLINE( 729)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f1 = false;
            							}
HXDLIN( 729)							if (f1) {
HXLINE( 729)								f = beta1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f = a;
            								}
            								else {
HXLINE( 729)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this1 = f;
HXDLIN( 729)							Float za = this1;
HXDLIN( 729)							Float f2;
HXDLIN( 729)							bool f3;
HXDLIN( 729)							if ((gamma1 >= 0)) {
HXLINE( 729)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f3 = false;
            							}
HXDLIN( 729)							if (f3) {
HXLINE( 729)								f2 = gamma1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f2 = a;
            								}
            								else {
HXLINE( 729)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this2 = f2;
HXDLIN( 729)							Float zb = this2;
HXDLIN( 729)							Float fa = za;
HXDLIN( 729)							Float fb = zb;
HXDLIN( 729)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 729)							bool clockwise = (fa < fb);
HXDLIN( 729)							Float dif;
HXDLIN( 729)							if (clockwise) {
HXLINE( 729)								dif = theta;
            							}
            							else {
HXLINE( 729)								dif = -(theta);
            							}
HXDLIN( 729)							if ((dif < 0)) {
HXLINE( 729)								dif1 = dif;
            							}
            							else {
HXLINE( 729)								dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            							}
            						}
            						break;
            						case (int)2: {
HXLINE( 729)							Float f;
HXDLIN( 729)							bool f1;
HXDLIN( 729)							if ((beta1 >= 0)) {
HXLINE( 729)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f1 = false;
            							}
HXDLIN( 729)							if (f1) {
HXLINE( 729)								f = beta1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f = a;
            								}
            								else {
HXLINE( 729)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this1 = f;
HXDLIN( 729)							Float za = this1;
HXDLIN( 729)							Float f2;
HXDLIN( 729)							bool f3;
HXDLIN( 729)							if ((gamma1 >= 0)) {
HXLINE( 729)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f3 = false;
            							}
HXDLIN( 729)							if (f3) {
HXLINE( 729)								f2 = gamma1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f2 = a;
            								}
            								else {
HXLINE( 729)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this2 = f2;
HXDLIN( 729)							Float zb = this2;
HXDLIN( 729)							Float fa = za;
HXDLIN( 729)							Float fb = zb;
HXDLIN( 729)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 729)							bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 729)							bool clockwise = (fa < fb);
HXDLIN( 729)							Float dif;
HXDLIN( 729)							if (clockwise) {
HXLINE( 729)								dif = theta;
            							}
            							else {
HXLINE( 729)								dif = -(theta);
            							}
HXDLIN( 729)							if (smallest) {
HXLINE( 729)								dif1 = dif;
            							}
            							else {
HXLINE( 729)								if (clockwise) {
HXLINE( 729)									dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXLINE( 729)									dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            						case (int)3: {
HXLINE( 729)							Float f;
HXDLIN( 729)							bool f1;
HXDLIN( 729)							if ((beta1 >= 0)) {
HXLINE( 729)								f1 = (beta1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f1 = false;
            							}
HXDLIN( 729)							if (f1) {
HXLINE( 729)								f = beta1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f = a;
            								}
            								else {
HXLINE( 729)									f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this1 = f;
HXDLIN( 729)							Float za = this1;
HXDLIN( 729)							Float f2;
HXDLIN( 729)							bool f3;
HXDLIN( 729)							if ((gamma1 >= 0)) {
HXLINE( 729)								f3 = (gamma1 > ::Math_obj::PI);
            							}
            							else {
HXLINE( 729)								f3 = false;
            							}
HXDLIN( 729)							if (f3) {
HXLINE( 729)								f2 = gamma1;
            							}
            							else {
HXLINE( 729)								Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 729)								if ((a >= 0)) {
HXLINE( 729)									f2 = a;
            								}
            								else {
HXLINE( 729)									f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            								}
            							}
HXDLIN( 729)							Float this2 = f2;
HXDLIN( 729)							Float zb = this2;
HXDLIN( 729)							Float fa = za;
HXDLIN( 729)							Float fb = zb;
HXDLIN( 729)							Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 729)							bool largest = (theta > ::Math_obj::PI);
HXDLIN( 729)							bool clockwise = (fa < fb);
HXDLIN( 729)							Float dif;
HXDLIN( 729)							if (clockwise) {
HXLINE( 729)								dif = theta;
            							}
            							else {
HXLINE( 729)								dif = -(theta);
            							}
HXDLIN( 729)							if (largest) {
HXLINE( 729)								dif1 = dif;
            							}
            							else {
HXLINE( 729)								if (clockwise) {
HXLINE( 729)									dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            								}
            								else {
HXLINE( 729)									dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            								}
            							}
            						}
            						break;
            					}
HXDLIN( 729)					bool positive1 = (dif1 >= 0);
HXDLIN( 729)					int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN( 729)					Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN( 729)					Float angle1 = beta1;
HXDLIN( 729)					Float cx1;
HXDLIN( 729)					Float cy1;
HXDLIN( 729)					Float bx1 = ( (Float)(0) );
HXDLIN( 729)					Float by1 = ( (Float)(0) );
HXDLIN( 729)					{
HXLINE( 729)						int _g2 = 0;
HXDLIN( 729)						int _g3 = (totalSteps1 + 1);
HXDLIN( 729)						while((_g2 < _g3)){
HXLINE( 729)							_g2 = (_g2 + 1);
HXDLIN( 729)							int i = (_g2 - 1);
HXDLIN( 729)							cx1 = (bx_ + (radius1 * ::Math_obj::sin(angle1)));
HXDLIN( 729)							cy1 = (by_ + (radius1 * ::Math_obj::cos(angle1)));
HXDLIN( 729)							if ((i != 0)) {
HXLINE( 729)								::cornerContour::IPen_obj::triangle2DFill(this->pen,bx_,by_,bx1,by1,cx1,cy1,color1);
            							}
HXDLIN( 729)							angle1 = (angle1 + step3);
HXDLIN( 729)							bx1 = cx1;
HXDLIN( 729)							by1 = cy1;
            						}
            					}
            				}
            			}
HXLINE( 727)			goto _hx_goto_47;
            		}
            		_hx_goto_47:;
HXLINE( 731)		::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(exPrev_) ),( (Float)(eyPrev_) ),-1);
HXLINE( 732)		::cornerContour::IPen_obj::triangle2DFill(this->pen,( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),( (Float)(this->dx) ),( (Float)(this->dy) ),( (Float)(this->ex) ),( (Float)(this->ey) ),-1);
            	}


HX_DEFINE_DYNAMIC_FUNC6(Contour_obj,line,(void))

int Contour_obj::circle(Float ax,Float ay,Float radius,::hx::Null< int >  __o_color, ::Dynamic __o_sides, ::Dynamic __o_omega){
            		int color = __o_color.Default(-1);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_738_circle)
HXLINE( 739)		Float pi = ::Math_obj::PI;
HXLINE( 740)		Float theta = ((pi / ( (Float)(2) )) + omega);
HXLINE( 741)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 742)		Float bx;
HXLINE( 743)		Float by;
HXLINE( 744)		Float cx;
HXLINE( 745)		Float cy;
HXLINE( 746)		{
HXLINE( 746)			int _g = 0;
HXDLIN( 746)			 ::Dynamic _g1 = sides;
HXDLIN( 746)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 746)				_g = (_g + 1);
HXDLIN( 746)				int i = (_g - 1);
HXLINE( 747)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 748)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 749)				theta = (theta + step);
HXLINE( 750)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 751)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 752)				::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            			}
            		}
HXLINE( 754)		return ( (int)(sides) );
            	}


HX_DEFINE_DYNAMIC_FUNC6(Contour_obj,circle,return )

int Contour_obj::pie(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer,::hx::Null< int >  __o_color, ::Dynamic __o_sides){
            		int color = __o_color.Default(-1);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_765_pie)
HXLINE( 767)		Float pi = ::Math_obj::PI;
HXLINE( 768)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 769)		Float dif;
HXDLIN( 769)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 769)				Float f;
HXDLIN( 769)				bool f1;
HXDLIN( 769)				if ((beta >= 0)) {
HXLINE( 769)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f1 = false;
            				}
HXDLIN( 769)				if (f1) {
HXLINE( 769)					f = beta;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f = a;
            					}
            					else {
HXLINE( 769)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this1 = f;
HXDLIN( 769)				Float za = this1;
HXDLIN( 769)				Float f2;
HXDLIN( 769)				bool f3;
HXDLIN( 769)				if ((gamma >= 0)) {
HXLINE( 769)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f3 = false;
            				}
HXDLIN( 769)				if (f3) {
HXLINE( 769)					f2 = gamma;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f2 = a;
            					}
            					else {
HXLINE( 769)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this2 = f2;
HXDLIN( 769)				Float zb = this2;
HXDLIN( 769)				Float fa = za;
HXDLIN( 769)				Float fb = zb;
HXDLIN( 769)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 769)				bool clockwise = (fa < fb);
HXDLIN( 769)				Float dif1;
HXDLIN( 769)				if (clockwise) {
HXLINE( 769)					dif1 = theta;
            				}
            				else {
HXLINE( 769)					dif1 = -(theta);
            				}
HXDLIN( 769)				if ((dif1 > 0)) {
HXLINE( 769)					dif = dif1;
            				}
            				else {
HXLINE( 769)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 769)				Float f;
HXDLIN( 769)				bool f1;
HXDLIN( 769)				if ((beta >= 0)) {
HXLINE( 769)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f1 = false;
            				}
HXDLIN( 769)				if (f1) {
HXLINE( 769)					f = beta;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f = a;
            					}
            					else {
HXLINE( 769)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this1 = f;
HXDLIN( 769)				Float za = this1;
HXDLIN( 769)				Float f2;
HXDLIN( 769)				bool f3;
HXDLIN( 769)				if ((gamma >= 0)) {
HXLINE( 769)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f3 = false;
            				}
HXDLIN( 769)				if (f3) {
HXLINE( 769)					f2 = gamma;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f2 = a;
            					}
            					else {
HXLINE( 769)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this2 = f2;
HXDLIN( 769)				Float zb = this2;
HXDLIN( 769)				Float fa = za;
HXDLIN( 769)				Float fb = zb;
HXDLIN( 769)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 769)				bool clockwise = (fa < fb);
HXDLIN( 769)				Float dif1;
HXDLIN( 769)				if (clockwise) {
HXLINE( 769)					dif1 = theta;
            				}
            				else {
HXLINE( 769)					dif1 = -(theta);
            				}
HXDLIN( 769)				if ((dif1 < 0)) {
HXLINE( 769)					dif = dif1;
            				}
            				else {
HXLINE( 769)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 769)				Float f;
HXDLIN( 769)				bool f1;
HXDLIN( 769)				if ((beta >= 0)) {
HXLINE( 769)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f1 = false;
            				}
HXDLIN( 769)				if (f1) {
HXLINE( 769)					f = beta;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f = a;
            					}
            					else {
HXLINE( 769)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this1 = f;
HXDLIN( 769)				Float za = this1;
HXDLIN( 769)				Float f2;
HXDLIN( 769)				bool f3;
HXDLIN( 769)				if ((gamma >= 0)) {
HXLINE( 769)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f3 = false;
            				}
HXDLIN( 769)				if (f3) {
HXLINE( 769)					f2 = gamma;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f2 = a;
            					}
            					else {
HXLINE( 769)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this2 = f2;
HXDLIN( 769)				Float zb = this2;
HXDLIN( 769)				Float fa = za;
HXDLIN( 769)				Float fb = zb;
HXDLIN( 769)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 769)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 769)				bool clockwise = (fa < fb);
HXDLIN( 769)				Float dif1;
HXDLIN( 769)				if (clockwise) {
HXLINE( 769)					dif1 = theta;
            				}
            				else {
HXLINE( 769)					dif1 = -(theta);
            				}
HXDLIN( 769)				if (smallest) {
HXLINE( 769)					dif = dif1;
            				}
            				else {
HXLINE( 769)					if (clockwise) {
HXLINE( 769)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 769)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 769)				Float f;
HXDLIN( 769)				bool f1;
HXDLIN( 769)				if ((beta >= 0)) {
HXLINE( 769)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f1 = false;
            				}
HXDLIN( 769)				if (f1) {
HXLINE( 769)					f = beta;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f = a;
            					}
            					else {
HXLINE( 769)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this1 = f;
HXDLIN( 769)				Float za = this1;
HXDLIN( 769)				Float f2;
HXDLIN( 769)				bool f3;
HXDLIN( 769)				if ((gamma >= 0)) {
HXLINE( 769)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 769)					f3 = false;
            				}
HXDLIN( 769)				if (f3) {
HXLINE( 769)					f2 = gamma;
            				}
            				else {
HXLINE( 769)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 769)					if ((a >= 0)) {
HXLINE( 769)						f2 = a;
            					}
            					else {
HXLINE( 769)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 769)				Float this2 = f2;
HXDLIN( 769)				Float zb = this2;
HXDLIN( 769)				Float fa = za;
HXDLIN( 769)				Float fb = zb;
HXDLIN( 769)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 769)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 769)				bool clockwise = (fa < fb);
HXDLIN( 769)				Float dif1;
HXDLIN( 769)				if (clockwise) {
HXLINE( 769)					dif1 = theta;
            				}
            				else {
HXLINE( 769)					dif1 = -(theta);
            				}
HXDLIN( 769)				if (largest) {
HXLINE( 769)					dif = dif1;
            				}
            				else {
HXLINE( 769)					if (clockwise) {
HXLINE( 769)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 769)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 770)		bool positive = (dif >= 0);
HXLINE( 771)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 773)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 774)		Float angle = beta;
HXLINE( 775)		Float cx;
HXLINE( 776)		Float cy;
HXLINE( 777)		Float bx = ( (Float)(0) );
HXLINE( 778)		Float by = ( (Float)(0) );
HXLINE( 779)		{
HXLINE( 779)			int _g = 0;
HXDLIN( 779)			int _g1 = (totalSteps + 1);
HXDLIN( 779)			while((_g < _g1)){
HXLINE( 779)				_g = (_g + 1);
HXDLIN( 779)				int i = (_g - 1);
HXLINE( 780)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 781)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 782)				if ((i != 0)) {
HXLINE( 783)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            				}
HXLINE( 785)				angle = (angle + step1);
HXLINE( 786)				bx = cx;
HXLINE( 787)				by = cy;
            			}
            		}
HXLINE( 789)		return totalSteps;
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,pie,return )

int Contour_obj::pieX(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer,::Array< Float > edgePoly,::hx::Null< int >  __o_color, ::Dynamic __o_sides){
            		int color = __o_color.Default(-1);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_801_pieX)
HXLINE( 803)		Float pi = ::Math_obj::PI;
HXLINE( 804)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 805)		Float dif;
HXDLIN( 805)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 805)				Float f;
HXDLIN( 805)				bool f1;
HXDLIN( 805)				if ((beta >= 0)) {
HXLINE( 805)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f1 = false;
            				}
HXDLIN( 805)				if (f1) {
HXLINE( 805)					f = beta;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f = a;
            					}
            					else {
HXLINE( 805)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this1 = f;
HXDLIN( 805)				Float za = this1;
HXDLIN( 805)				Float f2;
HXDLIN( 805)				bool f3;
HXDLIN( 805)				if ((gamma >= 0)) {
HXLINE( 805)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f3 = false;
            				}
HXDLIN( 805)				if (f3) {
HXLINE( 805)					f2 = gamma;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f2 = a;
            					}
            					else {
HXLINE( 805)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this2 = f2;
HXDLIN( 805)				Float zb = this2;
HXDLIN( 805)				Float fa = za;
HXDLIN( 805)				Float fb = zb;
HXDLIN( 805)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 805)				bool clockwise = (fa < fb);
HXDLIN( 805)				Float dif1;
HXDLIN( 805)				if (clockwise) {
HXLINE( 805)					dif1 = theta;
            				}
            				else {
HXLINE( 805)					dif1 = -(theta);
            				}
HXDLIN( 805)				if ((dif1 > 0)) {
HXLINE( 805)					dif = dif1;
            				}
            				else {
HXLINE( 805)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 805)				Float f;
HXDLIN( 805)				bool f1;
HXDLIN( 805)				if ((beta >= 0)) {
HXLINE( 805)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f1 = false;
            				}
HXDLIN( 805)				if (f1) {
HXLINE( 805)					f = beta;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f = a;
            					}
            					else {
HXLINE( 805)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this1 = f;
HXDLIN( 805)				Float za = this1;
HXDLIN( 805)				Float f2;
HXDLIN( 805)				bool f3;
HXDLIN( 805)				if ((gamma >= 0)) {
HXLINE( 805)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f3 = false;
            				}
HXDLIN( 805)				if (f3) {
HXLINE( 805)					f2 = gamma;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f2 = a;
            					}
            					else {
HXLINE( 805)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this2 = f2;
HXDLIN( 805)				Float zb = this2;
HXDLIN( 805)				Float fa = za;
HXDLIN( 805)				Float fb = zb;
HXDLIN( 805)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 805)				bool clockwise = (fa < fb);
HXDLIN( 805)				Float dif1;
HXDLIN( 805)				if (clockwise) {
HXLINE( 805)					dif1 = theta;
            				}
            				else {
HXLINE( 805)					dif1 = -(theta);
            				}
HXDLIN( 805)				if ((dif1 < 0)) {
HXLINE( 805)					dif = dif1;
            				}
            				else {
HXLINE( 805)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 805)				Float f;
HXDLIN( 805)				bool f1;
HXDLIN( 805)				if ((beta >= 0)) {
HXLINE( 805)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f1 = false;
            				}
HXDLIN( 805)				if (f1) {
HXLINE( 805)					f = beta;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f = a;
            					}
            					else {
HXLINE( 805)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this1 = f;
HXDLIN( 805)				Float za = this1;
HXDLIN( 805)				Float f2;
HXDLIN( 805)				bool f3;
HXDLIN( 805)				if ((gamma >= 0)) {
HXLINE( 805)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f3 = false;
            				}
HXDLIN( 805)				if (f3) {
HXLINE( 805)					f2 = gamma;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f2 = a;
            					}
            					else {
HXLINE( 805)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this2 = f2;
HXDLIN( 805)				Float zb = this2;
HXDLIN( 805)				Float fa = za;
HXDLIN( 805)				Float fb = zb;
HXDLIN( 805)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 805)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 805)				bool clockwise = (fa < fb);
HXDLIN( 805)				Float dif1;
HXDLIN( 805)				if (clockwise) {
HXLINE( 805)					dif1 = theta;
            				}
            				else {
HXLINE( 805)					dif1 = -(theta);
            				}
HXDLIN( 805)				if (smallest) {
HXLINE( 805)					dif = dif1;
            				}
            				else {
HXLINE( 805)					if (clockwise) {
HXLINE( 805)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 805)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 805)				Float f;
HXDLIN( 805)				bool f1;
HXDLIN( 805)				if ((beta >= 0)) {
HXLINE( 805)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f1 = false;
            				}
HXDLIN( 805)				if (f1) {
HXLINE( 805)					f = beta;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f = a;
            					}
            					else {
HXLINE( 805)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this1 = f;
HXDLIN( 805)				Float za = this1;
HXDLIN( 805)				Float f2;
HXDLIN( 805)				bool f3;
HXDLIN( 805)				if ((gamma >= 0)) {
HXLINE( 805)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 805)					f3 = false;
            				}
HXDLIN( 805)				if (f3) {
HXLINE( 805)					f2 = gamma;
            				}
            				else {
HXLINE( 805)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 805)					if ((a >= 0)) {
HXLINE( 805)						f2 = a;
            					}
            					else {
HXLINE( 805)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 805)				Float this2 = f2;
HXDLIN( 805)				Float zb = this2;
HXDLIN( 805)				Float fa = za;
HXDLIN( 805)				Float fb = zb;
HXDLIN( 805)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 805)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 805)				bool clockwise = (fa < fb);
HXDLIN( 805)				Float dif1;
HXDLIN( 805)				if (clockwise) {
HXLINE( 805)					dif1 = theta;
            				}
            				else {
HXLINE( 805)					dif1 = -(theta);
            				}
HXDLIN( 805)				if (largest) {
HXLINE( 805)					dif = dif1;
            				}
            				else {
HXLINE( 805)					if (clockwise) {
HXLINE( 805)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 805)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 806)		bool positive = (dif >= 0);
HXLINE( 807)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 809)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 810)		Float angle = beta;
HXLINE( 811)		Float cx;
HXLINE( 812)		Float cy;
HXLINE( 813)		Float bx = ( (Float)(0) );
HXLINE( 814)		Float by = ( (Float)(0) );
HXLINE( 815)		int p2 = edgePoly->length;
HXLINE( 816)		{
HXLINE( 816)			int _g = 0;
HXDLIN( 816)			int _g1 = (totalSteps + 1);
HXDLIN( 816)			while((_g < _g1)){
HXLINE( 816)				_g = (_g + 1);
HXDLIN( 816)				int i = (_g - 1);
HXLINE( 817)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 818)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 819)				p2 = (p2 + 1);
HXDLIN( 819)				edgePoly[(p2 - 1)] = cx;
HXLINE( 820)				p2 = (p2 + 1);
HXDLIN( 820)				edgePoly[(p2 - 1)] = cy;
HXLINE( 821)				if ((i != 0)) {
HXLINE( 822)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            				}
HXLINE( 824)				angle = (angle + step1);
HXLINE( 825)				bx = cx;
HXLINE( 826)				by = cy;
            			}
            		}
HXLINE( 828)		return totalSteps;
            	}


HX_DEFINE_DYNAMIC_FUNC9(Contour_obj,pieX,return )

int Contour_obj::pieDifX(Float ax,Float ay,Float radius,Float beta,Float dif,::Array< Float > edgePoly,::hx::Null< int >  __o_color, ::Dynamic __o_sides){
            		int color = __o_color.Default(-1);
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_835_pieDifX)
HXLINE( 837)		Float pi = ::Math_obj::PI;
HXLINE( 838)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 839)		bool positive = (dif >= 0);
HXLINE( 840)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 842)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 843)		Float angle = beta;
HXLINE( 844)		Float cx;
HXLINE( 845)		Float cy;
HXLINE( 846)		Float bx = ( (Float)(0) );
HXLINE( 847)		Float by = ( (Float)(0) );
HXLINE( 848)		int p2 = edgePoly->length;
HXLINE( 849)		{
HXLINE( 849)			int _g = 0;
HXDLIN( 849)			int _g1 = (totalSteps + 1);
HXDLIN( 849)			while((_g < _g1)){
HXLINE( 849)				_g = (_g + 1);
HXDLIN( 849)				int i = (_g - 1);
HXLINE( 850)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 851)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 852)				p2 = (p2 + 1);
HXDLIN( 852)				edgePoly[(p2 - 1)] = cx;
HXLINE( 853)				p2 = (p2 + 1);
HXDLIN( 853)				edgePoly[(p2 - 1)] = cy;
HXLINE( 854)				if ((i != 0)) {
HXLINE( 855)					::cornerContour::IPen_obj::triangle2DFill(this->pen,ax,ay,bx,by,cx,cy,color);
            				}
HXLINE( 857)				angle = (angle + step1);
HXLINE( 858)				bx = cx;
HXLINE( 859)				by = cy;
            			}
            		}
HXLINE( 861)		return totalSteps;
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,pieDifX,return )

Float Contour_obj::smallDotScale;

Float Contour_obj::thetaCompute(Float px,Float py,Float qx,Float qy){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_166_thetaCompute)
HXDLIN( 166)		return ::Math_obj::atan2((py - qy),(px - qx));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Contour_obj,thetaCompute,return )

Float Contour_obj::dist(Float px,Float py,Float qx,Float qy){
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_169_dist)
HXLINE( 170)		Float x = (px - qx);
HXLINE( 171)		Float y = (py - qy);
HXLINE( 172)		return ((x * x) + (y * y));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Contour_obj,dist,return )


::hx::ObjectPtr< Contour_obj > Contour_obj::__new(::Dynamic pen_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Contour_obj > __this = new Contour_obj();
	__this->__construct(pen_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Contour_obj > Contour_obj::__alloc(::hx::Ctx *_hx_ctx,::Dynamic pen_,::hx::Null< int >  __o_endLine_) {
	Contour_obj *__this = (Contour_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Contour_obj), true, "cornerContour.Contour"));
	*(void **)__this = Contour_obj::_hx_vtable;
	__this->__construct(pen_,__o_endLine_);
	return __this;
}

Contour_obj::Contour_obj()
{
}

void Contour_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Contour);
	HX_MARK_MEMBER_NAME(debugCol0,"debugCol0");
	HX_MARK_MEMBER_NAME(debugCol1,"debugCol1");
	HX_MARK_MEMBER_NAME(debugCol2,"debugCol2");
	HX_MARK_MEMBER_NAME(debugCol3,"debugCol3");
	HX_MARK_MEMBER_NAME(debugCol4,"debugCol4");
	HX_MARK_MEMBER_NAME(debugCol5,"debugCol5");
	HX_MARK_MEMBER_NAME(debugCol6,"debugCol6");
	HX_MARK_MEMBER_NAME(debugCol7,"debugCol7");
	HX_MARK_MEMBER_NAME(debugCol8,"debugCol8");
	HX_MARK_MEMBER_NAME(debugCol9,"debugCol9");
	HX_MARK_MEMBER_NAME(debugCol10,"debugCol10");
	HX_MARK_MEMBER_NAME(debugCol11,"debugCol11");
	HX_MARK_MEMBER_NAME(debugCol12,"debugCol12");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(penultimateCX,"penultimateCX");
	HX_MARK_MEMBER_NAME(penultimateCY,"penultimateCY");
	HX_MARK_MEMBER_NAME(lastClockX,"lastClockX");
	HX_MARK_MEMBER_NAME(lastClockY,"lastClockY");
	HX_MARK_MEMBER_NAME(penultimateAX,"penultimateAX");
	HX_MARK_MEMBER_NAME(penultimateAY,"penultimateAY");
	HX_MARK_MEMBER_NAME(lastAntiX,"lastAntiX");
	HX_MARK_MEMBER_NAME(lastAntiY,"lastAntiY");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(ax,"ax");
	HX_MARK_MEMBER_NAME(ay,"ay");
	HX_MARK_MEMBER_NAME(bx,"bx");
	HX_MARK_MEMBER_NAME(by,"by");
	HX_MARK_MEMBER_NAME(cx,"cx");
	HX_MARK_MEMBER_NAME(cy,"cy");
	HX_MARK_MEMBER_NAME(dx,"dx");
	HX_MARK_MEMBER_NAME(dy,"dy");
	HX_MARK_MEMBER_NAME(ex,"ex");
	HX_MARK_MEMBER_NAME(ey,"ey");
	HX_MARK_MEMBER_NAME(dxPrev,"dxPrev");
	HX_MARK_MEMBER_NAME(dyPrev,"dyPrev");
	HX_MARK_MEMBER_NAME(exPrev,"exPrev");
	HX_MARK_MEMBER_NAME(eyPrev,"eyPrev");
	HX_MARK_MEMBER_NAME(dxOld,"dxOld");
	HX_MARK_MEMBER_NAME(dyOld,"dyOld");
	HX_MARK_MEMBER_NAME(exOld,"exOld");
	HX_MARK_MEMBER_NAME(eyOld,"eyOld");
	HX_MARK_MEMBER_NAME(jx,"jx");
	HX_MARK_MEMBER_NAME(jy,"jy");
	HX_MARK_MEMBER_NAME(lastClock,"lastClock");
	HX_MARK_MEMBER_NAME(jxOld,"jxOld");
	HX_MARK_MEMBER_NAME(jyOld,"jyOld");
	HX_MARK_MEMBER_NAME(kax,"kax");
	HX_MARK_MEMBER_NAME(kay,"kay");
	HX_MARK_MEMBER_NAME(kbx,"kbx");
	HX_MARK_MEMBER_NAME(kby,"kby");
	HX_MARK_MEMBER_NAME(kcx,"kcx");
	HX_MARK_MEMBER_NAME(kcy,"kcy");
	HX_MARK_MEMBER_NAME(ncx,"ncx");
	HX_MARK_MEMBER_NAME(ncy,"ncy");
	HX_MARK_MEMBER_NAME(quadIndex,"quadIndex");
	HX_MARK_MEMBER_NAME(angleA,"angleA");
	HX_MARK_MEMBER_NAME(halfA,"halfA");
	HX_MARK_MEMBER_NAME(beta,"beta");
	HX_MARK_MEMBER_NAME(r,"r");
	HX_MARK_MEMBER_NAME(theta,"theta");
	HX_MARK_MEMBER_NAME(angle1,"angle1");
	HX_MARK_MEMBER_NAME(angle2,"angle2");
	HX_MARK_MEMBER_NAME(count,"count");
	HX_MARK_MEMBER_NAME(counter,"counter");
	HX_MARK_END_CLASS();
}

void Contour_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(debugCol0,"debugCol0");
	HX_VISIT_MEMBER_NAME(debugCol1,"debugCol1");
	HX_VISIT_MEMBER_NAME(debugCol2,"debugCol2");
	HX_VISIT_MEMBER_NAME(debugCol3,"debugCol3");
	HX_VISIT_MEMBER_NAME(debugCol4,"debugCol4");
	HX_VISIT_MEMBER_NAME(debugCol5,"debugCol5");
	HX_VISIT_MEMBER_NAME(debugCol6,"debugCol6");
	HX_VISIT_MEMBER_NAME(debugCol7,"debugCol7");
	HX_VISIT_MEMBER_NAME(debugCol8,"debugCol8");
	HX_VISIT_MEMBER_NAME(debugCol9,"debugCol9");
	HX_VISIT_MEMBER_NAME(debugCol10,"debugCol10");
	HX_VISIT_MEMBER_NAME(debugCol11,"debugCol11");
	HX_VISIT_MEMBER_NAME(debugCol12,"debugCol12");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(penultimateCX,"penultimateCX");
	HX_VISIT_MEMBER_NAME(penultimateCY,"penultimateCY");
	HX_VISIT_MEMBER_NAME(lastClockX,"lastClockX");
	HX_VISIT_MEMBER_NAME(lastClockY,"lastClockY");
	HX_VISIT_MEMBER_NAME(penultimateAX,"penultimateAX");
	HX_VISIT_MEMBER_NAME(penultimateAY,"penultimateAY");
	HX_VISIT_MEMBER_NAME(lastAntiX,"lastAntiX");
	HX_VISIT_MEMBER_NAME(lastAntiY,"lastAntiY");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(ax,"ax");
	HX_VISIT_MEMBER_NAME(ay,"ay");
	HX_VISIT_MEMBER_NAME(bx,"bx");
	HX_VISIT_MEMBER_NAME(by,"by");
	HX_VISIT_MEMBER_NAME(cx,"cx");
	HX_VISIT_MEMBER_NAME(cy,"cy");
	HX_VISIT_MEMBER_NAME(dx,"dx");
	HX_VISIT_MEMBER_NAME(dy,"dy");
	HX_VISIT_MEMBER_NAME(ex,"ex");
	HX_VISIT_MEMBER_NAME(ey,"ey");
	HX_VISIT_MEMBER_NAME(dxPrev,"dxPrev");
	HX_VISIT_MEMBER_NAME(dyPrev,"dyPrev");
	HX_VISIT_MEMBER_NAME(exPrev,"exPrev");
	HX_VISIT_MEMBER_NAME(eyPrev,"eyPrev");
	HX_VISIT_MEMBER_NAME(dxOld,"dxOld");
	HX_VISIT_MEMBER_NAME(dyOld,"dyOld");
	HX_VISIT_MEMBER_NAME(exOld,"exOld");
	HX_VISIT_MEMBER_NAME(eyOld,"eyOld");
	HX_VISIT_MEMBER_NAME(jx,"jx");
	HX_VISIT_MEMBER_NAME(jy,"jy");
	HX_VISIT_MEMBER_NAME(lastClock,"lastClock");
	HX_VISIT_MEMBER_NAME(jxOld,"jxOld");
	HX_VISIT_MEMBER_NAME(jyOld,"jyOld");
	HX_VISIT_MEMBER_NAME(kax,"kax");
	HX_VISIT_MEMBER_NAME(kay,"kay");
	HX_VISIT_MEMBER_NAME(kbx,"kbx");
	HX_VISIT_MEMBER_NAME(kby,"kby");
	HX_VISIT_MEMBER_NAME(kcx,"kcx");
	HX_VISIT_MEMBER_NAME(kcy,"kcy");
	HX_VISIT_MEMBER_NAME(ncx,"ncx");
	HX_VISIT_MEMBER_NAME(ncy,"ncy");
	HX_VISIT_MEMBER_NAME(quadIndex,"quadIndex");
	HX_VISIT_MEMBER_NAME(angleA,"angleA");
	HX_VISIT_MEMBER_NAME(halfA,"halfA");
	HX_VISIT_MEMBER_NAME(beta,"beta");
	HX_VISIT_MEMBER_NAME(r,"r");
	HX_VISIT_MEMBER_NAME(theta,"theta");
	HX_VISIT_MEMBER_NAME(angle1,"angle1");
	HX_VISIT_MEMBER_NAME(angle2,"angle2");
	HX_VISIT_MEMBER_NAME(count,"count");
	HX_VISIT_MEMBER_NAME(counter,"counter");
}

::hx::Val Contour_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"r") ) { return ::hx::Val( r ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"ax") ) { return ::hx::Val( ax ); }
		if (HX_FIELD_EQ(inName,"ay") ) { return ::hx::Val( ay ); }
		if (HX_FIELD_EQ(inName,"bx") ) { return ::hx::Val( bx ); }
		if (HX_FIELD_EQ(inName,"by") ) { return ::hx::Val( by ); }
		if (HX_FIELD_EQ(inName,"cx") ) { return ::hx::Val( cx ); }
		if (HX_FIELD_EQ(inName,"cy") ) { return ::hx::Val( cy ); }
		if (HX_FIELD_EQ(inName,"dx") ) { return ::hx::Val( dx ); }
		if (HX_FIELD_EQ(inName,"dy") ) { return ::hx::Val( dy ); }
		if (HX_FIELD_EQ(inName,"ex") ) { return ::hx::Val( ex ); }
		if (HX_FIELD_EQ(inName,"ey") ) { return ::hx::Val( ey ); }
		if (HX_FIELD_EQ(inName,"jx") ) { return ::hx::Val( jx ); }
		if (HX_FIELD_EQ(inName,"jy") ) { return ::hx::Val( jy ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"kax") ) { return ::hx::Val( kax ); }
		if (HX_FIELD_EQ(inName,"kay") ) { return ::hx::Val( kay ); }
		if (HX_FIELD_EQ(inName,"kbx") ) { return ::hx::Val( kbx ); }
		if (HX_FIELD_EQ(inName,"kby") ) { return ::hx::Val( kby ); }
		if (HX_FIELD_EQ(inName,"kcx") ) { return ::hx::Val( kcx ); }
		if (HX_FIELD_EQ(inName,"kcy") ) { return ::hx::Val( kcy ); }
		if (HX_FIELD_EQ(inName,"ncx") ) { return ::hx::Val( ncx ); }
		if (HX_FIELD_EQ(inName,"ncy") ) { return ::hx::Val( ncy ); }
		if (HX_FIELD_EQ(inName,"end") ) { return ::hx::Val( end_dyn() ); }
		if (HX_FIELD_EQ(inName,"pie") ) { return ::hx::Val( pie_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"beta") ) { return ::hx::Val( beta ); }
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line_dyn() ); }
		if (HX_FIELD_EQ(inName,"pieX") ) { return ::hx::Val( pieX_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dxOld") ) { return ::hx::Val( dxOld ); }
		if (HX_FIELD_EQ(inName,"dyOld") ) { return ::hx::Val( dyOld ); }
		if (HX_FIELD_EQ(inName,"exOld") ) { return ::hx::Val( exOld ); }
		if (HX_FIELD_EQ(inName,"eyOld") ) { return ::hx::Val( eyOld ); }
		if (HX_FIELD_EQ(inName,"jxOld") ) { return ::hx::Val( jxOld ); }
		if (HX_FIELD_EQ(inName,"jyOld") ) { return ::hx::Val( jyOld ); }
		if (HX_FIELD_EQ(inName,"halfA") ) { return ::hx::Val( halfA ); }
		if (HX_FIELD_EQ(inName,"theta") ) { return ::hx::Val( theta ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		if (HX_FIELD_EQ(inName,"count") ) { return ::hx::Val( count ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"dxPrev") ) { return ::hx::Val( dxPrev ); }
		if (HX_FIELD_EQ(inName,"dyPrev") ) { return ::hx::Val( dyPrev ); }
		if (HX_FIELD_EQ(inName,"exPrev") ) { return ::hx::Val( exPrev ); }
		if (HX_FIELD_EQ(inName,"eyPrev") ) { return ::hx::Val( eyPrev ); }
		if (HX_FIELD_EQ(inName,"angleA") ) { return ::hx::Val( angleA ); }
		if (HX_FIELD_EQ(inName,"angle1") ) { return ::hx::Val( angle1 ); }
		if (HX_FIELD_EQ(inName,"angle2") ) { return ::hx::Val( angle2 ); }
		if (HX_FIELD_EQ(inName,"addPie") ) { return ::hx::Val( addPie_dyn() ); }
		if (HX_FIELD_EQ(inName,"addDot") ) { return ::hx::Val( addDot_dyn() ); }
		if (HX_FIELD_EQ(inName,"circle") ) { return ::hx::Val( circle_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		if (HX_FIELD_EQ(inName,"addPieX") ) { return ::hx::Val( addPieX_dyn() ); }
		if (HX_FIELD_EQ(inName,"counter") ) { return ::hx::Val( counter ); }
		if (HX_FIELD_EQ(inName,"pieDifX") ) { return ::hx::Val( pieDifX_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"computeJ") ) { return ::hx::Val( computeJ_dyn() ); }
		if (HX_FIELD_EQ(inName,"endEdges") ) { return ::hx::Val( endEdges_dyn() ); }
		if (HX_FIELD_EQ(inName,"addQuads") ) { return ::hx::Val( addQuads_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"debugCol0") ) { return ::hx::Val( debugCol0 ); }
		if (HX_FIELD_EQ(inName,"debugCol1") ) { return ::hx::Val( debugCol1 ); }
		if (HX_FIELD_EQ(inName,"debugCol2") ) { return ::hx::Val( debugCol2 ); }
		if (HX_FIELD_EQ(inName,"debugCol3") ) { return ::hx::Val( debugCol3 ); }
		if (HX_FIELD_EQ(inName,"debugCol4") ) { return ::hx::Val( debugCol4 ); }
		if (HX_FIELD_EQ(inName,"debugCol5") ) { return ::hx::Val( debugCol5 ); }
		if (HX_FIELD_EQ(inName,"debugCol6") ) { return ::hx::Val( debugCol6 ); }
		if (HX_FIELD_EQ(inName,"debugCol7") ) { return ::hx::Val( debugCol7 ); }
		if (HX_FIELD_EQ(inName,"debugCol8") ) { return ::hx::Val( debugCol8 ); }
		if (HX_FIELD_EQ(inName,"debugCol9") ) { return ::hx::Val( debugCol9 ); }
		if (HX_FIELD_EQ(inName,"lastAntiX") ) { return ::hx::Val( lastAntiX ); }
		if (HX_FIELD_EQ(inName,"lastAntiY") ) { return ::hx::Val( lastAntiY ); }
		if (HX_FIELD_EQ(inName,"lastClock") ) { return ::hx::Val( lastClock ); }
		if (HX_FIELD_EQ(inName,"quadIndex") ) { return ::hx::Val( quadIndex ); }
		if (HX_FIELD_EQ(inName,"computeDE") ) { return ::hx::Val( computeDE_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"debugCol10") ) { return ::hx::Val( debugCol10 ); }
		if (HX_FIELD_EQ(inName,"debugCol11") ) { return ::hx::Val( debugCol11 ); }
		if (HX_FIELD_EQ(inName,"debugCol12") ) { return ::hx::Val( debugCol12 ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"lastClockX") ) { return ::hx::Val( lastClockX ); }
		if (HX_FIELD_EQ(inName,"lastClockY") ) { return ::hx::Val( lastClockY ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		if (HX_FIELD_EQ(inName,"overlapQuad") ) { return ::hx::Val( overlapQuad_dyn() ); }
		if (HX_FIELD_EQ(inName,"isClockwise") ) { return ::hx::Val( isClockwise_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"triangleJoin") ) { return ::hx::Val( triangleJoin_dyn() ); }
		if (HX_FIELD_EQ(inName,"addPieXstart") ) { return ::hx::Val( addPieXstart_dyn() ); }
		if (HX_FIELD_EQ(inName,"connectQuads") ) { return ::hx::Val( connectQuads_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"penultimateCX") ) { return ::hx::Val( penultimateCX ); }
		if (HX_FIELD_EQ(inName,"penultimateCY") ) { return ::hx::Val( penultimateCY ); }
		if (HX_FIELD_EQ(inName,"penultimateAX") ) { return ::hx::Val( penultimateAX ); }
		if (HX_FIELD_EQ(inName,"penultimateAY") ) { return ::hx::Val( penultimateAY ); }
		if (HX_FIELD_EQ(inName,"anglesCompute") ) { return ::hx::Val( anglesCompute_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"triangle2DFill") ) { return ::hx::Val( triangle2DFill_dyn() ); }
		if (HX_FIELD_EQ(inName,"storeLastQuads") ) { return ::hx::Val( storeLastQuads_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"thetaComputeAdj") ) { return ::hx::Val( thetaComputeAdj_dyn() ); }
		if (HX_FIELD_EQ(inName,"addInitialQuads") ) { return ::hx::Val( addInitialQuads_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"addSmallTriangles") ) { return ::hx::Val( addSmallTriangles_dyn() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"triangle2DFillangleCorners") ) { return ::hx::Val( triangle2DFillangleCorners_dyn() ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"connectQuadsWhenQuadsOverlay") ) { return ::hx::Val( connectQuadsWhenQuadsOverlay_dyn() ); }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"triangle2DFillangleCornersLess") ) { return ::hx::Val( triangle2DFillangleCornersLess_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Contour_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"dist") ) { outValue = dist_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"thetaCompute") ) { outValue = thetaCompute_dyn(); return true; }
	}
	return false;
}

::hx::Val Contour_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"r") ) { r=inValue.Cast< Float >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"ax") ) { ax=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ay") ) { ay=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bx") ) { bx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"by") ) { by=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cx") ) { cx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cy") ) { cy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dx") ) { dx=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dy") ) { dy=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ex") ) { ex=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ey") ) { ey=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jx") ) { jx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jy") ) { jy=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast< ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kax") ) { kax=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kay") ) { kay=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kbx") ) { kbx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kby") ) { kby=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kcx") ) { kcx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kcy") ) { kcy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ncx") ) { ncx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ncy") ) { ncy=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"beta") ) { beta=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dxOld") ) { dxOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dyOld") ) { dyOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"exOld") ) { exOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"eyOld") ) { eyOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jxOld") ) { jxOld=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jyOld") ) { jyOld=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"halfA") ) { halfA=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"theta") ) { theta=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"dxPrev") ) { dxPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dyPrev") ) { dyPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"exPrev") ) { exPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"eyPrev") ) { eyPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angleA") ) { angleA=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angle1") ) { angle1=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angle2") ) { angle2=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"counter") ) { counter=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"debugCol0") ) { debugCol0=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol1") ) { debugCol1=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol2") ) { debugCol2=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol3") ) { debugCol3=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol4") ) { debugCol4=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol5") ) { debugCol5=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol6") ) { debugCol6=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol7") ) { debugCol7=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol8") ) { debugCol8=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol9") ) { debugCol9=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastAntiX") ) { lastAntiX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastAntiY") ) { lastAntiY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastClock") ) { lastClock=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"quadIndex") ) { quadIndex=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"debugCol10") ) { debugCol10=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol11") ) { debugCol11=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol12") ) { debugCol12=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastClockX") ) { lastClockX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastClockY") ) { lastClockY=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"penultimateCX") ) { penultimateCX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"penultimateCY") ) { penultimateCY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"penultimateAX") ) { penultimateAX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"penultimateAY") ) { penultimateAY=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Contour_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("debugCol0",e3,5b,10,25));
	outFields->push(HX_("debugCol1",e4,5b,10,25));
	outFields->push(HX_("debugCol2",e5,5b,10,25));
	outFields->push(HX_("debugCol3",e6,5b,10,25));
	outFields->push(HX_("debugCol4",e7,5b,10,25));
	outFields->push(HX_("debugCol5",e8,5b,10,25));
	outFields->push(HX_("debugCol6",e9,5b,10,25));
	outFields->push(HX_("debugCol7",ea,5b,10,25));
	outFields->push(HX_("debugCol8",eb,5b,10,25));
	outFields->push(HX_("debugCol9",ec,5b,10,25));
	outFields->push(HX_("debugCol10",cc,0b,40,49));
	outFields->push(HX_("debugCol11",cd,0b,40,49));
	outFields->push(HX_("debugCol12",ce,0b,40,49));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("penultimateCX",5f,f6,17,69));
	outFields->push(HX_("penultimateCY",60,f6,17,69));
	outFields->push(HX_("lastClockX",c0,6d,20,d9));
	outFields->push(HX_("lastClockY",c1,6d,20,d9));
	outFields->push(HX_("penultimateAX",a1,f4,17,69));
	outFields->push(HX_("penultimateAY",a2,f4,17,69));
	outFields->push(HX_("lastAntiX",40,4c,99,6f));
	outFields->push(HX_("lastAntiY",41,4c,99,6f));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("ax",f7,54,00,00));
	outFields->push(HX_("ay",f8,54,00,00));
	outFields->push(HX_("bx",d6,55,00,00));
	outFields->push(HX_("by",d7,55,00,00));
	outFields->push(HX_("cx",b5,56,00,00));
	outFields->push(HX_("cy",b6,56,00,00));
	outFields->push(HX_("dx",94,57,00,00));
	outFields->push(HX_("dy",95,57,00,00));
	outFields->push(HX_("ex",73,58,00,00));
	outFields->push(HX_("ey",74,58,00,00));
	outFields->push(HX_("dxPrev",a7,9c,fd,48));
	outFields->push(HX_("dyPrev",28,31,64,dc));
	outFields->push(HX_("exPrev",06,f9,58,af));
	outFields->push(HX_("eyPrev",87,8d,bf,42));
	outFields->push(HX_("dxOld",73,ed,9f,e3));
	outFields->push(HX_("dyOld",12,24,49,e4));
	outFields->push(HX_("exOld",f4,81,06,77));
	outFields->push(HX_("eyOld",93,b8,af,77));
	outFields->push(HX_("jx",ce,5c,00,00));
	outFields->push(HX_("jy",cf,5c,00,00));
	outFields->push(HX_("lastClock",98,37,10,95));
	outFields->push(HX_("jxOld",79,68,07,58));
	outFields->push(HX_("jyOld",18,9f,b0,58));
	outFields->push(HX_("kax",22,86,51,00));
	outFields->push(HX_("kay",23,86,51,00));
	outFields->push(HX_("kbx",01,87,51,00));
	outFields->push(HX_("kby",02,87,51,00));
	outFields->push(HX_("kcx",e0,87,51,00));
	outFields->push(HX_("kcy",e1,87,51,00));
	outFields->push(HX_("ncx",a3,ce,53,00));
	outFields->push(HX_("ncy",a4,ce,53,00));
	outFields->push(HX_("quadIndex",cb,a0,31,4f));
	outFields->push(HX_("angleA",0e,15,19,63));
	outFields->push(HX_("halfA",2e,53,1c,22));
	outFields->push(HX_("beta",f0,f1,13,41));
	outFields->push(HX_("r",72,00,00,00));
	outFields->push(HX_("theta",1e,84,86,0f));
	outFields->push(HX_("angle1",fe,14,19,63));
	outFields->push(HX_("angle2",ff,14,19,63));
	outFields->push(HX_("count",cf,44,63,4a));
	outFields->push(HX_("counter",fc,ae,59,1d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Contour_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol0),HX_("debugCol0",e3,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol1),HX_("debugCol1",e4,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol2),HX_("debugCol2",e5,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol3),HX_("debugCol3",e6,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol4),HX_("debugCol4",e7,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol5),HX_("debugCol5",e8,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol6),HX_("debugCol6",e9,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol7),HX_("debugCol7",ea,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol8),HX_("debugCol8",eb,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol9),HX_("debugCol9",ec,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol10),HX_("debugCol10",cc,0b,40,49)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol11),HX_("debugCol11",cd,0b,40,49)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol12),HX_("debugCol12",ce,0b,40,49)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Contour_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Contour_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateCX),HX_("penultimateCX",5f,f6,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateCY),HX_("penultimateCY",60,f6,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastClockX),HX_("lastClockX",c0,6d,20,d9)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastClockY),HX_("lastClockY",c1,6d,20,d9)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateAX),HX_("penultimateAX",a1,f4,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateAY),HX_("penultimateAY",a2,f4,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastAntiX),HX_("lastAntiX",40,4c,99,6f)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastAntiY),HX_("lastAntiY",41,4c,99,6f)},
	{::hx::fsObject /* ::Dynamic */ ,(int)offsetof(Contour_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Contour_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ax),HX_("ax",f7,54,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ay),HX_("ay",f8,54,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,bx),HX_("bx",d6,55,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,by),HX_("by",d7,55,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,cx),HX_("cx",b5,56,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,cy),HX_("cy",b6,56,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dx),HX_("dx",94,57,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dy),HX_("dy",95,57,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,ex),HX_("ex",73,58,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,ey),HX_("ey",74,58,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dxPrev),HX_("dxPrev",a7,9c,fd,48)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dyPrev),HX_("dyPrev",28,31,64,dc)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,exPrev),HX_("exPrev",06,f9,58,af)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,eyPrev),HX_("eyPrev",87,8d,bf,42)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dxOld),HX_("dxOld",73,ed,9f,e3)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dyOld),HX_("dyOld",12,24,49,e4)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,exOld),HX_("exOld",f4,81,06,77)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,eyOld),HX_("eyOld",93,b8,af,77)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jx),HX_("jx",ce,5c,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jy),HX_("jy",cf,5c,00,00)},
	{::hx::fsBool,(int)offsetof(Contour_obj,lastClock),HX_("lastClock",98,37,10,95)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jxOld),HX_("jxOld",79,68,07,58)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jyOld),HX_("jyOld",18,9f,b0,58)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kax),HX_("kax",22,86,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kay),HX_("kay",23,86,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kbx),HX_("kbx",01,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kby),HX_("kby",02,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kcx),HX_("kcx",e0,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kcy),HX_("kcy",e1,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ncx),HX_("ncx",a3,ce,53,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ncy),HX_("ncy",a4,ce,53,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,quadIndex),HX_("quadIndex",cb,a0,31,4f)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,angleA),HX_("angleA",0e,15,19,63)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,halfA),HX_("halfA",2e,53,1c,22)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,beta),HX_("beta",f0,f1,13,41)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,r),HX_("r",72,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,theta),HX_("theta",1e,84,86,0f)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,angle1),HX_("angle1",fe,14,19,63)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,angle2),HX_("angle2",ff,14,19,63)},
	{::hx::fsInt,(int)offsetof(Contour_obj,count),HX_("count",cf,44,63,4a)},
	{::hx::fsInt,(int)offsetof(Contour_obj,counter),HX_("counter",fc,ae,59,1d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Contour_obj_sStaticStorageInfo[] = {
	{::hx::fsFloat,(void *) &Contour_obj::smallDotScale,HX_("smallDotScale",28,77,1a,ec)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Contour_obj_sMemberFields[] = {
	HX_("debugCol0",e3,5b,10,25),
	HX_("debugCol1",e4,5b,10,25),
	HX_("debugCol2",e5,5b,10,25),
	HX_("debugCol3",e6,5b,10,25),
	HX_("debugCol4",e7,5b,10,25),
	HX_("debugCol5",e8,5b,10,25),
	HX_("debugCol6",e9,5b,10,25),
	HX_("debugCol7",ea,5b,10,25),
	HX_("debugCol8",eb,5b,10,25),
	HX_("debugCol9",ec,5b,10,25),
	HX_("debugCol10",cc,0b,40,49),
	HX_("debugCol11",cd,0b,40,49),
	HX_("debugCol12",ce,0b,40,49),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("penultimateCX",5f,f6,17,69),
	HX_("penultimateCY",60,f6,17,69),
	HX_("lastClockX",c0,6d,20,d9),
	HX_("lastClockY",c1,6d,20,d9),
	HX_("penultimateAX",a1,f4,17,69),
	HX_("penultimateAY",a2,f4,17,69),
	HX_("lastAntiX",40,4c,99,6f),
	HX_("lastAntiY",41,4c,99,6f),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("ax",f7,54,00,00),
	HX_("ay",f8,54,00,00),
	HX_("bx",d6,55,00,00),
	HX_("by",d7,55,00,00),
	HX_("cx",b5,56,00,00),
	HX_("cy",b6,56,00,00),
	HX_("dx",94,57,00,00),
	HX_("dy",95,57,00,00),
	HX_("ex",73,58,00,00),
	HX_("ey",74,58,00,00),
	HX_("dxPrev",a7,9c,fd,48),
	HX_("dyPrev",28,31,64,dc),
	HX_("exPrev",06,f9,58,af),
	HX_("eyPrev",87,8d,bf,42),
	HX_("dxOld",73,ed,9f,e3),
	HX_("dyOld",12,24,49,e4),
	HX_("exOld",f4,81,06,77),
	HX_("eyOld",93,b8,af,77),
	HX_("jx",ce,5c,00,00),
	HX_("jy",cf,5c,00,00),
	HX_("lastClock",98,37,10,95),
	HX_("jxOld",79,68,07,58),
	HX_("jyOld",18,9f,b0,58),
	HX_("kax",22,86,51,00),
	HX_("kay",23,86,51,00),
	HX_("kbx",01,87,51,00),
	HX_("kby",02,87,51,00),
	HX_("kcx",e0,87,51,00),
	HX_("kcy",e1,87,51,00),
	HX_("ncx",a3,ce,53,00),
	HX_("ncy",a4,ce,53,00),
	HX_("quadIndex",cb,a0,31,4f),
	HX_("angleA",0e,15,19,63),
	HX_("halfA",2e,53,1c,22),
	HX_("beta",f0,f1,13,41),
	HX_("r",72,00,00,00),
	HX_("theta",1e,84,86,0f),
	HX_("angle1",fe,14,19,63),
	HX_("angle2",ff,14,19,63),
	HX_("reset",cf,49,c8,e6),
	HX_("count",cf,44,63,4a),
	HX_("computeDE",b8,8e,b2,87),
	HX_("anglesCompute",17,82,c9,e2),
	HX_("thetaComputeAdj",ae,40,9d,e7),
	HX_("triangleJoin",d2,22,df,cf),
	HX_("overlapQuad",ee,77,e9,3a),
	HX_("end",db,03,4d,00),
	HX_("triangle2DFill",3d,7c,19,6e),
	HX_("addPieXstart",f5,ef,0d,da),
	HX_("addPieX",4d,2d,95,86),
	HX_("addPie",ab,68,06,9f),
	HX_("computeJ",f3,40,c6,85),
	HX_("addDot",e8,52,fd,9e),
	HX_("addSmallTriangles",e5,ec,80,f8),
	HX_("triangle2DFillangleCorners",28,53,7d,f1),
	HX_("triangle2DFillangleCornersLess",a1,46,b3,70),
	HX_("connectQuadsWhenQuadsOverlay",a0,62,6a,01),
	HX_("connectQuads",82,39,61,89),
	HX_("addInitialQuads",69,e2,46,a8),
	HX_("endEdges",bb,ff,dd,67),
	HX_("counter",fc,ae,59,1d),
	HX_("addQuads",eb,9b,44,d7),
	HX_("storeLastQuads",75,6b,ea,1d),
	HX_("isClockwise",a8,34,20,1b),
	HX_("line",f4,17,b3,47),
	HX_("circle",10,72,0d,56),
	HX_("pie",4c,58,55,00),
	HX_("pieX",8c,ea,57,4a),
	HX_("pieDifX",63,f6,97,81),
	::String(null()) };

static void Contour_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Contour_obj::smallDotScale,"smallDotScale");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Contour_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Contour_obj::smallDotScale,"smallDotScale");
};

#endif

::hx::Class Contour_obj::__mClass;

static ::String Contour_obj_sStaticFields[] = {
	HX_("smallDotScale",28,77,1a,ec),
	HX_("thetaCompute",f9,ca,c4,94),
	HX_("dist",66,67,69,42),
	::String(null())
};

void Contour_obj::__register()
{
	Contour_obj _hx_dummy;
	Contour_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("cornerContour.Contour",d1,46,a4,29);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Contour_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Contour_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Contour_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Contour_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Contour_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Contour_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Contour_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Contour_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Contour_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_a86754e404cc2b8f_83_boot)
HXDLIN(  83)		smallDotScale = ((Float)0.07);
            	}
}

} // end namespace cornerContour
